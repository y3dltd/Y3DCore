
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model PrintOrderTask
 * 
 */
export type PrintOrderTask = $Result.DefaultSelection<Prisma.$PrintOrderTaskPayload>
/**
 * Model AmazonCustomizationFile
 * 
 */
export type AmazonCustomizationFile = $Result.DefaultSelection<Prisma.$AmazonCustomizationFilePayload>
/**
 * Model system_logs
 * 
 */
export type system_logs = $Result.DefaultSelection<Prisma.$system_logsPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model ScriptRunLog
 * 
 */
export type ScriptRunLog = $Result.DefaultSelection<Prisma.$ScriptRunLogPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model SyncProgress
 * 
 */
export type SyncProgress = $Result.DefaultSelection<Prisma.$SyncProgressPayload>
/**
 * Model SyncMetrics
 * 
 */
export type SyncMetrics = $Result.DefaultSelection<Prisma.$SyncMetricsPayload>
/**
 * Model AiCallLog
 * 
 */
export type AiCallLog = $Result.DefaultSelection<Prisma.$AiCallLogPayload>
/**
 * Model Metric
 * 
 */
export type Metric = $Result.DefaultSelection<Prisma.$MetricPayload>
/**
 * Model AiReportDefinition
 * AI Reports System
 */
export type AiReportDefinition = $Result.DefaultSelection<Prisma.$AiReportDefinitionPayload>
/**
 * Model AiReportRun
 * 
 */
export type AiReportRun = $Result.DefaultSelection<Prisma.$AiReportRunPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const InternalOrderStatus: {
  new: 'new',
  processing: 'processing',
  printing: 'printing',
  completed: 'completed',
  cancelled: 'cancelled'
};

export type InternalOrderStatus = (typeof InternalOrderStatus)[keyof typeof InternalOrderStatus]


export const PrintTaskStatus: {
  pending: 'pending',
  in_progress: 'in_progress',
  completed: 'completed',
  cancelled: 'cancelled'
};

export type PrintTaskStatus = (typeof PrintTaskStatus)[keyof typeof PrintTaskStatus]


export const StlRenderStatus: {
  pending: 'pending',
  running: 'running',
  completed: 'completed',
  failed: 'failed'
};

export type StlRenderStatus = (typeof StlRenderStatus)[keyof typeof StlRenderStatus]

}

export type InternalOrderStatus = $Enums.InternalOrderStatus

export const InternalOrderStatus: typeof $Enums.InternalOrderStatus

export type PrintTaskStatus = $Enums.PrintTaskStatus

export const PrintTaskStatus: typeof $Enums.PrintTaskStatus

export type StlRenderStatus = $Enums.StlRenderStatus

export const StlRenderStatus: typeof $Enums.StlRenderStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Products
 * const products = await prisma.product.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Products
   * const products = await prisma.product.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.printOrderTask`: Exposes CRUD operations for the **PrintOrderTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrintOrderTasks
    * const printOrderTasks = await prisma.printOrderTask.findMany()
    * ```
    */
  get printOrderTask(): Prisma.PrintOrderTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.amazonCustomizationFile`: Exposes CRUD operations for the **AmazonCustomizationFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AmazonCustomizationFiles
    * const amazonCustomizationFiles = await prisma.amazonCustomizationFile.findMany()
    * ```
    */
  get amazonCustomizationFile(): Prisma.AmazonCustomizationFileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.system_logs`: Exposes CRUD operations for the **system_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more System_logs
    * const system_logs = await prisma.system_logs.findMany()
    * ```
    */
  get system_logs(): Prisma.system_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scriptRunLog`: Exposes CRUD operations for the **ScriptRunLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScriptRunLogs
    * const scriptRunLogs = await prisma.scriptRunLog.findMany()
    * ```
    */
  get scriptRunLog(): Prisma.ScriptRunLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.syncProgress`: Exposes CRUD operations for the **SyncProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncProgresses
    * const syncProgresses = await prisma.syncProgress.findMany()
    * ```
    */
  get syncProgress(): Prisma.SyncProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.syncMetrics`: Exposes CRUD operations for the **SyncMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncMetrics
    * const syncMetrics = await prisma.syncMetrics.findMany()
    * ```
    */
  get syncMetrics(): Prisma.SyncMetricsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiCallLog`: Exposes CRUD operations for the **AiCallLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiCallLogs
    * const aiCallLogs = await prisma.aiCallLog.findMany()
    * ```
    */
  get aiCallLog(): Prisma.AiCallLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.metric`: Exposes CRUD operations for the **Metric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Metrics
    * const metrics = await prisma.metric.findMany()
    * ```
    */
  get metric(): Prisma.MetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiReportDefinition`: Exposes CRUD operations for the **AiReportDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiReportDefinitions
    * const aiReportDefinitions = await prisma.aiReportDefinition.findMany()
    * ```
    */
  get aiReportDefinition(): Prisma.AiReportDefinitionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiReportRun`: Exposes CRUD operations for the **AiReportRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiReportRuns
    * const aiReportRuns = await prisma.aiReportRun.findMany()
    * ```
    */
  get aiReportRun(): Prisma.AiReportRunDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Product: 'Product',
    Order: 'Order',
    Customer: 'Customer',
    OrderItem: 'OrderItem',
    PrintOrderTask: 'PrintOrderTask',
    AmazonCustomizationFile: 'AmazonCustomizationFile',
    system_logs: 'system_logs',
    Tag: 'Tag',
    ScriptRunLog: 'ScriptRunLog',
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    SyncProgress: 'SyncProgress',
    SyncMetrics: 'SyncMetrics',
    AiCallLog: 'AiCallLog',
    Metric: 'Metric',
    AiReportDefinition: 'AiReportDefinition',
    AiReportRun: 'AiReportRun'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "product" | "order" | "customer" | "orderItem" | "printOrderTask" | "amazonCustomizationFile" | "system_logs" | "tag" | "scriptRunLog" | "user" | "account" | "session" | "verificationToken" | "syncProgress" | "syncMetrics" | "aiCallLog" | "metric" | "aiReportDefinition" | "aiReportRun"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      PrintOrderTask: {
        payload: Prisma.$PrintOrderTaskPayload<ExtArgs>
        fields: Prisma.PrintOrderTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrintOrderTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintOrderTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrintOrderTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintOrderTaskPayload>
          }
          findFirst: {
            args: Prisma.PrintOrderTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintOrderTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrintOrderTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintOrderTaskPayload>
          }
          findMany: {
            args: Prisma.PrintOrderTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintOrderTaskPayload>[]
          }
          create: {
            args: Prisma.PrintOrderTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintOrderTaskPayload>
          }
          createMany: {
            args: Prisma.PrintOrderTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PrintOrderTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintOrderTaskPayload>
          }
          update: {
            args: Prisma.PrintOrderTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintOrderTaskPayload>
          }
          deleteMany: {
            args: Prisma.PrintOrderTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrintOrderTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrintOrderTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintOrderTaskPayload>
          }
          aggregate: {
            args: Prisma.PrintOrderTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrintOrderTask>
          }
          groupBy: {
            args: Prisma.PrintOrderTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrintOrderTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrintOrderTaskCountArgs<ExtArgs>
            result: $Utils.Optional<PrintOrderTaskCountAggregateOutputType> | number
          }
        }
      }
      AmazonCustomizationFile: {
        payload: Prisma.$AmazonCustomizationFilePayload<ExtArgs>
        fields: Prisma.AmazonCustomizationFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmazonCustomizationFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonCustomizationFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmazonCustomizationFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonCustomizationFilePayload>
          }
          findFirst: {
            args: Prisma.AmazonCustomizationFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonCustomizationFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmazonCustomizationFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonCustomizationFilePayload>
          }
          findMany: {
            args: Prisma.AmazonCustomizationFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonCustomizationFilePayload>[]
          }
          create: {
            args: Prisma.AmazonCustomizationFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonCustomizationFilePayload>
          }
          createMany: {
            args: Prisma.AmazonCustomizationFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AmazonCustomizationFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonCustomizationFilePayload>
          }
          update: {
            args: Prisma.AmazonCustomizationFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonCustomizationFilePayload>
          }
          deleteMany: {
            args: Prisma.AmazonCustomizationFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmazonCustomizationFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AmazonCustomizationFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonCustomizationFilePayload>
          }
          aggregate: {
            args: Prisma.AmazonCustomizationFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmazonCustomizationFile>
          }
          groupBy: {
            args: Prisma.AmazonCustomizationFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmazonCustomizationFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmazonCustomizationFileCountArgs<ExtArgs>
            result: $Utils.Optional<AmazonCustomizationFileCountAggregateOutputType> | number
          }
        }
      }
      system_logs: {
        payload: Prisma.$system_logsPayload<ExtArgs>
        fields: Prisma.system_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.system_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.system_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_logsPayload>
          }
          findFirst: {
            args: Prisma.system_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.system_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_logsPayload>
          }
          findMany: {
            args: Prisma.system_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_logsPayload>[]
          }
          create: {
            args: Prisma.system_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_logsPayload>
          }
          createMany: {
            args: Prisma.system_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.system_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_logsPayload>
          }
          update: {
            args: Prisma.system_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_logsPayload>
          }
          deleteMany: {
            args: Prisma.system_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.system_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.system_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_logsPayload>
          }
          aggregate: {
            args: Prisma.System_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystem_logs>
          }
          groupBy: {
            args: Prisma.system_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<System_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.system_logsCountArgs<ExtArgs>
            result: $Utils.Optional<System_logsCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      ScriptRunLog: {
        payload: Prisma.$ScriptRunLogPayload<ExtArgs>
        fields: Prisma.ScriptRunLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScriptRunLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptRunLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScriptRunLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptRunLogPayload>
          }
          findFirst: {
            args: Prisma.ScriptRunLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptRunLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScriptRunLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptRunLogPayload>
          }
          findMany: {
            args: Prisma.ScriptRunLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptRunLogPayload>[]
          }
          create: {
            args: Prisma.ScriptRunLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptRunLogPayload>
          }
          createMany: {
            args: Prisma.ScriptRunLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ScriptRunLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptRunLogPayload>
          }
          update: {
            args: Prisma.ScriptRunLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptRunLogPayload>
          }
          deleteMany: {
            args: Prisma.ScriptRunLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScriptRunLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScriptRunLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptRunLogPayload>
          }
          aggregate: {
            args: Prisma.ScriptRunLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScriptRunLog>
          }
          groupBy: {
            args: Prisma.ScriptRunLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScriptRunLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScriptRunLogCountArgs<ExtArgs>
            result: $Utils.Optional<ScriptRunLogCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      SyncProgress: {
        payload: Prisma.$SyncProgressPayload<ExtArgs>
        fields: Prisma.SyncProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncProgressPayload>
          }
          findFirst: {
            args: Prisma.SyncProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncProgressPayload>
          }
          findMany: {
            args: Prisma.SyncProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncProgressPayload>[]
          }
          create: {
            args: Prisma.SyncProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncProgressPayload>
          }
          createMany: {
            args: Prisma.SyncProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SyncProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncProgressPayload>
          }
          update: {
            args: Prisma.SyncProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncProgressPayload>
          }
          deleteMany: {
            args: Prisma.SyncProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SyncProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncProgressPayload>
          }
          aggregate: {
            args: Prisma.SyncProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncProgress>
          }
          groupBy: {
            args: Prisma.SyncProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncProgressCountArgs<ExtArgs>
            result: $Utils.Optional<SyncProgressCountAggregateOutputType> | number
          }
        }
      }
      SyncMetrics: {
        payload: Prisma.$SyncMetricsPayload<ExtArgs>
        fields: Prisma.SyncMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncMetricsPayload>
          }
          findFirst: {
            args: Prisma.SyncMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncMetricsPayload>
          }
          findMany: {
            args: Prisma.SyncMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncMetricsPayload>[]
          }
          create: {
            args: Prisma.SyncMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncMetricsPayload>
          }
          createMany: {
            args: Prisma.SyncMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SyncMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncMetricsPayload>
          }
          update: {
            args: Prisma.SyncMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncMetricsPayload>
          }
          deleteMany: {
            args: Prisma.SyncMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SyncMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncMetricsPayload>
          }
          aggregate: {
            args: Prisma.SyncMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncMetrics>
          }
          groupBy: {
            args: Prisma.SyncMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<SyncMetricsCountAggregateOutputType> | number
          }
        }
      }
      AiCallLog: {
        payload: Prisma.$AiCallLogPayload<ExtArgs>
        fields: Prisma.AiCallLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiCallLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiCallLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiCallLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiCallLogPayload>
          }
          findFirst: {
            args: Prisma.AiCallLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiCallLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiCallLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiCallLogPayload>
          }
          findMany: {
            args: Prisma.AiCallLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiCallLogPayload>[]
          }
          create: {
            args: Prisma.AiCallLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiCallLogPayload>
          }
          createMany: {
            args: Prisma.AiCallLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AiCallLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiCallLogPayload>
          }
          update: {
            args: Prisma.AiCallLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiCallLogPayload>
          }
          deleteMany: {
            args: Prisma.AiCallLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiCallLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AiCallLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiCallLogPayload>
          }
          aggregate: {
            args: Prisma.AiCallLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiCallLog>
          }
          groupBy: {
            args: Prisma.AiCallLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiCallLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiCallLogCountArgs<ExtArgs>
            result: $Utils.Optional<AiCallLogCountAggregateOutputType> | number
          }
        }
      }
      Metric: {
        payload: Prisma.$MetricPayload<ExtArgs>
        fields: Prisma.MetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          findFirst: {
            args: Prisma.MetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          findMany: {
            args: Prisma.MetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>[]
          }
          create: {
            args: Prisma.MetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          createMany: {
            args: Prisma.MetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          update: {
            args: Prisma.MetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          deleteMany: {
            args: Prisma.MetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          aggregate: {
            args: Prisma.MetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMetric>
          }
          groupBy: {
            args: Prisma.MetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<MetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.MetricCountArgs<ExtArgs>
            result: $Utils.Optional<MetricCountAggregateOutputType> | number
          }
        }
      }
      AiReportDefinition: {
        payload: Prisma.$AiReportDefinitionPayload<ExtArgs>
        fields: Prisma.AiReportDefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiReportDefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiReportDefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiReportDefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiReportDefinitionPayload>
          }
          findFirst: {
            args: Prisma.AiReportDefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiReportDefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiReportDefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiReportDefinitionPayload>
          }
          findMany: {
            args: Prisma.AiReportDefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiReportDefinitionPayload>[]
          }
          create: {
            args: Prisma.AiReportDefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiReportDefinitionPayload>
          }
          createMany: {
            args: Prisma.AiReportDefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AiReportDefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiReportDefinitionPayload>
          }
          update: {
            args: Prisma.AiReportDefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiReportDefinitionPayload>
          }
          deleteMany: {
            args: Prisma.AiReportDefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiReportDefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AiReportDefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiReportDefinitionPayload>
          }
          aggregate: {
            args: Prisma.AiReportDefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiReportDefinition>
          }
          groupBy: {
            args: Prisma.AiReportDefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiReportDefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiReportDefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<AiReportDefinitionCountAggregateOutputType> | number
          }
        }
      }
      AiReportRun: {
        payload: Prisma.$AiReportRunPayload<ExtArgs>
        fields: Prisma.AiReportRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiReportRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiReportRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiReportRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiReportRunPayload>
          }
          findFirst: {
            args: Prisma.AiReportRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiReportRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiReportRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiReportRunPayload>
          }
          findMany: {
            args: Prisma.AiReportRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiReportRunPayload>[]
          }
          create: {
            args: Prisma.AiReportRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiReportRunPayload>
          }
          createMany: {
            args: Prisma.AiReportRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AiReportRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiReportRunPayload>
          }
          update: {
            args: Prisma.AiReportRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiReportRunPayload>
          }
          deleteMany: {
            args: Prisma.AiReportRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiReportRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AiReportRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiReportRunPayload>
          }
          aggregate: {
            args: Prisma.AiReportRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiReportRun>
          }
          groupBy: {
            args: Prisma.AiReportRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiReportRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiReportRunCountArgs<ExtArgs>
            result: $Utils.Optional<AiReportRunCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    product?: ProductOmit
    order?: OrderOmit
    customer?: CustomerOmit
    orderItem?: OrderItemOmit
    printOrderTask?: PrintOrderTaskOmit
    amazonCustomizationFile?: AmazonCustomizationFileOmit
    system_logs?: system_logsOmit
    tag?: TagOmit
    scriptRunLog?: ScriptRunLogOmit
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    syncProgress?: SyncProgressOmit
    syncMetrics?: SyncMetricsOmit
    aiCallLog?: AiCallLogOmit
    metric?: MetricOmit
    aiReportDefinition?: AiReportDefinitionOmit
    aiReportRun?: AiReportRunOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    orderItems: number
    printTasks: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
    printTasks?: boolean | ProductCountOutputTypeCountPrintTasksArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPrintTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrintOrderTaskWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
    printTasks: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
    printTasks?: boolean | OrderCountOutputTypeCountPrintTasksArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountPrintTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrintOrderTaskWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    orders: number
    printTasks: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
    printTasks?: boolean | CustomerCountOutputTypeCountPrintTasksArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPrintTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrintOrderTaskWhereInput
  }


  /**
   * Count Type OrderItemCountOutputType
   */

  export type OrderItemCountOutputType = {
    printTasks: number
  }

  export type OrderItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    printTasks?: boolean | OrderItemCountOutputTypeCountPrintTasksArgs
  }

  // Custom InputTypes
  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemCountOutputType
     */
    select?: OrderItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeCountPrintTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrintOrderTaskWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * Count Type AiReportDefinitionCountOutputType
   */

  export type AiReportDefinitionCountOutputType = {
    runs: number
  }

  export type AiReportDefinitionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runs?: boolean | AiReportDefinitionCountOutputTypeCountRunsArgs
  }

  // Custom InputTypes
  /**
   * AiReportDefinitionCountOutputType without action
   */
  export type AiReportDefinitionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportDefinitionCountOutputType
     */
    select?: AiReportDefinitionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AiReportDefinitionCountOutputType without action
   */
  export type AiReportDefinitionCountOutputTypeCountRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiReportRunWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    weight: Decimal | null
    item_weight_value: Decimal | null
    shipstation_product_id: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    weight: Decimal | null
    item_weight_value: Decimal | null
    shipstation_product_id: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    sku: string | null
    name: string | null
    imageUrl: string | null
    weight: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fulfillment_sku: string | null
    item_weight_units: string | null
    item_weight_value: Decimal | null
    shipstation_product_id: number | null
    upc: string | null
    warehouse_location: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    sku: string | null
    name: string | null
    imageUrl: string | null
    weight: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fulfillment_sku: string | null
    item_weight_units: string | null
    item_weight_value: Decimal | null
    shipstation_product_id: number | null
    upc: string | null
    warehouse_location: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    sku: number
    name: number
    imageUrl: number
    weight: number
    notes: number
    createdAt: number
    updatedAt: number
    fulfillment_sku: number
    item_weight_units: number
    item_weight_value: number
    shipstation_product_id: number
    upc: number
    warehouse_location: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    weight?: true
    item_weight_value?: true
    shipstation_product_id?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    weight?: true
    item_weight_value?: true
    shipstation_product_id?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    imageUrl?: true
    weight?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    fulfillment_sku?: true
    item_weight_units?: true
    item_weight_value?: true
    shipstation_product_id?: true
    upc?: true
    warehouse_location?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    imageUrl?: true
    weight?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    fulfillment_sku?: true
    item_weight_units?: true
    item_weight_value?: true
    shipstation_product_id?: true
    upc?: true
    warehouse_location?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    imageUrl?: true
    weight?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    fulfillment_sku?: true
    item_weight_units?: true
    item_weight_value?: true
    shipstation_product_id?: true
    upc?: true
    warehouse_location?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    sku: string | null
    name: string
    imageUrl: string | null
    weight: Decimal | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    fulfillment_sku: string | null
    item_weight_units: string | null
    item_weight_value: Decimal | null
    shipstation_product_id: number | null
    upc: string | null
    warehouse_location: string | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    imageUrl?: boolean
    weight?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fulfillment_sku?: boolean
    item_weight_units?: boolean
    item_weight_value?: boolean
    shipstation_product_id?: boolean
    upc?: boolean
    warehouse_location?: boolean
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    printTasks?: boolean | Product$printTasksArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>



  export type ProductSelectScalar = {
    id?: boolean
    sku?: boolean
    name?: boolean
    imageUrl?: boolean
    weight?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fulfillment_sku?: boolean
    item_weight_units?: boolean
    item_weight_value?: boolean
    shipstation_product_id?: boolean
    upc?: boolean
    warehouse_location?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sku" | "name" | "imageUrl" | "weight" | "notes" | "createdAt" | "updatedAt" | "fulfillment_sku" | "item_weight_units" | "item_weight_value" | "shipstation_product_id" | "upc" | "warehouse_location", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    printTasks?: boolean | Product$printTasksArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      printTasks: Prisma.$PrintOrderTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sku: string | null
      name: string
      imageUrl: string | null
      weight: Prisma.Decimal | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      fulfillment_sku: string | null
      item_weight_units: string | null
      item_weight_value: Prisma.Decimal | null
      shipstation_product_id: number | null
      upc: string | null
      warehouse_location: string | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    printTasks<T extends Product$printTasksArgs<ExtArgs> = {}>(args?: Subset<T, Product$printTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrintOrderTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly imageUrl: FieldRef<"Product", 'String'>
    readonly weight: FieldRef<"Product", 'Decimal'>
    readonly notes: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly fulfillment_sku: FieldRef<"Product", 'String'>
    readonly item_weight_units: FieldRef<"Product", 'String'>
    readonly item_weight_value: FieldRef<"Product", 'Decimal'>
    readonly shipstation_product_id: FieldRef<"Product", 'Int'>
    readonly upc: FieldRef<"Product", 'String'>
    readonly warehouse_location: FieldRef<"Product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product.printTasks
   */
  export type Product$printTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOrderTask
     */
    select?: PrintOrderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintOrderTask
     */
    omit?: PrintOrderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintOrderTaskInclude<ExtArgs> | null
    where?: PrintOrderTaskWhereInput
    orderBy?: PrintOrderTaskOrderByWithRelationInput | PrintOrderTaskOrderByWithRelationInput[]
    cursor?: PrintOrderTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrintOrderTaskScalarFieldEnum | PrintOrderTaskScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    shipping_price: Decimal | null
    tax_amount: Decimal | null
    discount_amount: Decimal | null
    shipping_amount_paid: Decimal | null
    shipping_tax: Decimal | null
    total_price: Decimal | null
    amount_paid: Decimal | null
    order_weight_value: Decimal | null
    shipstation_store_id: number | null
    dimensions_height: Decimal | null
    dimensions_length: Decimal | null
    dimensions_width: Decimal | null
    insurance_insured_value: Decimal | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    shipping_price: Decimal | null
    tax_amount: Decimal | null
    discount_amount: Decimal | null
    shipping_amount_paid: Decimal | null
    shipping_tax: Decimal | null
    total_price: Decimal | null
    amount_paid: Decimal | null
    order_weight_value: Decimal | null
    shipstation_store_id: number | null
    dimensions_height: Decimal | null
    dimensions_length: Decimal | null
    dimensions_width: Decimal | null
    insurance_insured_value: Decimal | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    shipstation_order_id: string | null
    shipstation_order_number: string | null
    customerId: number | null
    customer_name: string | null
    order_status: string | null
    order_key: string | null
    order_date: Date | null
    payment_date: Date | null
    ship_by_date: Date | null
    shipping_price: Decimal | null
    tax_amount: Decimal | null
    discount_amount: Decimal | null
    shipping_amount_paid: Decimal | null
    shipping_tax: Decimal | null
    total_price: Decimal | null
    gift: boolean | null
    gift_message: string | null
    gift_email: string | null
    requested_shipping_service: string | null
    carrier_code: string | null
    service_code: string | null
    package_code: string | null
    confirmation: string | null
    tracking_number: string | null
    shipped_date: Date | null
    warehouse_id: string | null
    customer_notes: string | null
    internal_notes: string | null
    last_sync_date: Date | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
    marketplace: string | null
    amount_paid: Decimal | null
    order_weight_units: string | null
    order_weight_value: Decimal | null
    payment_method: string | null
    shipstation_store_id: number | null
    dimensions_height: Decimal | null
    dimensions_length: Decimal | null
    dimensions_units: string | null
    dimensions_width: Decimal | null
    insurance_insure_shipment: boolean | null
    insurance_insured_value: Decimal | null
    insurance_provider: string | null
    internal_status: $Enums.InternalOrderStatus | null
    is_voided: boolean | null
    marketplace_notified: boolean | null
    void_date: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    shipstation_order_id: string | null
    shipstation_order_number: string | null
    customerId: number | null
    customer_name: string | null
    order_status: string | null
    order_key: string | null
    order_date: Date | null
    payment_date: Date | null
    ship_by_date: Date | null
    shipping_price: Decimal | null
    tax_amount: Decimal | null
    discount_amount: Decimal | null
    shipping_amount_paid: Decimal | null
    shipping_tax: Decimal | null
    total_price: Decimal | null
    gift: boolean | null
    gift_message: string | null
    gift_email: string | null
    requested_shipping_service: string | null
    carrier_code: string | null
    service_code: string | null
    package_code: string | null
    confirmation: string | null
    tracking_number: string | null
    shipped_date: Date | null
    warehouse_id: string | null
    customer_notes: string | null
    internal_notes: string | null
    last_sync_date: Date | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
    marketplace: string | null
    amount_paid: Decimal | null
    order_weight_units: string | null
    order_weight_value: Decimal | null
    payment_method: string | null
    shipstation_store_id: number | null
    dimensions_height: Decimal | null
    dimensions_length: Decimal | null
    dimensions_units: string | null
    dimensions_width: Decimal | null
    insurance_insure_shipment: boolean | null
    insurance_insured_value: Decimal | null
    insurance_provider: string | null
    internal_status: $Enums.InternalOrderStatus | null
    is_voided: boolean | null
    marketplace_notified: boolean | null
    void_date: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    shipstation_order_id: number
    shipstation_order_number: number
    customerId: number
    customer_name: number
    order_status: number
    order_key: number
    order_date: number
    payment_date: number
    ship_by_date: number
    shipping_price: number
    tax_amount: number
    discount_amount: number
    shipping_amount_paid: number
    shipping_tax: number
    total_price: number
    gift: number
    gift_message: number
    gift_email: number
    requested_shipping_service: number
    carrier_code: number
    service_code: number
    package_code: number
    confirmation: number
    tracking_number: number
    shipped_date: number
    warehouse_id: number
    customer_notes: number
    internal_notes: number
    last_sync_date: number
    notes: number
    created_at: number
    updated_at: number
    marketplace: number
    amount_paid: number
    order_weight_units: number
    order_weight_value: number
    payment_method: number
    shipstation_store_id: number
    tag_ids: number
    dimensions_height: number
    dimensions_length: number
    dimensions_units: number
    dimensions_width: number
    insurance_insure_shipment: number
    insurance_insured_value: number
    insurance_provider: number
    internal_status: number
    is_voided: number
    marketplace_notified: number
    void_date: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    customerId?: true
    shipping_price?: true
    tax_amount?: true
    discount_amount?: true
    shipping_amount_paid?: true
    shipping_tax?: true
    total_price?: true
    amount_paid?: true
    order_weight_value?: true
    shipstation_store_id?: true
    dimensions_height?: true
    dimensions_length?: true
    dimensions_width?: true
    insurance_insured_value?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    customerId?: true
    shipping_price?: true
    tax_amount?: true
    discount_amount?: true
    shipping_amount_paid?: true
    shipping_tax?: true
    total_price?: true
    amount_paid?: true
    order_weight_value?: true
    shipstation_store_id?: true
    dimensions_height?: true
    dimensions_length?: true
    dimensions_width?: true
    insurance_insured_value?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    shipstation_order_id?: true
    shipstation_order_number?: true
    customerId?: true
    customer_name?: true
    order_status?: true
    order_key?: true
    order_date?: true
    payment_date?: true
    ship_by_date?: true
    shipping_price?: true
    tax_amount?: true
    discount_amount?: true
    shipping_amount_paid?: true
    shipping_tax?: true
    total_price?: true
    gift?: true
    gift_message?: true
    gift_email?: true
    requested_shipping_service?: true
    carrier_code?: true
    service_code?: true
    package_code?: true
    confirmation?: true
    tracking_number?: true
    shipped_date?: true
    warehouse_id?: true
    customer_notes?: true
    internal_notes?: true
    last_sync_date?: true
    notes?: true
    created_at?: true
    updated_at?: true
    marketplace?: true
    amount_paid?: true
    order_weight_units?: true
    order_weight_value?: true
    payment_method?: true
    shipstation_store_id?: true
    dimensions_height?: true
    dimensions_length?: true
    dimensions_units?: true
    dimensions_width?: true
    insurance_insure_shipment?: true
    insurance_insured_value?: true
    insurance_provider?: true
    internal_status?: true
    is_voided?: true
    marketplace_notified?: true
    void_date?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    shipstation_order_id?: true
    shipstation_order_number?: true
    customerId?: true
    customer_name?: true
    order_status?: true
    order_key?: true
    order_date?: true
    payment_date?: true
    ship_by_date?: true
    shipping_price?: true
    tax_amount?: true
    discount_amount?: true
    shipping_amount_paid?: true
    shipping_tax?: true
    total_price?: true
    gift?: true
    gift_message?: true
    gift_email?: true
    requested_shipping_service?: true
    carrier_code?: true
    service_code?: true
    package_code?: true
    confirmation?: true
    tracking_number?: true
    shipped_date?: true
    warehouse_id?: true
    customer_notes?: true
    internal_notes?: true
    last_sync_date?: true
    notes?: true
    created_at?: true
    updated_at?: true
    marketplace?: true
    amount_paid?: true
    order_weight_units?: true
    order_weight_value?: true
    payment_method?: true
    shipstation_store_id?: true
    dimensions_height?: true
    dimensions_length?: true
    dimensions_units?: true
    dimensions_width?: true
    insurance_insure_shipment?: true
    insurance_insured_value?: true
    insurance_provider?: true
    internal_status?: true
    is_voided?: true
    marketplace_notified?: true
    void_date?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    shipstation_order_id?: true
    shipstation_order_number?: true
    customerId?: true
    customer_name?: true
    order_status?: true
    order_key?: true
    order_date?: true
    payment_date?: true
    ship_by_date?: true
    shipping_price?: true
    tax_amount?: true
    discount_amount?: true
    shipping_amount_paid?: true
    shipping_tax?: true
    total_price?: true
    gift?: true
    gift_message?: true
    gift_email?: true
    requested_shipping_service?: true
    carrier_code?: true
    service_code?: true
    package_code?: true
    confirmation?: true
    tracking_number?: true
    shipped_date?: true
    warehouse_id?: true
    customer_notes?: true
    internal_notes?: true
    last_sync_date?: true
    notes?: true
    created_at?: true
    updated_at?: true
    marketplace?: true
    amount_paid?: true
    order_weight_units?: true
    order_weight_value?: true
    payment_method?: true
    shipstation_store_id?: true
    tag_ids?: true
    dimensions_height?: true
    dimensions_length?: true
    dimensions_units?: true
    dimensions_width?: true
    insurance_insure_shipment?: true
    insurance_insured_value?: true
    insurance_provider?: true
    internal_status?: true
    is_voided?: true
    marketplace_notified?: true
    void_date?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: number
    shipstation_order_id: string | null
    shipstation_order_number: string | null
    customerId: number | null
    customer_name: string | null
    order_status: string
    order_key: string | null
    order_date: Date | null
    payment_date: Date | null
    ship_by_date: Date | null
    shipping_price: Decimal | null
    tax_amount: Decimal | null
    discount_amount: Decimal | null
    shipping_amount_paid: Decimal | null
    shipping_tax: Decimal | null
    total_price: Decimal
    gift: boolean
    gift_message: string | null
    gift_email: string | null
    requested_shipping_service: string | null
    carrier_code: string | null
    service_code: string | null
    package_code: string | null
    confirmation: string | null
    tracking_number: string | null
    shipped_date: Date | null
    warehouse_id: string | null
    customer_notes: string | null
    internal_notes: string | null
    last_sync_date: Date | null
    notes: string | null
    created_at: Date
    updated_at: Date | null
    marketplace: string | null
    amount_paid: Decimal | null
    order_weight_units: string | null
    order_weight_value: Decimal | null
    payment_method: string | null
    shipstation_store_id: number | null
    tag_ids: JsonValue | null
    dimensions_height: Decimal | null
    dimensions_length: Decimal | null
    dimensions_units: string | null
    dimensions_width: Decimal | null
    insurance_insure_shipment: boolean | null
    insurance_insured_value: Decimal | null
    insurance_provider: string | null
    internal_status: $Enums.InternalOrderStatus
    is_voided: boolean | null
    marketplace_notified: boolean
    void_date: Date | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipstation_order_id?: boolean
    shipstation_order_number?: boolean
    customerId?: boolean
    customer_name?: boolean
    order_status?: boolean
    order_key?: boolean
    order_date?: boolean
    payment_date?: boolean
    ship_by_date?: boolean
    shipping_price?: boolean
    tax_amount?: boolean
    discount_amount?: boolean
    shipping_amount_paid?: boolean
    shipping_tax?: boolean
    total_price?: boolean
    gift?: boolean
    gift_message?: boolean
    gift_email?: boolean
    requested_shipping_service?: boolean
    carrier_code?: boolean
    service_code?: boolean
    package_code?: boolean
    confirmation?: boolean
    tracking_number?: boolean
    shipped_date?: boolean
    warehouse_id?: boolean
    customer_notes?: boolean
    internal_notes?: boolean
    last_sync_date?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    marketplace?: boolean
    amount_paid?: boolean
    order_weight_units?: boolean
    order_weight_value?: boolean
    payment_method?: boolean
    shipstation_store_id?: boolean
    tag_ids?: boolean
    dimensions_height?: boolean
    dimensions_length?: boolean
    dimensions_units?: boolean
    dimensions_width?: boolean
    insurance_insure_shipment?: boolean
    insurance_insured_value?: boolean
    insurance_provider?: boolean
    internal_status?: boolean
    is_voided?: boolean
    marketplace_notified?: boolean
    void_date?: boolean
    customer?: boolean | Order$customerArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    printTasks?: boolean | Order$printTasksArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>



  export type OrderSelectScalar = {
    id?: boolean
    shipstation_order_id?: boolean
    shipstation_order_number?: boolean
    customerId?: boolean
    customer_name?: boolean
    order_status?: boolean
    order_key?: boolean
    order_date?: boolean
    payment_date?: boolean
    ship_by_date?: boolean
    shipping_price?: boolean
    tax_amount?: boolean
    discount_amount?: boolean
    shipping_amount_paid?: boolean
    shipping_tax?: boolean
    total_price?: boolean
    gift?: boolean
    gift_message?: boolean
    gift_email?: boolean
    requested_shipping_service?: boolean
    carrier_code?: boolean
    service_code?: boolean
    package_code?: boolean
    confirmation?: boolean
    tracking_number?: boolean
    shipped_date?: boolean
    warehouse_id?: boolean
    customer_notes?: boolean
    internal_notes?: boolean
    last_sync_date?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    marketplace?: boolean
    amount_paid?: boolean
    order_weight_units?: boolean
    order_weight_value?: boolean
    payment_method?: boolean
    shipstation_store_id?: boolean
    tag_ids?: boolean
    dimensions_height?: boolean
    dimensions_length?: boolean
    dimensions_units?: boolean
    dimensions_width?: boolean
    insurance_insure_shipment?: boolean
    insurance_insured_value?: boolean
    insurance_provider?: boolean
    internal_status?: boolean
    is_voided?: boolean
    marketplace_notified?: boolean
    void_date?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shipstation_order_id" | "shipstation_order_number" | "customerId" | "customer_name" | "order_status" | "order_key" | "order_date" | "payment_date" | "ship_by_date" | "shipping_price" | "tax_amount" | "discount_amount" | "shipping_amount_paid" | "shipping_tax" | "total_price" | "gift" | "gift_message" | "gift_email" | "requested_shipping_service" | "carrier_code" | "service_code" | "package_code" | "confirmation" | "tracking_number" | "shipped_date" | "warehouse_id" | "customer_notes" | "internal_notes" | "last_sync_date" | "notes" | "created_at" | "updated_at" | "marketplace" | "amount_paid" | "order_weight_units" | "order_weight_value" | "payment_method" | "shipstation_store_id" | "tag_ids" | "dimensions_height" | "dimensions_length" | "dimensions_units" | "dimensions_width" | "insurance_insure_shipment" | "insurance_insured_value" | "insurance_provider" | "internal_status" | "is_voided" | "marketplace_notified" | "void_date", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Order$customerArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    printTasks?: boolean | Order$printTasksArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      printTasks: Prisma.$PrintOrderTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      shipstation_order_id: string | null
      shipstation_order_number: string | null
      customerId: number | null
      customer_name: string | null
      order_status: string
      order_key: string | null
      order_date: Date | null
      payment_date: Date | null
      ship_by_date: Date | null
      shipping_price: Prisma.Decimal | null
      tax_amount: Prisma.Decimal | null
      discount_amount: Prisma.Decimal | null
      shipping_amount_paid: Prisma.Decimal | null
      shipping_tax: Prisma.Decimal | null
      total_price: Prisma.Decimal
      gift: boolean
      gift_message: string | null
      gift_email: string | null
      requested_shipping_service: string | null
      carrier_code: string | null
      service_code: string | null
      package_code: string | null
      confirmation: string | null
      tracking_number: string | null
      shipped_date: Date | null
      warehouse_id: string | null
      customer_notes: string | null
      internal_notes: string | null
      last_sync_date: Date | null
      notes: string | null
      created_at: Date
      updated_at: Date | null
      marketplace: string | null
      amount_paid: Prisma.Decimal | null
      order_weight_units: string | null
      order_weight_value: Prisma.Decimal | null
      payment_method: string | null
      shipstation_store_id: number | null
      tag_ids: Prisma.JsonValue | null
      dimensions_height: Prisma.Decimal | null
      dimensions_length: Prisma.Decimal | null
      dimensions_units: string | null
      dimensions_width: Prisma.Decimal | null
      insurance_insure_shipment: boolean | null
      insurance_insured_value: Prisma.Decimal | null
      insurance_provider: string | null
      internal_status: $Enums.InternalOrderStatus
      is_voided: boolean | null
      marketplace_notified: boolean
      void_date: Date | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends Order$customerArgs<ExtArgs> = {}>(args?: Subset<T, Order$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    printTasks<T extends Order$printTasksArgs<ExtArgs> = {}>(args?: Subset<T, Order$printTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrintOrderTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'Int'>
    readonly shipstation_order_id: FieldRef<"Order", 'String'>
    readonly shipstation_order_number: FieldRef<"Order", 'String'>
    readonly customerId: FieldRef<"Order", 'Int'>
    readonly customer_name: FieldRef<"Order", 'String'>
    readonly order_status: FieldRef<"Order", 'String'>
    readonly order_key: FieldRef<"Order", 'String'>
    readonly order_date: FieldRef<"Order", 'DateTime'>
    readonly payment_date: FieldRef<"Order", 'DateTime'>
    readonly ship_by_date: FieldRef<"Order", 'DateTime'>
    readonly shipping_price: FieldRef<"Order", 'Decimal'>
    readonly tax_amount: FieldRef<"Order", 'Decimal'>
    readonly discount_amount: FieldRef<"Order", 'Decimal'>
    readonly shipping_amount_paid: FieldRef<"Order", 'Decimal'>
    readonly shipping_tax: FieldRef<"Order", 'Decimal'>
    readonly total_price: FieldRef<"Order", 'Decimal'>
    readonly gift: FieldRef<"Order", 'Boolean'>
    readonly gift_message: FieldRef<"Order", 'String'>
    readonly gift_email: FieldRef<"Order", 'String'>
    readonly requested_shipping_service: FieldRef<"Order", 'String'>
    readonly carrier_code: FieldRef<"Order", 'String'>
    readonly service_code: FieldRef<"Order", 'String'>
    readonly package_code: FieldRef<"Order", 'String'>
    readonly confirmation: FieldRef<"Order", 'String'>
    readonly tracking_number: FieldRef<"Order", 'String'>
    readonly shipped_date: FieldRef<"Order", 'DateTime'>
    readonly warehouse_id: FieldRef<"Order", 'String'>
    readonly customer_notes: FieldRef<"Order", 'String'>
    readonly internal_notes: FieldRef<"Order", 'String'>
    readonly last_sync_date: FieldRef<"Order", 'DateTime'>
    readonly notes: FieldRef<"Order", 'String'>
    readonly created_at: FieldRef<"Order", 'DateTime'>
    readonly updated_at: FieldRef<"Order", 'DateTime'>
    readonly marketplace: FieldRef<"Order", 'String'>
    readonly amount_paid: FieldRef<"Order", 'Decimal'>
    readonly order_weight_units: FieldRef<"Order", 'String'>
    readonly order_weight_value: FieldRef<"Order", 'Decimal'>
    readonly payment_method: FieldRef<"Order", 'String'>
    readonly shipstation_store_id: FieldRef<"Order", 'Int'>
    readonly tag_ids: FieldRef<"Order", 'Json'>
    readonly dimensions_height: FieldRef<"Order", 'Decimal'>
    readonly dimensions_length: FieldRef<"Order", 'Decimal'>
    readonly dimensions_units: FieldRef<"Order", 'String'>
    readonly dimensions_width: FieldRef<"Order", 'Decimal'>
    readonly insurance_insure_shipment: FieldRef<"Order", 'Boolean'>
    readonly insurance_insured_value: FieldRef<"Order", 'Decimal'>
    readonly insurance_provider: FieldRef<"Order", 'String'>
    readonly internal_status: FieldRef<"Order", 'InternalOrderStatus'>
    readonly is_voided: FieldRef<"Order", 'Boolean'>
    readonly marketplace_notified: FieldRef<"Order", 'Boolean'>
    readonly void_date: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data?: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.customer
   */
  export type Order$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.printTasks
   */
  export type Order$printTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOrderTask
     */
    select?: PrintOrderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintOrderTask
     */
    omit?: PrintOrderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintOrderTaskInclude<ExtArgs> | null
    where?: PrintOrderTaskWhereInput
    orderBy?: PrintOrderTaskOrderByWithRelationInput | PrintOrderTaskOrderByWithRelationInput[]
    cursor?: PrintOrderTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrintOrderTaskScalarFieldEnum | PrintOrderTaskScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    shipstation_customer_id: string | null
    company: string | null
    street1: string | null
    street2: string | null
    street3: string | null
    city: string | null
    state: string | null
    postal_code: string | null
    country: string | null
    country_code: string | null
    customer_notes: string | null
    created_at: Date | null
    updated_at: Date | null
    address_verified_status: string | null
    is_residential: boolean | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    shipstation_customer_id: string | null
    company: string | null
    street1: string | null
    street2: string | null
    street3: string | null
    city: string | null
    state: string | null
    postal_code: string | null
    country: string | null
    country_code: string | null
    customer_notes: string | null
    created_at: Date | null
    updated_at: Date | null
    address_verified_status: string | null
    is_residential: boolean | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    address: number
    shipstation_customer_id: number
    company: number
    street1: number
    street2: number
    street3: number
    city: number
    state: number
    postal_code: number
    country: number
    country_code: number
    customer_notes: number
    created_at: number
    updated_at: number
    address_verified_status: number
    is_residential: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    shipstation_customer_id?: true
    company?: true
    street1?: true
    street2?: true
    street3?: true
    city?: true
    state?: true
    postal_code?: true
    country?: true
    country_code?: true
    customer_notes?: true
    created_at?: true
    updated_at?: true
    address_verified_status?: true
    is_residential?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    shipstation_customer_id?: true
    company?: true
    street1?: true
    street2?: true
    street3?: true
    city?: true
    state?: true
    postal_code?: true
    country?: true
    country_code?: true
    customer_notes?: true
    created_at?: true
    updated_at?: true
    address_verified_status?: true
    is_residential?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    shipstation_customer_id?: true
    company?: true
    street1?: true
    street2?: true
    street3?: true
    city?: true
    state?: true
    postal_code?: true
    country?: true
    country_code?: true
    customer_notes?: true
    created_at?: true
    updated_at?: true
    address_verified_status?: true
    is_residential?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: number
    name: string
    email: string | null
    phone: string | null
    address: string | null
    shipstation_customer_id: string | null
    company: string | null
    street1: string | null
    street2: string | null
    street3: string | null
    city: string | null
    state: string | null
    postal_code: string | null
    country: string | null
    country_code: string | null
    customer_notes: string | null
    created_at: Date
    updated_at: Date | null
    address_verified_status: string | null
    is_residential: boolean | null
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    shipstation_customer_id?: boolean
    company?: boolean
    street1?: boolean
    street2?: boolean
    street3?: boolean
    city?: boolean
    state?: boolean
    postal_code?: boolean
    country?: boolean
    country_code?: boolean
    customer_notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    address_verified_status?: boolean
    is_residential?: boolean
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    printTasks?: boolean | Customer$printTasksArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>



  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    shipstation_customer_id?: boolean
    company?: boolean
    street1?: boolean
    street2?: boolean
    street3?: boolean
    city?: boolean
    state?: boolean
    postal_code?: boolean
    country?: boolean
    country_code?: boolean
    customer_notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    address_verified_status?: boolean
    is_residential?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "address" | "shipstation_customer_id" | "company" | "street1" | "street2" | "street3" | "city" | "state" | "postal_code" | "country" | "country_code" | "customer_notes" | "created_at" | "updated_at" | "address_verified_status" | "is_residential", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    printTasks?: boolean | Customer$printTasksArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
      printTasks: Prisma.$PrintOrderTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string | null
      phone: string | null
      address: string | null
      shipstation_customer_id: string | null
      company: string | null
      street1: string | null
      street2: string | null
      street3: string | null
      city: string | null
      state: string | null
      postal_code: string | null
      country: string | null
      country_code: string | null
      customer_notes: string | null
      created_at: Date
      updated_at: Date | null
      address_verified_status: string | null
      is_residential: boolean | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    printTasks<T extends Customer$printTasksArgs<ExtArgs> = {}>(args?: Subset<T, Customer$printTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrintOrderTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'Int'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly shipstation_customer_id: FieldRef<"Customer", 'String'>
    readonly company: FieldRef<"Customer", 'String'>
    readonly street1: FieldRef<"Customer", 'String'>
    readonly street2: FieldRef<"Customer", 'String'>
    readonly street3: FieldRef<"Customer", 'String'>
    readonly city: FieldRef<"Customer", 'String'>
    readonly state: FieldRef<"Customer", 'String'>
    readonly postal_code: FieldRef<"Customer", 'String'>
    readonly country: FieldRef<"Customer", 'String'>
    readonly country_code: FieldRef<"Customer", 'String'>
    readonly customer_notes: FieldRef<"Customer", 'String'>
    readonly created_at: FieldRef<"Customer", 'DateTime'>
    readonly updated_at: FieldRef<"Customer", 'DateTime'>
    readonly address_verified_status: FieldRef<"Customer", 'String'>
    readonly is_residential: FieldRef<"Customer", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Customer.printTasks
   */
  export type Customer$printTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOrderTask
     */
    select?: PrintOrderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintOrderTask
     */
    omit?: PrintOrderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintOrderTaskInclude<ExtArgs> | null
    where?: PrintOrderTaskWhereInput
    orderBy?: PrintOrderTaskOrderByWithRelationInput | PrintOrderTaskOrderByWithRelationInput[]
    cursor?: PrintOrderTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrintOrderTaskScalarFieldEnum | PrintOrderTaskScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    quantity: number | null
    unit_price: Decimal | null
    productId: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    quantity: number | null
    unit_price: Decimal | null
    productId: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    quantity: number | null
    unit_price: Decimal | null
    created_at: Date | null
    updated_at: Date | null
    shipstationLineItemKey: string | null
    productId: number | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    quantity: number | null
    unit_price: Decimal | null
    created_at: Date | null
    updated_at: Date | null
    shipstationLineItemKey: string | null
    productId: number | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    quantity: number
    unit_price: number
    print_settings: number
    created_at: number
    updated_at: number
    shipstationLineItemKey: number
    productId: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    id?: true
    orderId?: true
    quantity?: true
    unit_price?: true
    productId?: true
  }

  export type OrderItemSumAggregateInputType = {
    id?: true
    orderId?: true
    quantity?: true
    unit_price?: true
    productId?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    quantity?: true
    unit_price?: true
    created_at?: true
    updated_at?: true
    shipstationLineItemKey?: true
    productId?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    quantity?: true
    unit_price?: true
    created_at?: true
    updated_at?: true
    shipstationLineItemKey?: true
    productId?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    quantity?: true
    unit_price?: true
    print_settings?: true
    created_at?: true
    updated_at?: true
    shipstationLineItemKey?: true
    productId?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: number
    orderId: number
    quantity: number
    unit_price: Decimal
    print_settings: JsonValue | null
    created_at: Date
    updated_at: Date | null
    shipstationLineItemKey: string | null
    productId: number
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    quantity?: boolean
    unit_price?: boolean
    print_settings?: boolean
    created_at?: boolean
    updated_at?: boolean
    shipstationLineItemKey?: boolean
    productId?: boolean
    amazonCustomizationFiles?: boolean | OrderItem$amazonCustomizationFilesArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    printTasks?: boolean | OrderItem$printTasksArgs<ExtArgs>
    _count?: boolean | OrderItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>



  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    quantity?: boolean
    unit_price?: boolean
    print_settings?: boolean
    created_at?: boolean
    updated_at?: boolean
    shipstationLineItemKey?: boolean
    productId?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "quantity" | "unit_price" | "print_settings" | "created_at" | "updated_at" | "shipstationLineItemKey" | "productId", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    amazonCustomizationFiles?: boolean | OrderItem$amazonCustomizationFilesArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    printTasks?: boolean | OrderItem$printTasksArgs<ExtArgs>
    _count?: boolean | OrderItemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      amazonCustomizationFiles: Prisma.$AmazonCustomizationFilePayload<ExtArgs> | null
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      printTasks: Prisma.$PrintOrderTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      quantity: number
      unit_price: Prisma.Decimal
      print_settings: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date | null
      shipstationLineItemKey: string | null
      productId: number
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    amazonCustomizationFiles<T extends OrderItem$amazonCustomizationFilesArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$amazonCustomizationFilesArgs<ExtArgs>>): Prisma__AmazonCustomizationFileClient<$Result.GetResult<Prisma.$AmazonCustomizationFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    printTasks<T extends OrderItem$printTasksArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$printTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrintOrderTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'Int'>
    readonly orderId: FieldRef<"OrderItem", 'Int'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly unit_price: FieldRef<"OrderItem", 'Decimal'>
    readonly print_settings: FieldRef<"OrderItem", 'Json'>
    readonly created_at: FieldRef<"OrderItem", 'DateTime'>
    readonly updated_at: FieldRef<"OrderItem", 'DateTime'>
    readonly shipstationLineItemKey: FieldRef<"OrderItem", 'String'>
    readonly productId: FieldRef<"OrderItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem.amazonCustomizationFiles
   */
  export type OrderItem$amazonCustomizationFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonCustomizationFile
     */
    select?: AmazonCustomizationFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonCustomizationFile
     */
    omit?: AmazonCustomizationFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonCustomizationFileInclude<ExtArgs> | null
    where?: AmazonCustomizationFileWhereInput
  }

  /**
   * OrderItem.printTasks
   */
  export type OrderItem$printTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOrderTask
     */
    select?: PrintOrderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintOrderTask
     */
    omit?: PrintOrderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintOrderTaskInclude<ExtArgs> | null
    where?: PrintOrderTaskWhereInput
    orderBy?: PrintOrderTaskOrderByWithRelationInput | PrintOrderTaskOrderByWithRelationInput[]
    cursor?: PrintOrderTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrintOrderTaskScalarFieldEnum | PrintOrderTaskScalarFieldEnum[]
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model PrintOrderTask
   */

  export type AggregatePrintOrderTask = {
    _count: PrintOrderTaskCountAggregateOutputType | null
    _avg: PrintOrderTaskAvgAggregateOutputType | null
    _sum: PrintOrderTaskSumAggregateOutputType | null
    _min: PrintOrderTaskMinAggregateOutputType | null
    _max: PrintOrderTaskMaxAggregateOutputType | null
  }

  export type PrintOrderTaskAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    customerId: number | null
    quantity: number | null
    render_retries: number | null
    orderItemId: number | null
    taskIndex: number | null
    productId: number | null
  }

  export type PrintOrderTaskSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    customerId: number | null
    quantity: number | null
    render_retries: number | null
    orderItemId: number | null
    taskIndex: number | null
    productId: number | null
  }

  export type PrintOrderTaskMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    marketplace_order_number: string | null
    customerId: number | null
    custom_text: string | null
    quantity: number | null
    color_1: string | null
    color_2: string | null
    ship_by_date: Date | null
    status: $Enums.PrintTaskStatus | null
    stl_render_state: $Enums.StlRenderStatus | null
    stl_path: string | null
    render_retries: number | null
    needs_review: boolean | null
    review_reason: string | null
    created_at: Date | null
    updated_at: Date | null
    orderItemId: number | null
    taskIndex: number | null
    productId: number | null
    shorthandProductName: string | null
    annotation: string | null
  }

  export type PrintOrderTaskMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    marketplace_order_number: string | null
    customerId: number | null
    custom_text: string | null
    quantity: number | null
    color_1: string | null
    color_2: string | null
    ship_by_date: Date | null
    status: $Enums.PrintTaskStatus | null
    stl_render_state: $Enums.StlRenderStatus | null
    stl_path: string | null
    render_retries: number | null
    needs_review: boolean | null
    review_reason: string | null
    created_at: Date | null
    updated_at: Date | null
    orderItemId: number | null
    taskIndex: number | null
    productId: number | null
    shorthandProductName: string | null
    annotation: string | null
  }

  export type PrintOrderTaskCountAggregateOutputType = {
    id: number
    orderId: number
    marketplace_order_number: number
    customerId: number
    custom_text: number
    quantity: number
    color_1: number
    color_2: number
    ship_by_date: number
    status: number
    stl_render_state: number
    stl_path: number
    render_retries: number
    needs_review: number
    review_reason: number
    created_at: number
    updated_at: number
    orderItemId: number
    taskIndex: number
    productId: number
    shorthandProductName: number
    annotation: number
    _all: number
  }


  export type PrintOrderTaskAvgAggregateInputType = {
    id?: true
    orderId?: true
    customerId?: true
    quantity?: true
    render_retries?: true
    orderItemId?: true
    taskIndex?: true
    productId?: true
  }

  export type PrintOrderTaskSumAggregateInputType = {
    id?: true
    orderId?: true
    customerId?: true
    quantity?: true
    render_retries?: true
    orderItemId?: true
    taskIndex?: true
    productId?: true
  }

  export type PrintOrderTaskMinAggregateInputType = {
    id?: true
    orderId?: true
    marketplace_order_number?: true
    customerId?: true
    custom_text?: true
    quantity?: true
    color_1?: true
    color_2?: true
    ship_by_date?: true
    status?: true
    stl_render_state?: true
    stl_path?: true
    render_retries?: true
    needs_review?: true
    review_reason?: true
    created_at?: true
    updated_at?: true
    orderItemId?: true
    taskIndex?: true
    productId?: true
    shorthandProductName?: true
    annotation?: true
  }

  export type PrintOrderTaskMaxAggregateInputType = {
    id?: true
    orderId?: true
    marketplace_order_number?: true
    customerId?: true
    custom_text?: true
    quantity?: true
    color_1?: true
    color_2?: true
    ship_by_date?: true
    status?: true
    stl_render_state?: true
    stl_path?: true
    render_retries?: true
    needs_review?: true
    review_reason?: true
    created_at?: true
    updated_at?: true
    orderItemId?: true
    taskIndex?: true
    productId?: true
    shorthandProductName?: true
    annotation?: true
  }

  export type PrintOrderTaskCountAggregateInputType = {
    id?: true
    orderId?: true
    marketplace_order_number?: true
    customerId?: true
    custom_text?: true
    quantity?: true
    color_1?: true
    color_2?: true
    ship_by_date?: true
    status?: true
    stl_render_state?: true
    stl_path?: true
    render_retries?: true
    needs_review?: true
    review_reason?: true
    created_at?: true
    updated_at?: true
    orderItemId?: true
    taskIndex?: true
    productId?: true
    shorthandProductName?: true
    annotation?: true
    _all?: true
  }

  export type PrintOrderTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrintOrderTask to aggregate.
     */
    where?: PrintOrderTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrintOrderTasks to fetch.
     */
    orderBy?: PrintOrderTaskOrderByWithRelationInput | PrintOrderTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrintOrderTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrintOrderTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrintOrderTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrintOrderTasks
    **/
    _count?: true | PrintOrderTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrintOrderTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrintOrderTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrintOrderTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrintOrderTaskMaxAggregateInputType
  }

  export type GetPrintOrderTaskAggregateType<T extends PrintOrderTaskAggregateArgs> = {
        [P in keyof T & keyof AggregatePrintOrderTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrintOrderTask[P]>
      : GetScalarType<T[P], AggregatePrintOrderTask[P]>
  }




  export type PrintOrderTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrintOrderTaskWhereInput
    orderBy?: PrintOrderTaskOrderByWithAggregationInput | PrintOrderTaskOrderByWithAggregationInput[]
    by: PrintOrderTaskScalarFieldEnum[] | PrintOrderTaskScalarFieldEnum
    having?: PrintOrderTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrintOrderTaskCountAggregateInputType | true
    _avg?: PrintOrderTaskAvgAggregateInputType
    _sum?: PrintOrderTaskSumAggregateInputType
    _min?: PrintOrderTaskMinAggregateInputType
    _max?: PrintOrderTaskMaxAggregateInputType
  }

  export type PrintOrderTaskGroupByOutputType = {
    id: number
    orderId: number
    marketplace_order_number: string | null
    customerId: number | null
    custom_text: string | null
    quantity: number
    color_1: string | null
    color_2: string | null
    ship_by_date: Date | null
    status: $Enums.PrintTaskStatus
    stl_render_state: $Enums.StlRenderStatus
    stl_path: string | null
    render_retries: number
    needs_review: boolean
    review_reason: string | null
    created_at: Date
    updated_at: Date | null
    orderItemId: number
    taskIndex: number
    productId: number
    shorthandProductName: string | null
    annotation: string | null
    _count: PrintOrderTaskCountAggregateOutputType | null
    _avg: PrintOrderTaskAvgAggregateOutputType | null
    _sum: PrintOrderTaskSumAggregateOutputType | null
    _min: PrintOrderTaskMinAggregateOutputType | null
    _max: PrintOrderTaskMaxAggregateOutputType | null
  }

  type GetPrintOrderTaskGroupByPayload<T extends PrintOrderTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrintOrderTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrintOrderTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrintOrderTaskGroupByOutputType[P]>
            : GetScalarType<T[P], PrintOrderTaskGroupByOutputType[P]>
        }
      >
    >


  export type PrintOrderTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    marketplace_order_number?: boolean
    customerId?: boolean
    custom_text?: boolean
    quantity?: boolean
    color_1?: boolean
    color_2?: boolean
    ship_by_date?: boolean
    status?: boolean
    stl_render_state?: boolean
    stl_path?: boolean
    render_retries?: boolean
    needs_review?: boolean
    review_reason?: boolean
    created_at?: boolean
    updated_at?: boolean
    orderItemId?: boolean
    taskIndex?: boolean
    productId?: boolean
    shorthandProductName?: boolean
    annotation?: boolean
    customer?: boolean | PrintOrderTask$customerArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["printOrderTask"]>



  export type PrintOrderTaskSelectScalar = {
    id?: boolean
    orderId?: boolean
    marketplace_order_number?: boolean
    customerId?: boolean
    custom_text?: boolean
    quantity?: boolean
    color_1?: boolean
    color_2?: boolean
    ship_by_date?: boolean
    status?: boolean
    stl_render_state?: boolean
    stl_path?: boolean
    render_retries?: boolean
    needs_review?: boolean
    review_reason?: boolean
    created_at?: boolean
    updated_at?: boolean
    orderItemId?: boolean
    taskIndex?: boolean
    productId?: boolean
    shorthandProductName?: boolean
    annotation?: boolean
  }

  export type PrintOrderTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "marketplace_order_number" | "customerId" | "custom_text" | "quantity" | "color_1" | "color_2" | "ship_by_date" | "status" | "stl_render_state" | "stl_path" | "render_retries" | "needs_review" | "review_reason" | "created_at" | "updated_at" | "orderItemId" | "taskIndex" | "productId" | "shorthandProductName" | "annotation", ExtArgs["result"]["printOrderTask"]>
  export type PrintOrderTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | PrintOrderTask$customerArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $PrintOrderTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrintOrderTask"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      order: Prisma.$OrderPayload<ExtArgs>
      orderItem: Prisma.$OrderItemPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      marketplace_order_number: string | null
      customerId: number | null
      custom_text: string | null
      quantity: number
      color_1: string | null
      color_2: string | null
      ship_by_date: Date | null
      status: $Enums.PrintTaskStatus
      stl_render_state: $Enums.StlRenderStatus
      stl_path: string | null
      render_retries: number
      needs_review: boolean
      review_reason: string | null
      created_at: Date
      updated_at: Date | null
      orderItemId: number
      taskIndex: number
      productId: number
      shorthandProductName: string | null
      annotation: string | null
    }, ExtArgs["result"]["printOrderTask"]>
    composites: {}
  }

  type PrintOrderTaskGetPayload<S extends boolean | null | undefined | PrintOrderTaskDefaultArgs> = $Result.GetResult<Prisma.$PrintOrderTaskPayload, S>

  type PrintOrderTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrintOrderTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrintOrderTaskCountAggregateInputType | true
    }

  export interface PrintOrderTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrintOrderTask'], meta: { name: 'PrintOrderTask' } }
    /**
     * Find zero or one PrintOrderTask that matches the filter.
     * @param {PrintOrderTaskFindUniqueArgs} args - Arguments to find a PrintOrderTask
     * @example
     * // Get one PrintOrderTask
     * const printOrderTask = await prisma.printOrderTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrintOrderTaskFindUniqueArgs>(args: SelectSubset<T, PrintOrderTaskFindUniqueArgs<ExtArgs>>): Prisma__PrintOrderTaskClient<$Result.GetResult<Prisma.$PrintOrderTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrintOrderTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrintOrderTaskFindUniqueOrThrowArgs} args - Arguments to find a PrintOrderTask
     * @example
     * // Get one PrintOrderTask
     * const printOrderTask = await prisma.printOrderTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrintOrderTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, PrintOrderTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrintOrderTaskClient<$Result.GetResult<Prisma.$PrintOrderTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrintOrderTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintOrderTaskFindFirstArgs} args - Arguments to find a PrintOrderTask
     * @example
     * // Get one PrintOrderTask
     * const printOrderTask = await prisma.printOrderTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrintOrderTaskFindFirstArgs>(args?: SelectSubset<T, PrintOrderTaskFindFirstArgs<ExtArgs>>): Prisma__PrintOrderTaskClient<$Result.GetResult<Prisma.$PrintOrderTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrintOrderTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintOrderTaskFindFirstOrThrowArgs} args - Arguments to find a PrintOrderTask
     * @example
     * // Get one PrintOrderTask
     * const printOrderTask = await prisma.printOrderTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrintOrderTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, PrintOrderTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrintOrderTaskClient<$Result.GetResult<Prisma.$PrintOrderTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrintOrderTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintOrderTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrintOrderTasks
     * const printOrderTasks = await prisma.printOrderTask.findMany()
     * 
     * // Get first 10 PrintOrderTasks
     * const printOrderTasks = await prisma.printOrderTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const printOrderTaskWithIdOnly = await prisma.printOrderTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrintOrderTaskFindManyArgs>(args?: SelectSubset<T, PrintOrderTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrintOrderTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrintOrderTask.
     * @param {PrintOrderTaskCreateArgs} args - Arguments to create a PrintOrderTask.
     * @example
     * // Create one PrintOrderTask
     * const PrintOrderTask = await prisma.printOrderTask.create({
     *   data: {
     *     // ... data to create a PrintOrderTask
     *   }
     * })
     * 
     */
    create<T extends PrintOrderTaskCreateArgs>(args: SelectSubset<T, PrintOrderTaskCreateArgs<ExtArgs>>): Prisma__PrintOrderTaskClient<$Result.GetResult<Prisma.$PrintOrderTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrintOrderTasks.
     * @param {PrintOrderTaskCreateManyArgs} args - Arguments to create many PrintOrderTasks.
     * @example
     * // Create many PrintOrderTasks
     * const printOrderTask = await prisma.printOrderTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrintOrderTaskCreateManyArgs>(args?: SelectSubset<T, PrintOrderTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PrintOrderTask.
     * @param {PrintOrderTaskDeleteArgs} args - Arguments to delete one PrintOrderTask.
     * @example
     * // Delete one PrintOrderTask
     * const PrintOrderTask = await prisma.printOrderTask.delete({
     *   where: {
     *     // ... filter to delete one PrintOrderTask
     *   }
     * })
     * 
     */
    delete<T extends PrintOrderTaskDeleteArgs>(args: SelectSubset<T, PrintOrderTaskDeleteArgs<ExtArgs>>): Prisma__PrintOrderTaskClient<$Result.GetResult<Prisma.$PrintOrderTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrintOrderTask.
     * @param {PrintOrderTaskUpdateArgs} args - Arguments to update one PrintOrderTask.
     * @example
     * // Update one PrintOrderTask
     * const printOrderTask = await prisma.printOrderTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrintOrderTaskUpdateArgs>(args: SelectSubset<T, PrintOrderTaskUpdateArgs<ExtArgs>>): Prisma__PrintOrderTaskClient<$Result.GetResult<Prisma.$PrintOrderTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrintOrderTasks.
     * @param {PrintOrderTaskDeleteManyArgs} args - Arguments to filter PrintOrderTasks to delete.
     * @example
     * // Delete a few PrintOrderTasks
     * const { count } = await prisma.printOrderTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrintOrderTaskDeleteManyArgs>(args?: SelectSubset<T, PrintOrderTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrintOrderTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintOrderTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrintOrderTasks
     * const printOrderTask = await prisma.printOrderTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrintOrderTaskUpdateManyArgs>(args: SelectSubset<T, PrintOrderTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PrintOrderTask.
     * @param {PrintOrderTaskUpsertArgs} args - Arguments to update or create a PrintOrderTask.
     * @example
     * // Update or create a PrintOrderTask
     * const printOrderTask = await prisma.printOrderTask.upsert({
     *   create: {
     *     // ... data to create a PrintOrderTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrintOrderTask we want to update
     *   }
     * })
     */
    upsert<T extends PrintOrderTaskUpsertArgs>(args: SelectSubset<T, PrintOrderTaskUpsertArgs<ExtArgs>>): Prisma__PrintOrderTaskClient<$Result.GetResult<Prisma.$PrintOrderTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrintOrderTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintOrderTaskCountArgs} args - Arguments to filter PrintOrderTasks to count.
     * @example
     * // Count the number of PrintOrderTasks
     * const count = await prisma.printOrderTask.count({
     *   where: {
     *     // ... the filter for the PrintOrderTasks we want to count
     *   }
     * })
    **/
    count<T extends PrintOrderTaskCountArgs>(
      args?: Subset<T, PrintOrderTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrintOrderTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrintOrderTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintOrderTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrintOrderTaskAggregateArgs>(args: Subset<T, PrintOrderTaskAggregateArgs>): Prisma.PrismaPromise<GetPrintOrderTaskAggregateType<T>>

    /**
     * Group by PrintOrderTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintOrderTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrintOrderTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrintOrderTaskGroupByArgs['orderBy'] }
        : { orderBy?: PrintOrderTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrintOrderTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrintOrderTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrintOrderTask model
   */
  readonly fields: PrintOrderTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrintOrderTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrintOrderTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends PrintOrderTask$customerArgs<ExtArgs> = {}>(args?: Subset<T, PrintOrderTask$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orderItem<T extends OrderItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderItemDefaultArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrintOrderTask model
   */
  interface PrintOrderTaskFieldRefs {
    readonly id: FieldRef<"PrintOrderTask", 'Int'>
    readonly orderId: FieldRef<"PrintOrderTask", 'Int'>
    readonly marketplace_order_number: FieldRef<"PrintOrderTask", 'String'>
    readonly customerId: FieldRef<"PrintOrderTask", 'Int'>
    readonly custom_text: FieldRef<"PrintOrderTask", 'String'>
    readonly quantity: FieldRef<"PrintOrderTask", 'Int'>
    readonly color_1: FieldRef<"PrintOrderTask", 'String'>
    readonly color_2: FieldRef<"PrintOrderTask", 'String'>
    readonly ship_by_date: FieldRef<"PrintOrderTask", 'DateTime'>
    readonly status: FieldRef<"PrintOrderTask", 'PrintTaskStatus'>
    readonly stl_render_state: FieldRef<"PrintOrderTask", 'StlRenderStatus'>
    readonly stl_path: FieldRef<"PrintOrderTask", 'String'>
    readonly render_retries: FieldRef<"PrintOrderTask", 'Int'>
    readonly needs_review: FieldRef<"PrintOrderTask", 'Boolean'>
    readonly review_reason: FieldRef<"PrintOrderTask", 'String'>
    readonly created_at: FieldRef<"PrintOrderTask", 'DateTime'>
    readonly updated_at: FieldRef<"PrintOrderTask", 'DateTime'>
    readonly orderItemId: FieldRef<"PrintOrderTask", 'Int'>
    readonly taskIndex: FieldRef<"PrintOrderTask", 'Int'>
    readonly productId: FieldRef<"PrintOrderTask", 'Int'>
    readonly shorthandProductName: FieldRef<"PrintOrderTask", 'String'>
    readonly annotation: FieldRef<"PrintOrderTask", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PrintOrderTask findUnique
   */
  export type PrintOrderTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOrderTask
     */
    select?: PrintOrderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintOrderTask
     */
    omit?: PrintOrderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintOrderTaskInclude<ExtArgs> | null
    /**
     * Filter, which PrintOrderTask to fetch.
     */
    where: PrintOrderTaskWhereUniqueInput
  }

  /**
   * PrintOrderTask findUniqueOrThrow
   */
  export type PrintOrderTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOrderTask
     */
    select?: PrintOrderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintOrderTask
     */
    omit?: PrintOrderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintOrderTaskInclude<ExtArgs> | null
    /**
     * Filter, which PrintOrderTask to fetch.
     */
    where: PrintOrderTaskWhereUniqueInput
  }

  /**
   * PrintOrderTask findFirst
   */
  export type PrintOrderTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOrderTask
     */
    select?: PrintOrderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintOrderTask
     */
    omit?: PrintOrderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintOrderTaskInclude<ExtArgs> | null
    /**
     * Filter, which PrintOrderTask to fetch.
     */
    where?: PrintOrderTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrintOrderTasks to fetch.
     */
    orderBy?: PrintOrderTaskOrderByWithRelationInput | PrintOrderTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrintOrderTasks.
     */
    cursor?: PrintOrderTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrintOrderTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrintOrderTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrintOrderTasks.
     */
    distinct?: PrintOrderTaskScalarFieldEnum | PrintOrderTaskScalarFieldEnum[]
  }

  /**
   * PrintOrderTask findFirstOrThrow
   */
  export type PrintOrderTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOrderTask
     */
    select?: PrintOrderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintOrderTask
     */
    omit?: PrintOrderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintOrderTaskInclude<ExtArgs> | null
    /**
     * Filter, which PrintOrderTask to fetch.
     */
    where?: PrintOrderTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrintOrderTasks to fetch.
     */
    orderBy?: PrintOrderTaskOrderByWithRelationInput | PrintOrderTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrintOrderTasks.
     */
    cursor?: PrintOrderTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrintOrderTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrintOrderTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrintOrderTasks.
     */
    distinct?: PrintOrderTaskScalarFieldEnum | PrintOrderTaskScalarFieldEnum[]
  }

  /**
   * PrintOrderTask findMany
   */
  export type PrintOrderTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOrderTask
     */
    select?: PrintOrderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintOrderTask
     */
    omit?: PrintOrderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintOrderTaskInclude<ExtArgs> | null
    /**
     * Filter, which PrintOrderTasks to fetch.
     */
    where?: PrintOrderTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrintOrderTasks to fetch.
     */
    orderBy?: PrintOrderTaskOrderByWithRelationInput | PrintOrderTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrintOrderTasks.
     */
    cursor?: PrintOrderTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrintOrderTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrintOrderTasks.
     */
    skip?: number
    distinct?: PrintOrderTaskScalarFieldEnum | PrintOrderTaskScalarFieldEnum[]
  }

  /**
   * PrintOrderTask create
   */
  export type PrintOrderTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOrderTask
     */
    select?: PrintOrderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintOrderTask
     */
    omit?: PrintOrderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintOrderTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a PrintOrderTask.
     */
    data: XOR<PrintOrderTaskCreateInput, PrintOrderTaskUncheckedCreateInput>
  }

  /**
   * PrintOrderTask createMany
   */
  export type PrintOrderTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrintOrderTasks.
     */
    data: PrintOrderTaskCreateManyInput | PrintOrderTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrintOrderTask update
   */
  export type PrintOrderTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOrderTask
     */
    select?: PrintOrderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintOrderTask
     */
    omit?: PrintOrderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintOrderTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a PrintOrderTask.
     */
    data: XOR<PrintOrderTaskUpdateInput, PrintOrderTaskUncheckedUpdateInput>
    /**
     * Choose, which PrintOrderTask to update.
     */
    where: PrintOrderTaskWhereUniqueInput
  }

  /**
   * PrintOrderTask updateMany
   */
  export type PrintOrderTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrintOrderTasks.
     */
    data: XOR<PrintOrderTaskUpdateManyMutationInput, PrintOrderTaskUncheckedUpdateManyInput>
    /**
     * Filter which PrintOrderTasks to update
     */
    where?: PrintOrderTaskWhereInput
    /**
     * Limit how many PrintOrderTasks to update.
     */
    limit?: number
  }

  /**
   * PrintOrderTask upsert
   */
  export type PrintOrderTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOrderTask
     */
    select?: PrintOrderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintOrderTask
     */
    omit?: PrintOrderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintOrderTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the PrintOrderTask to update in case it exists.
     */
    where: PrintOrderTaskWhereUniqueInput
    /**
     * In case the PrintOrderTask found by the `where` argument doesn't exist, create a new PrintOrderTask with this data.
     */
    create: XOR<PrintOrderTaskCreateInput, PrintOrderTaskUncheckedCreateInput>
    /**
     * In case the PrintOrderTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrintOrderTaskUpdateInput, PrintOrderTaskUncheckedUpdateInput>
  }

  /**
   * PrintOrderTask delete
   */
  export type PrintOrderTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOrderTask
     */
    select?: PrintOrderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintOrderTask
     */
    omit?: PrintOrderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintOrderTaskInclude<ExtArgs> | null
    /**
     * Filter which PrintOrderTask to delete.
     */
    where: PrintOrderTaskWhereUniqueInput
  }

  /**
   * PrintOrderTask deleteMany
   */
  export type PrintOrderTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrintOrderTasks to delete
     */
    where?: PrintOrderTaskWhereInput
    /**
     * Limit how many PrintOrderTasks to delete.
     */
    limit?: number
  }

  /**
   * PrintOrderTask.customer
   */
  export type PrintOrderTask$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * PrintOrderTask without action
   */
  export type PrintOrderTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOrderTask
     */
    select?: PrintOrderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintOrderTask
     */
    omit?: PrintOrderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintOrderTaskInclude<ExtArgs> | null
  }


  /**
   * Model AmazonCustomizationFile
   */

  export type AggregateAmazonCustomizationFile = {
    _count: AmazonCustomizationFileCountAggregateOutputType | null
    _avg: AmazonCustomizationFileAvgAggregateOutputType | null
    _sum: AmazonCustomizationFileSumAggregateOutputType | null
    _min: AmazonCustomizationFileMinAggregateOutputType | null
    _max: AmazonCustomizationFileMaxAggregateOutputType | null
  }

  export type AmazonCustomizationFileAvgAggregateOutputType = {
    id: number | null
    orderItemId: number | null
    retryCount: number | null
  }

  export type AmazonCustomizationFileSumAggregateOutputType = {
    id: number | null
    orderItemId: number | null
    retryCount: number | null
  }

  export type AmazonCustomizationFileMinAggregateOutputType = {
    id: number | null
    orderItemId: number | null
    originalUrl: string | null
    localFilePath: string | null
    downloadStatus: string | null
    processingStatus: string | null
    customText: string | null
    color1: string | null
    color2: string | null
    errorMessage: string | null
    retryCount: number | null
    lastProcessedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmazonCustomizationFileMaxAggregateOutputType = {
    id: number | null
    orderItemId: number | null
    originalUrl: string | null
    localFilePath: string | null
    downloadStatus: string | null
    processingStatus: string | null
    customText: string | null
    color1: string | null
    color2: string | null
    errorMessage: string | null
    retryCount: number | null
    lastProcessedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmazonCustomizationFileCountAggregateOutputType = {
    id: number
    orderItemId: number
    originalUrl: number
    localFilePath: number
    downloadStatus: number
    processingStatus: number
    customText: number
    color1: number
    color2: number
    rawJsonData: number
    errorMessage: number
    retryCount: number
    lastProcessedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AmazonCustomizationFileAvgAggregateInputType = {
    id?: true
    orderItemId?: true
    retryCount?: true
  }

  export type AmazonCustomizationFileSumAggregateInputType = {
    id?: true
    orderItemId?: true
    retryCount?: true
  }

  export type AmazonCustomizationFileMinAggregateInputType = {
    id?: true
    orderItemId?: true
    originalUrl?: true
    localFilePath?: true
    downloadStatus?: true
    processingStatus?: true
    customText?: true
    color1?: true
    color2?: true
    errorMessage?: true
    retryCount?: true
    lastProcessedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmazonCustomizationFileMaxAggregateInputType = {
    id?: true
    orderItemId?: true
    originalUrl?: true
    localFilePath?: true
    downloadStatus?: true
    processingStatus?: true
    customText?: true
    color1?: true
    color2?: true
    errorMessage?: true
    retryCount?: true
    lastProcessedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmazonCustomizationFileCountAggregateInputType = {
    id?: true
    orderItemId?: true
    originalUrl?: true
    localFilePath?: true
    downloadStatus?: true
    processingStatus?: true
    customText?: true
    color1?: true
    color2?: true
    rawJsonData?: true
    errorMessage?: true
    retryCount?: true
    lastProcessedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AmazonCustomizationFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AmazonCustomizationFile to aggregate.
     */
    where?: AmazonCustomizationFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmazonCustomizationFiles to fetch.
     */
    orderBy?: AmazonCustomizationFileOrderByWithRelationInput | AmazonCustomizationFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmazonCustomizationFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmazonCustomizationFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmazonCustomizationFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AmazonCustomizationFiles
    **/
    _count?: true | AmazonCustomizationFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmazonCustomizationFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmazonCustomizationFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmazonCustomizationFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmazonCustomizationFileMaxAggregateInputType
  }

  export type GetAmazonCustomizationFileAggregateType<T extends AmazonCustomizationFileAggregateArgs> = {
        [P in keyof T & keyof AggregateAmazonCustomizationFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmazonCustomizationFile[P]>
      : GetScalarType<T[P], AggregateAmazonCustomizationFile[P]>
  }




  export type AmazonCustomizationFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmazonCustomizationFileWhereInput
    orderBy?: AmazonCustomizationFileOrderByWithAggregationInput | AmazonCustomizationFileOrderByWithAggregationInput[]
    by: AmazonCustomizationFileScalarFieldEnum[] | AmazonCustomizationFileScalarFieldEnum
    having?: AmazonCustomizationFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmazonCustomizationFileCountAggregateInputType | true
    _avg?: AmazonCustomizationFileAvgAggregateInputType
    _sum?: AmazonCustomizationFileSumAggregateInputType
    _min?: AmazonCustomizationFileMinAggregateInputType
    _max?: AmazonCustomizationFileMaxAggregateInputType
  }

  export type AmazonCustomizationFileGroupByOutputType = {
    id: number
    orderItemId: number
    originalUrl: string
    localFilePath: string | null
    downloadStatus: string
    processingStatus: string
    customText: string | null
    color1: string | null
    color2: string | null
    rawJsonData: JsonValue | null
    errorMessage: string | null
    retryCount: number
    lastProcessedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AmazonCustomizationFileCountAggregateOutputType | null
    _avg: AmazonCustomizationFileAvgAggregateOutputType | null
    _sum: AmazonCustomizationFileSumAggregateOutputType | null
    _min: AmazonCustomizationFileMinAggregateOutputType | null
    _max: AmazonCustomizationFileMaxAggregateOutputType | null
  }

  type GetAmazonCustomizationFileGroupByPayload<T extends AmazonCustomizationFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmazonCustomizationFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmazonCustomizationFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmazonCustomizationFileGroupByOutputType[P]>
            : GetScalarType<T[P], AmazonCustomizationFileGroupByOutputType[P]>
        }
      >
    >


  export type AmazonCustomizationFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderItemId?: boolean
    originalUrl?: boolean
    localFilePath?: boolean
    downloadStatus?: boolean
    processingStatus?: boolean
    customText?: boolean
    color1?: boolean
    color2?: boolean
    rawJsonData?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    lastProcessedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amazonCustomizationFile"]>



  export type AmazonCustomizationFileSelectScalar = {
    id?: boolean
    orderItemId?: boolean
    originalUrl?: boolean
    localFilePath?: boolean
    downloadStatus?: boolean
    processingStatus?: boolean
    customText?: boolean
    color1?: boolean
    color2?: boolean
    rawJsonData?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    lastProcessedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AmazonCustomizationFileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderItemId" | "originalUrl" | "localFilePath" | "downloadStatus" | "processingStatus" | "customText" | "color1" | "color2" | "rawJsonData" | "errorMessage" | "retryCount" | "lastProcessedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["amazonCustomizationFile"]>
  export type AmazonCustomizationFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
  }

  export type $AmazonCustomizationFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AmazonCustomizationFile"
    objects: {
      orderItem: Prisma.$OrderItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderItemId: number
      originalUrl: string
      localFilePath: string | null
      downloadStatus: string
      processingStatus: string
      customText: string | null
      color1: string | null
      color2: string | null
      rawJsonData: Prisma.JsonValue | null
      errorMessage: string | null
      retryCount: number
      lastProcessedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["amazonCustomizationFile"]>
    composites: {}
  }

  type AmazonCustomizationFileGetPayload<S extends boolean | null | undefined | AmazonCustomizationFileDefaultArgs> = $Result.GetResult<Prisma.$AmazonCustomizationFilePayload, S>

  type AmazonCustomizationFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmazonCustomizationFileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmazonCustomizationFileCountAggregateInputType | true
    }

  export interface AmazonCustomizationFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AmazonCustomizationFile'], meta: { name: 'AmazonCustomizationFile' } }
    /**
     * Find zero or one AmazonCustomizationFile that matches the filter.
     * @param {AmazonCustomizationFileFindUniqueArgs} args - Arguments to find a AmazonCustomizationFile
     * @example
     * // Get one AmazonCustomizationFile
     * const amazonCustomizationFile = await prisma.amazonCustomizationFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmazonCustomizationFileFindUniqueArgs>(args: SelectSubset<T, AmazonCustomizationFileFindUniqueArgs<ExtArgs>>): Prisma__AmazonCustomizationFileClient<$Result.GetResult<Prisma.$AmazonCustomizationFilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AmazonCustomizationFile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmazonCustomizationFileFindUniqueOrThrowArgs} args - Arguments to find a AmazonCustomizationFile
     * @example
     * // Get one AmazonCustomizationFile
     * const amazonCustomizationFile = await prisma.amazonCustomizationFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmazonCustomizationFileFindUniqueOrThrowArgs>(args: SelectSubset<T, AmazonCustomizationFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmazonCustomizationFileClient<$Result.GetResult<Prisma.$AmazonCustomizationFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AmazonCustomizationFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonCustomizationFileFindFirstArgs} args - Arguments to find a AmazonCustomizationFile
     * @example
     * // Get one AmazonCustomizationFile
     * const amazonCustomizationFile = await prisma.amazonCustomizationFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmazonCustomizationFileFindFirstArgs>(args?: SelectSubset<T, AmazonCustomizationFileFindFirstArgs<ExtArgs>>): Prisma__AmazonCustomizationFileClient<$Result.GetResult<Prisma.$AmazonCustomizationFilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AmazonCustomizationFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonCustomizationFileFindFirstOrThrowArgs} args - Arguments to find a AmazonCustomizationFile
     * @example
     * // Get one AmazonCustomizationFile
     * const amazonCustomizationFile = await prisma.amazonCustomizationFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmazonCustomizationFileFindFirstOrThrowArgs>(args?: SelectSubset<T, AmazonCustomizationFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmazonCustomizationFileClient<$Result.GetResult<Prisma.$AmazonCustomizationFilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AmazonCustomizationFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonCustomizationFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AmazonCustomizationFiles
     * const amazonCustomizationFiles = await prisma.amazonCustomizationFile.findMany()
     * 
     * // Get first 10 AmazonCustomizationFiles
     * const amazonCustomizationFiles = await prisma.amazonCustomizationFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amazonCustomizationFileWithIdOnly = await prisma.amazonCustomizationFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmazonCustomizationFileFindManyArgs>(args?: SelectSubset<T, AmazonCustomizationFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmazonCustomizationFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AmazonCustomizationFile.
     * @param {AmazonCustomizationFileCreateArgs} args - Arguments to create a AmazonCustomizationFile.
     * @example
     * // Create one AmazonCustomizationFile
     * const AmazonCustomizationFile = await prisma.amazonCustomizationFile.create({
     *   data: {
     *     // ... data to create a AmazonCustomizationFile
     *   }
     * })
     * 
     */
    create<T extends AmazonCustomizationFileCreateArgs>(args: SelectSubset<T, AmazonCustomizationFileCreateArgs<ExtArgs>>): Prisma__AmazonCustomizationFileClient<$Result.GetResult<Prisma.$AmazonCustomizationFilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AmazonCustomizationFiles.
     * @param {AmazonCustomizationFileCreateManyArgs} args - Arguments to create many AmazonCustomizationFiles.
     * @example
     * // Create many AmazonCustomizationFiles
     * const amazonCustomizationFile = await prisma.amazonCustomizationFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmazonCustomizationFileCreateManyArgs>(args?: SelectSubset<T, AmazonCustomizationFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AmazonCustomizationFile.
     * @param {AmazonCustomizationFileDeleteArgs} args - Arguments to delete one AmazonCustomizationFile.
     * @example
     * // Delete one AmazonCustomizationFile
     * const AmazonCustomizationFile = await prisma.amazonCustomizationFile.delete({
     *   where: {
     *     // ... filter to delete one AmazonCustomizationFile
     *   }
     * })
     * 
     */
    delete<T extends AmazonCustomizationFileDeleteArgs>(args: SelectSubset<T, AmazonCustomizationFileDeleteArgs<ExtArgs>>): Prisma__AmazonCustomizationFileClient<$Result.GetResult<Prisma.$AmazonCustomizationFilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AmazonCustomizationFile.
     * @param {AmazonCustomizationFileUpdateArgs} args - Arguments to update one AmazonCustomizationFile.
     * @example
     * // Update one AmazonCustomizationFile
     * const amazonCustomizationFile = await prisma.amazonCustomizationFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmazonCustomizationFileUpdateArgs>(args: SelectSubset<T, AmazonCustomizationFileUpdateArgs<ExtArgs>>): Prisma__AmazonCustomizationFileClient<$Result.GetResult<Prisma.$AmazonCustomizationFilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AmazonCustomizationFiles.
     * @param {AmazonCustomizationFileDeleteManyArgs} args - Arguments to filter AmazonCustomizationFiles to delete.
     * @example
     * // Delete a few AmazonCustomizationFiles
     * const { count } = await prisma.amazonCustomizationFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmazonCustomizationFileDeleteManyArgs>(args?: SelectSubset<T, AmazonCustomizationFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AmazonCustomizationFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonCustomizationFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AmazonCustomizationFiles
     * const amazonCustomizationFile = await prisma.amazonCustomizationFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmazonCustomizationFileUpdateManyArgs>(args: SelectSubset<T, AmazonCustomizationFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AmazonCustomizationFile.
     * @param {AmazonCustomizationFileUpsertArgs} args - Arguments to update or create a AmazonCustomizationFile.
     * @example
     * // Update or create a AmazonCustomizationFile
     * const amazonCustomizationFile = await prisma.amazonCustomizationFile.upsert({
     *   create: {
     *     // ... data to create a AmazonCustomizationFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AmazonCustomizationFile we want to update
     *   }
     * })
     */
    upsert<T extends AmazonCustomizationFileUpsertArgs>(args: SelectSubset<T, AmazonCustomizationFileUpsertArgs<ExtArgs>>): Prisma__AmazonCustomizationFileClient<$Result.GetResult<Prisma.$AmazonCustomizationFilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AmazonCustomizationFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonCustomizationFileCountArgs} args - Arguments to filter AmazonCustomizationFiles to count.
     * @example
     * // Count the number of AmazonCustomizationFiles
     * const count = await prisma.amazonCustomizationFile.count({
     *   where: {
     *     // ... the filter for the AmazonCustomizationFiles we want to count
     *   }
     * })
    **/
    count<T extends AmazonCustomizationFileCountArgs>(
      args?: Subset<T, AmazonCustomizationFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmazonCustomizationFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AmazonCustomizationFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonCustomizationFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmazonCustomizationFileAggregateArgs>(args: Subset<T, AmazonCustomizationFileAggregateArgs>): Prisma.PrismaPromise<GetAmazonCustomizationFileAggregateType<T>>

    /**
     * Group by AmazonCustomizationFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonCustomizationFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmazonCustomizationFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmazonCustomizationFileGroupByArgs['orderBy'] }
        : { orderBy?: AmazonCustomizationFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmazonCustomizationFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmazonCustomizationFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AmazonCustomizationFile model
   */
  readonly fields: AmazonCustomizationFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AmazonCustomizationFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmazonCustomizationFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItem<T extends OrderItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderItemDefaultArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AmazonCustomizationFile model
   */
  interface AmazonCustomizationFileFieldRefs {
    readonly id: FieldRef<"AmazonCustomizationFile", 'Int'>
    readonly orderItemId: FieldRef<"AmazonCustomizationFile", 'Int'>
    readonly originalUrl: FieldRef<"AmazonCustomizationFile", 'String'>
    readonly localFilePath: FieldRef<"AmazonCustomizationFile", 'String'>
    readonly downloadStatus: FieldRef<"AmazonCustomizationFile", 'String'>
    readonly processingStatus: FieldRef<"AmazonCustomizationFile", 'String'>
    readonly customText: FieldRef<"AmazonCustomizationFile", 'String'>
    readonly color1: FieldRef<"AmazonCustomizationFile", 'String'>
    readonly color2: FieldRef<"AmazonCustomizationFile", 'String'>
    readonly rawJsonData: FieldRef<"AmazonCustomizationFile", 'Json'>
    readonly errorMessage: FieldRef<"AmazonCustomizationFile", 'String'>
    readonly retryCount: FieldRef<"AmazonCustomizationFile", 'Int'>
    readonly lastProcessedAt: FieldRef<"AmazonCustomizationFile", 'DateTime'>
    readonly createdAt: FieldRef<"AmazonCustomizationFile", 'DateTime'>
    readonly updatedAt: FieldRef<"AmazonCustomizationFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AmazonCustomizationFile findUnique
   */
  export type AmazonCustomizationFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonCustomizationFile
     */
    select?: AmazonCustomizationFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonCustomizationFile
     */
    omit?: AmazonCustomizationFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonCustomizationFileInclude<ExtArgs> | null
    /**
     * Filter, which AmazonCustomizationFile to fetch.
     */
    where: AmazonCustomizationFileWhereUniqueInput
  }

  /**
   * AmazonCustomizationFile findUniqueOrThrow
   */
  export type AmazonCustomizationFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonCustomizationFile
     */
    select?: AmazonCustomizationFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonCustomizationFile
     */
    omit?: AmazonCustomizationFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonCustomizationFileInclude<ExtArgs> | null
    /**
     * Filter, which AmazonCustomizationFile to fetch.
     */
    where: AmazonCustomizationFileWhereUniqueInput
  }

  /**
   * AmazonCustomizationFile findFirst
   */
  export type AmazonCustomizationFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonCustomizationFile
     */
    select?: AmazonCustomizationFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonCustomizationFile
     */
    omit?: AmazonCustomizationFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonCustomizationFileInclude<ExtArgs> | null
    /**
     * Filter, which AmazonCustomizationFile to fetch.
     */
    where?: AmazonCustomizationFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmazonCustomizationFiles to fetch.
     */
    orderBy?: AmazonCustomizationFileOrderByWithRelationInput | AmazonCustomizationFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmazonCustomizationFiles.
     */
    cursor?: AmazonCustomizationFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmazonCustomizationFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmazonCustomizationFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmazonCustomizationFiles.
     */
    distinct?: AmazonCustomizationFileScalarFieldEnum | AmazonCustomizationFileScalarFieldEnum[]
  }

  /**
   * AmazonCustomizationFile findFirstOrThrow
   */
  export type AmazonCustomizationFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonCustomizationFile
     */
    select?: AmazonCustomizationFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonCustomizationFile
     */
    omit?: AmazonCustomizationFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonCustomizationFileInclude<ExtArgs> | null
    /**
     * Filter, which AmazonCustomizationFile to fetch.
     */
    where?: AmazonCustomizationFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmazonCustomizationFiles to fetch.
     */
    orderBy?: AmazonCustomizationFileOrderByWithRelationInput | AmazonCustomizationFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmazonCustomizationFiles.
     */
    cursor?: AmazonCustomizationFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmazonCustomizationFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmazonCustomizationFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmazonCustomizationFiles.
     */
    distinct?: AmazonCustomizationFileScalarFieldEnum | AmazonCustomizationFileScalarFieldEnum[]
  }

  /**
   * AmazonCustomizationFile findMany
   */
  export type AmazonCustomizationFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonCustomizationFile
     */
    select?: AmazonCustomizationFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonCustomizationFile
     */
    omit?: AmazonCustomizationFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonCustomizationFileInclude<ExtArgs> | null
    /**
     * Filter, which AmazonCustomizationFiles to fetch.
     */
    where?: AmazonCustomizationFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmazonCustomizationFiles to fetch.
     */
    orderBy?: AmazonCustomizationFileOrderByWithRelationInput | AmazonCustomizationFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AmazonCustomizationFiles.
     */
    cursor?: AmazonCustomizationFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmazonCustomizationFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmazonCustomizationFiles.
     */
    skip?: number
    distinct?: AmazonCustomizationFileScalarFieldEnum | AmazonCustomizationFileScalarFieldEnum[]
  }

  /**
   * AmazonCustomizationFile create
   */
  export type AmazonCustomizationFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonCustomizationFile
     */
    select?: AmazonCustomizationFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonCustomizationFile
     */
    omit?: AmazonCustomizationFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonCustomizationFileInclude<ExtArgs> | null
    /**
     * The data needed to create a AmazonCustomizationFile.
     */
    data: XOR<AmazonCustomizationFileCreateInput, AmazonCustomizationFileUncheckedCreateInput>
  }

  /**
   * AmazonCustomizationFile createMany
   */
  export type AmazonCustomizationFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AmazonCustomizationFiles.
     */
    data: AmazonCustomizationFileCreateManyInput | AmazonCustomizationFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AmazonCustomizationFile update
   */
  export type AmazonCustomizationFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonCustomizationFile
     */
    select?: AmazonCustomizationFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonCustomizationFile
     */
    omit?: AmazonCustomizationFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonCustomizationFileInclude<ExtArgs> | null
    /**
     * The data needed to update a AmazonCustomizationFile.
     */
    data: XOR<AmazonCustomizationFileUpdateInput, AmazonCustomizationFileUncheckedUpdateInput>
    /**
     * Choose, which AmazonCustomizationFile to update.
     */
    where: AmazonCustomizationFileWhereUniqueInput
  }

  /**
   * AmazonCustomizationFile updateMany
   */
  export type AmazonCustomizationFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AmazonCustomizationFiles.
     */
    data: XOR<AmazonCustomizationFileUpdateManyMutationInput, AmazonCustomizationFileUncheckedUpdateManyInput>
    /**
     * Filter which AmazonCustomizationFiles to update
     */
    where?: AmazonCustomizationFileWhereInput
    /**
     * Limit how many AmazonCustomizationFiles to update.
     */
    limit?: number
  }

  /**
   * AmazonCustomizationFile upsert
   */
  export type AmazonCustomizationFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonCustomizationFile
     */
    select?: AmazonCustomizationFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonCustomizationFile
     */
    omit?: AmazonCustomizationFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonCustomizationFileInclude<ExtArgs> | null
    /**
     * The filter to search for the AmazonCustomizationFile to update in case it exists.
     */
    where: AmazonCustomizationFileWhereUniqueInput
    /**
     * In case the AmazonCustomizationFile found by the `where` argument doesn't exist, create a new AmazonCustomizationFile with this data.
     */
    create: XOR<AmazonCustomizationFileCreateInput, AmazonCustomizationFileUncheckedCreateInput>
    /**
     * In case the AmazonCustomizationFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmazonCustomizationFileUpdateInput, AmazonCustomizationFileUncheckedUpdateInput>
  }

  /**
   * AmazonCustomizationFile delete
   */
  export type AmazonCustomizationFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonCustomizationFile
     */
    select?: AmazonCustomizationFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonCustomizationFile
     */
    omit?: AmazonCustomizationFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonCustomizationFileInclude<ExtArgs> | null
    /**
     * Filter which AmazonCustomizationFile to delete.
     */
    where: AmazonCustomizationFileWhereUniqueInput
  }

  /**
   * AmazonCustomizationFile deleteMany
   */
  export type AmazonCustomizationFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AmazonCustomizationFiles to delete
     */
    where?: AmazonCustomizationFileWhereInput
    /**
     * Limit how many AmazonCustomizationFiles to delete.
     */
    limit?: number
  }

  /**
   * AmazonCustomizationFile without action
   */
  export type AmazonCustomizationFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonCustomizationFile
     */
    select?: AmazonCustomizationFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonCustomizationFile
     */
    omit?: AmazonCustomizationFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonCustomizationFileInclude<ExtArgs> | null
  }


  /**
   * Model system_logs
   */

  export type AggregateSystem_logs = {
    _count: System_logsCountAggregateOutputType | null
    _avg: System_logsAvgAggregateOutputType | null
    _sum: System_logsSumAggregateOutputType | null
    _min: System_logsMinAggregateOutputType | null
    _max: System_logsMaxAggregateOutputType | null
  }

  export type System_logsAvgAggregateOutputType = {
    id: number | null
  }

  export type System_logsSumAggregateOutputType = {
    id: number | null
  }

  export type System_logsMinAggregateOutputType = {
    id: number | null
    message: string | null
    level: string | null
    timestamp: Date | null
  }

  export type System_logsMaxAggregateOutputType = {
    id: number | null
    message: string | null
    level: string | null
    timestamp: Date | null
  }

  export type System_logsCountAggregateOutputType = {
    id: number
    message: number
    level: number
    timestamp: number
    _all: number
  }


  export type System_logsAvgAggregateInputType = {
    id?: true
  }

  export type System_logsSumAggregateInputType = {
    id?: true
  }

  export type System_logsMinAggregateInputType = {
    id?: true
    message?: true
    level?: true
    timestamp?: true
  }

  export type System_logsMaxAggregateInputType = {
    id?: true
    message?: true
    level?: true
    timestamp?: true
  }

  export type System_logsCountAggregateInputType = {
    id?: true
    message?: true
    level?: true
    timestamp?: true
    _all?: true
  }

  export type System_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which system_logs to aggregate.
     */
    where?: system_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of system_logs to fetch.
     */
    orderBy?: system_logsOrderByWithRelationInput | system_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: system_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` system_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` system_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned system_logs
    **/
    _count?: true | System_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: System_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: System_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: System_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: System_logsMaxAggregateInputType
  }

  export type GetSystem_logsAggregateType<T extends System_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystem_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystem_logs[P]>
      : GetScalarType<T[P], AggregateSystem_logs[P]>
  }




  export type system_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: system_logsWhereInput
    orderBy?: system_logsOrderByWithAggregationInput | system_logsOrderByWithAggregationInput[]
    by: System_logsScalarFieldEnum[] | System_logsScalarFieldEnum
    having?: system_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: System_logsCountAggregateInputType | true
    _avg?: System_logsAvgAggregateInputType
    _sum?: System_logsSumAggregateInputType
    _min?: System_logsMinAggregateInputType
    _max?: System_logsMaxAggregateInputType
  }

  export type System_logsGroupByOutputType = {
    id: number
    message: string | null
    level: string | null
    timestamp: Date
    _count: System_logsCountAggregateOutputType | null
    _avg: System_logsAvgAggregateOutputType | null
    _sum: System_logsSumAggregateOutputType | null
    _min: System_logsMinAggregateOutputType | null
    _max: System_logsMaxAggregateOutputType | null
  }

  type GetSystem_logsGroupByPayload<T extends system_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<System_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof System_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], System_logsGroupByOutputType[P]>
            : GetScalarType<T[P], System_logsGroupByOutputType[P]>
        }
      >
    >


  export type system_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    level?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["system_logs"]>



  export type system_logsSelectScalar = {
    id?: boolean
    message?: boolean
    level?: boolean
    timestamp?: boolean
  }

  export type system_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "message" | "level" | "timestamp", ExtArgs["result"]["system_logs"]>

  export type $system_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "system_logs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      message: string | null
      level: string | null
      timestamp: Date
    }, ExtArgs["result"]["system_logs"]>
    composites: {}
  }

  type system_logsGetPayload<S extends boolean | null | undefined | system_logsDefaultArgs> = $Result.GetResult<Prisma.$system_logsPayload, S>

  type system_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<system_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: System_logsCountAggregateInputType | true
    }

  export interface system_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['system_logs'], meta: { name: 'system_logs' } }
    /**
     * Find zero or one System_logs that matches the filter.
     * @param {system_logsFindUniqueArgs} args - Arguments to find a System_logs
     * @example
     * // Get one System_logs
     * const system_logs = await prisma.system_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends system_logsFindUniqueArgs>(args: SelectSubset<T, system_logsFindUniqueArgs<ExtArgs>>): Prisma__system_logsClient<$Result.GetResult<Prisma.$system_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one System_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {system_logsFindUniqueOrThrowArgs} args - Arguments to find a System_logs
     * @example
     * // Get one System_logs
     * const system_logs = await prisma.system_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends system_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, system_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__system_logsClient<$Result.GetResult<Prisma.$system_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first System_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_logsFindFirstArgs} args - Arguments to find a System_logs
     * @example
     * // Get one System_logs
     * const system_logs = await prisma.system_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends system_logsFindFirstArgs>(args?: SelectSubset<T, system_logsFindFirstArgs<ExtArgs>>): Prisma__system_logsClient<$Result.GetResult<Prisma.$system_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first System_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_logsFindFirstOrThrowArgs} args - Arguments to find a System_logs
     * @example
     * // Get one System_logs
     * const system_logs = await prisma.system_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends system_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, system_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__system_logsClient<$Result.GetResult<Prisma.$system_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more System_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all System_logs
     * const system_logs = await prisma.system_logs.findMany()
     * 
     * // Get first 10 System_logs
     * const system_logs = await prisma.system_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const system_logsWithIdOnly = await prisma.system_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends system_logsFindManyArgs>(args?: SelectSubset<T, system_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$system_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a System_logs.
     * @param {system_logsCreateArgs} args - Arguments to create a System_logs.
     * @example
     * // Create one System_logs
     * const System_logs = await prisma.system_logs.create({
     *   data: {
     *     // ... data to create a System_logs
     *   }
     * })
     * 
     */
    create<T extends system_logsCreateArgs>(args: SelectSubset<T, system_logsCreateArgs<ExtArgs>>): Prisma__system_logsClient<$Result.GetResult<Prisma.$system_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many System_logs.
     * @param {system_logsCreateManyArgs} args - Arguments to create many System_logs.
     * @example
     * // Create many System_logs
     * const system_logs = await prisma.system_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends system_logsCreateManyArgs>(args?: SelectSubset<T, system_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a System_logs.
     * @param {system_logsDeleteArgs} args - Arguments to delete one System_logs.
     * @example
     * // Delete one System_logs
     * const System_logs = await prisma.system_logs.delete({
     *   where: {
     *     // ... filter to delete one System_logs
     *   }
     * })
     * 
     */
    delete<T extends system_logsDeleteArgs>(args: SelectSubset<T, system_logsDeleteArgs<ExtArgs>>): Prisma__system_logsClient<$Result.GetResult<Prisma.$system_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one System_logs.
     * @param {system_logsUpdateArgs} args - Arguments to update one System_logs.
     * @example
     * // Update one System_logs
     * const system_logs = await prisma.system_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends system_logsUpdateArgs>(args: SelectSubset<T, system_logsUpdateArgs<ExtArgs>>): Prisma__system_logsClient<$Result.GetResult<Prisma.$system_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more System_logs.
     * @param {system_logsDeleteManyArgs} args - Arguments to filter System_logs to delete.
     * @example
     * // Delete a few System_logs
     * const { count } = await prisma.system_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends system_logsDeleteManyArgs>(args?: SelectSubset<T, system_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more System_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many System_logs
     * const system_logs = await prisma.system_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends system_logsUpdateManyArgs>(args: SelectSubset<T, system_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one System_logs.
     * @param {system_logsUpsertArgs} args - Arguments to update or create a System_logs.
     * @example
     * // Update or create a System_logs
     * const system_logs = await prisma.system_logs.upsert({
     *   create: {
     *     // ... data to create a System_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the System_logs we want to update
     *   }
     * })
     */
    upsert<T extends system_logsUpsertArgs>(args: SelectSubset<T, system_logsUpsertArgs<ExtArgs>>): Prisma__system_logsClient<$Result.GetResult<Prisma.$system_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of System_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_logsCountArgs} args - Arguments to filter System_logs to count.
     * @example
     * // Count the number of System_logs
     * const count = await prisma.system_logs.count({
     *   where: {
     *     // ... the filter for the System_logs we want to count
     *   }
     * })
    **/
    count<T extends system_logsCountArgs>(
      args?: Subset<T, system_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], System_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a System_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {System_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends System_logsAggregateArgs>(args: Subset<T, System_logsAggregateArgs>): Prisma.PrismaPromise<GetSystem_logsAggregateType<T>>

    /**
     * Group by System_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends system_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: system_logsGroupByArgs['orderBy'] }
        : { orderBy?: system_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, system_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystem_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the system_logs model
   */
  readonly fields: system_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for system_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__system_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the system_logs model
   */
  interface system_logsFieldRefs {
    readonly id: FieldRef<"system_logs", 'Int'>
    readonly message: FieldRef<"system_logs", 'String'>
    readonly level: FieldRef<"system_logs", 'String'>
    readonly timestamp: FieldRef<"system_logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * system_logs findUnique
   */
  export type system_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_logs
     */
    select?: system_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_logs
     */
    omit?: system_logsOmit<ExtArgs> | null
    /**
     * Filter, which system_logs to fetch.
     */
    where: system_logsWhereUniqueInput
  }

  /**
   * system_logs findUniqueOrThrow
   */
  export type system_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_logs
     */
    select?: system_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_logs
     */
    omit?: system_logsOmit<ExtArgs> | null
    /**
     * Filter, which system_logs to fetch.
     */
    where: system_logsWhereUniqueInput
  }

  /**
   * system_logs findFirst
   */
  export type system_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_logs
     */
    select?: system_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_logs
     */
    omit?: system_logsOmit<ExtArgs> | null
    /**
     * Filter, which system_logs to fetch.
     */
    where?: system_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of system_logs to fetch.
     */
    orderBy?: system_logsOrderByWithRelationInput | system_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for system_logs.
     */
    cursor?: system_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` system_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` system_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of system_logs.
     */
    distinct?: System_logsScalarFieldEnum | System_logsScalarFieldEnum[]
  }

  /**
   * system_logs findFirstOrThrow
   */
  export type system_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_logs
     */
    select?: system_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_logs
     */
    omit?: system_logsOmit<ExtArgs> | null
    /**
     * Filter, which system_logs to fetch.
     */
    where?: system_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of system_logs to fetch.
     */
    orderBy?: system_logsOrderByWithRelationInput | system_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for system_logs.
     */
    cursor?: system_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` system_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` system_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of system_logs.
     */
    distinct?: System_logsScalarFieldEnum | System_logsScalarFieldEnum[]
  }

  /**
   * system_logs findMany
   */
  export type system_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_logs
     */
    select?: system_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_logs
     */
    omit?: system_logsOmit<ExtArgs> | null
    /**
     * Filter, which system_logs to fetch.
     */
    where?: system_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of system_logs to fetch.
     */
    orderBy?: system_logsOrderByWithRelationInput | system_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing system_logs.
     */
    cursor?: system_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` system_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` system_logs.
     */
    skip?: number
    distinct?: System_logsScalarFieldEnum | System_logsScalarFieldEnum[]
  }

  /**
   * system_logs create
   */
  export type system_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_logs
     */
    select?: system_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_logs
     */
    omit?: system_logsOmit<ExtArgs> | null
    /**
     * The data needed to create a system_logs.
     */
    data?: XOR<system_logsCreateInput, system_logsUncheckedCreateInput>
  }

  /**
   * system_logs createMany
   */
  export type system_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many system_logs.
     */
    data: system_logsCreateManyInput | system_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * system_logs update
   */
  export type system_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_logs
     */
    select?: system_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_logs
     */
    omit?: system_logsOmit<ExtArgs> | null
    /**
     * The data needed to update a system_logs.
     */
    data: XOR<system_logsUpdateInput, system_logsUncheckedUpdateInput>
    /**
     * Choose, which system_logs to update.
     */
    where: system_logsWhereUniqueInput
  }

  /**
   * system_logs updateMany
   */
  export type system_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update system_logs.
     */
    data: XOR<system_logsUpdateManyMutationInput, system_logsUncheckedUpdateManyInput>
    /**
     * Filter which system_logs to update
     */
    where?: system_logsWhereInput
    /**
     * Limit how many system_logs to update.
     */
    limit?: number
  }

  /**
   * system_logs upsert
   */
  export type system_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_logs
     */
    select?: system_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_logs
     */
    omit?: system_logsOmit<ExtArgs> | null
    /**
     * The filter to search for the system_logs to update in case it exists.
     */
    where: system_logsWhereUniqueInput
    /**
     * In case the system_logs found by the `where` argument doesn't exist, create a new system_logs with this data.
     */
    create: XOR<system_logsCreateInput, system_logsUncheckedCreateInput>
    /**
     * In case the system_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<system_logsUpdateInput, system_logsUncheckedUpdateInput>
  }

  /**
   * system_logs delete
   */
  export type system_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_logs
     */
    select?: system_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_logs
     */
    omit?: system_logsOmit<ExtArgs> | null
    /**
     * Filter which system_logs to delete.
     */
    where: system_logsWhereUniqueInput
  }

  /**
   * system_logs deleteMany
   */
  export type system_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which system_logs to delete
     */
    where?: system_logsWhereInput
    /**
     * Limit how many system_logs to delete.
     */
    limit?: number
  }

  /**
   * system_logs without action
   */
  export type system_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_logs
     */
    select?: system_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_logs
     */
    omit?: system_logsOmit<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    id: number | null
    shipstation_tag_id: number | null
  }

  export type TagSumAggregateOutputType = {
    id: number | null
    shipstation_tag_id: number | null
  }

  export type TagMinAggregateOutputType = {
    id: number | null
    shipstation_tag_id: number | null
    name: string | null
    color_hex: string | null
    last_synced: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: number | null
    shipstation_tag_id: number | null
    name: string | null
    color_hex: string | null
    last_synced: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    shipstation_tag_id: number
    name: number
    color_hex: number
    last_synced: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    id?: true
    shipstation_tag_id?: true
  }

  export type TagSumAggregateInputType = {
    id?: true
    shipstation_tag_id?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    shipstation_tag_id?: true
    name?: true
    color_hex?: true
    last_synced?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    shipstation_tag_id?: true
    name?: true
    color_hex?: true
    last_synced?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    shipstation_tag_id?: true
    name?: true
    color_hex?: true
    last_synced?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: number
    shipstation_tag_id: number
    name: string
    color_hex: string | null
    last_synced: Date
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipstation_tag_id?: boolean
    name?: boolean
    color_hex?: boolean
    last_synced?: boolean
  }, ExtArgs["result"]["tag"]>



  export type TagSelectScalar = {
    id?: boolean
    shipstation_tag_id?: boolean
    name?: boolean
    color_hex?: boolean
    last_synced?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shipstation_tag_id" | "name" | "color_hex" | "last_synced", ExtArgs["result"]["tag"]>

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      shipstation_tag_id: number
      name: string
      color_hex: string | null
      last_synced: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'Int'>
    readonly shipstation_tag_id: FieldRef<"Tag", 'Int'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly color_hex: FieldRef<"Tag", 'String'>
    readonly last_synced: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
  }


  /**
   * Model ScriptRunLog
   */

  export type AggregateScriptRunLog = {
    _count: ScriptRunLogCountAggregateOutputType | null
    _avg: ScriptRunLogAvgAggregateOutputType | null
    _sum: ScriptRunLogSumAggregateOutputType | null
    _min: ScriptRunLogMinAggregateOutputType | null
    _max: ScriptRunLogMaxAggregateOutputType | null
  }

  export type ScriptRunLogAvgAggregateOutputType = {
    id: number | null
  }

  export type ScriptRunLogSumAggregateOutputType = {
    id: number | null
  }

  export type ScriptRunLogMinAggregateOutputType = {
    id: number | null
    scriptName: string | null
    runStartedAt: Date | null
    runEndedAt: Date | null
    status: string | null
    errorMessage: string | null
    errorStack: string | null
    createdAt: Date | null
  }

  export type ScriptRunLogMaxAggregateOutputType = {
    id: number | null
    scriptName: string | null
    runStartedAt: Date | null
    runEndedAt: Date | null
    status: string | null
    errorMessage: string | null
    errorStack: string | null
    createdAt: Date | null
  }

  export type ScriptRunLogCountAggregateOutputType = {
    id: number
    scriptName: number
    runStartedAt: number
    runEndedAt: number
    status: number
    errorMessage: number
    errorStack: number
    details: number
    createdAt: number
    _all: number
  }


  export type ScriptRunLogAvgAggregateInputType = {
    id?: true
  }

  export type ScriptRunLogSumAggregateInputType = {
    id?: true
  }

  export type ScriptRunLogMinAggregateInputType = {
    id?: true
    scriptName?: true
    runStartedAt?: true
    runEndedAt?: true
    status?: true
    errorMessage?: true
    errorStack?: true
    createdAt?: true
  }

  export type ScriptRunLogMaxAggregateInputType = {
    id?: true
    scriptName?: true
    runStartedAt?: true
    runEndedAt?: true
    status?: true
    errorMessage?: true
    errorStack?: true
    createdAt?: true
  }

  export type ScriptRunLogCountAggregateInputType = {
    id?: true
    scriptName?: true
    runStartedAt?: true
    runEndedAt?: true
    status?: true
    errorMessage?: true
    errorStack?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type ScriptRunLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScriptRunLog to aggregate.
     */
    where?: ScriptRunLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScriptRunLogs to fetch.
     */
    orderBy?: ScriptRunLogOrderByWithRelationInput | ScriptRunLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScriptRunLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScriptRunLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScriptRunLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScriptRunLogs
    **/
    _count?: true | ScriptRunLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScriptRunLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScriptRunLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScriptRunLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScriptRunLogMaxAggregateInputType
  }

  export type GetScriptRunLogAggregateType<T extends ScriptRunLogAggregateArgs> = {
        [P in keyof T & keyof AggregateScriptRunLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScriptRunLog[P]>
      : GetScalarType<T[P], AggregateScriptRunLog[P]>
  }




  export type ScriptRunLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScriptRunLogWhereInput
    orderBy?: ScriptRunLogOrderByWithAggregationInput | ScriptRunLogOrderByWithAggregationInput[]
    by: ScriptRunLogScalarFieldEnum[] | ScriptRunLogScalarFieldEnum
    having?: ScriptRunLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScriptRunLogCountAggregateInputType | true
    _avg?: ScriptRunLogAvgAggregateInputType
    _sum?: ScriptRunLogSumAggregateInputType
    _min?: ScriptRunLogMinAggregateInputType
    _max?: ScriptRunLogMaxAggregateInputType
  }

  export type ScriptRunLogGroupByOutputType = {
    id: number
    scriptName: string
    runStartedAt: Date
    runEndedAt: Date | null
    status: string
    errorMessage: string | null
    errorStack: string | null
    details: JsonValue | null
    createdAt: Date
    _count: ScriptRunLogCountAggregateOutputType | null
    _avg: ScriptRunLogAvgAggregateOutputType | null
    _sum: ScriptRunLogSumAggregateOutputType | null
    _min: ScriptRunLogMinAggregateOutputType | null
    _max: ScriptRunLogMaxAggregateOutputType | null
  }

  type GetScriptRunLogGroupByPayload<T extends ScriptRunLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScriptRunLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScriptRunLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScriptRunLogGroupByOutputType[P]>
            : GetScalarType<T[P], ScriptRunLogGroupByOutputType[P]>
        }
      >
    >


  export type ScriptRunLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scriptName?: boolean
    runStartedAt?: boolean
    runEndedAt?: boolean
    status?: boolean
    errorMessage?: boolean
    errorStack?: boolean
    details?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["scriptRunLog"]>



  export type ScriptRunLogSelectScalar = {
    id?: boolean
    scriptName?: boolean
    runStartedAt?: boolean
    runEndedAt?: boolean
    status?: boolean
    errorMessage?: boolean
    errorStack?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type ScriptRunLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "scriptName" | "runStartedAt" | "runEndedAt" | "status" | "errorMessage" | "errorStack" | "details" | "createdAt", ExtArgs["result"]["scriptRunLog"]>

  export type $ScriptRunLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScriptRunLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      scriptName: string
      runStartedAt: Date
      runEndedAt: Date | null
      status: string
      errorMessage: string | null
      errorStack: string | null
      details: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["scriptRunLog"]>
    composites: {}
  }

  type ScriptRunLogGetPayload<S extends boolean | null | undefined | ScriptRunLogDefaultArgs> = $Result.GetResult<Prisma.$ScriptRunLogPayload, S>

  type ScriptRunLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScriptRunLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScriptRunLogCountAggregateInputType | true
    }

  export interface ScriptRunLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScriptRunLog'], meta: { name: 'ScriptRunLog' } }
    /**
     * Find zero or one ScriptRunLog that matches the filter.
     * @param {ScriptRunLogFindUniqueArgs} args - Arguments to find a ScriptRunLog
     * @example
     * // Get one ScriptRunLog
     * const scriptRunLog = await prisma.scriptRunLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScriptRunLogFindUniqueArgs>(args: SelectSubset<T, ScriptRunLogFindUniqueArgs<ExtArgs>>): Prisma__ScriptRunLogClient<$Result.GetResult<Prisma.$ScriptRunLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScriptRunLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScriptRunLogFindUniqueOrThrowArgs} args - Arguments to find a ScriptRunLog
     * @example
     * // Get one ScriptRunLog
     * const scriptRunLog = await prisma.scriptRunLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScriptRunLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ScriptRunLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScriptRunLogClient<$Result.GetResult<Prisma.$ScriptRunLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScriptRunLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptRunLogFindFirstArgs} args - Arguments to find a ScriptRunLog
     * @example
     * // Get one ScriptRunLog
     * const scriptRunLog = await prisma.scriptRunLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScriptRunLogFindFirstArgs>(args?: SelectSubset<T, ScriptRunLogFindFirstArgs<ExtArgs>>): Prisma__ScriptRunLogClient<$Result.GetResult<Prisma.$ScriptRunLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScriptRunLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptRunLogFindFirstOrThrowArgs} args - Arguments to find a ScriptRunLog
     * @example
     * // Get one ScriptRunLog
     * const scriptRunLog = await prisma.scriptRunLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScriptRunLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ScriptRunLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScriptRunLogClient<$Result.GetResult<Prisma.$ScriptRunLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScriptRunLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptRunLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScriptRunLogs
     * const scriptRunLogs = await prisma.scriptRunLog.findMany()
     * 
     * // Get first 10 ScriptRunLogs
     * const scriptRunLogs = await prisma.scriptRunLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scriptRunLogWithIdOnly = await prisma.scriptRunLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScriptRunLogFindManyArgs>(args?: SelectSubset<T, ScriptRunLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScriptRunLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScriptRunLog.
     * @param {ScriptRunLogCreateArgs} args - Arguments to create a ScriptRunLog.
     * @example
     * // Create one ScriptRunLog
     * const ScriptRunLog = await prisma.scriptRunLog.create({
     *   data: {
     *     // ... data to create a ScriptRunLog
     *   }
     * })
     * 
     */
    create<T extends ScriptRunLogCreateArgs>(args: SelectSubset<T, ScriptRunLogCreateArgs<ExtArgs>>): Prisma__ScriptRunLogClient<$Result.GetResult<Prisma.$ScriptRunLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScriptRunLogs.
     * @param {ScriptRunLogCreateManyArgs} args - Arguments to create many ScriptRunLogs.
     * @example
     * // Create many ScriptRunLogs
     * const scriptRunLog = await prisma.scriptRunLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScriptRunLogCreateManyArgs>(args?: SelectSubset<T, ScriptRunLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ScriptRunLog.
     * @param {ScriptRunLogDeleteArgs} args - Arguments to delete one ScriptRunLog.
     * @example
     * // Delete one ScriptRunLog
     * const ScriptRunLog = await prisma.scriptRunLog.delete({
     *   where: {
     *     // ... filter to delete one ScriptRunLog
     *   }
     * })
     * 
     */
    delete<T extends ScriptRunLogDeleteArgs>(args: SelectSubset<T, ScriptRunLogDeleteArgs<ExtArgs>>): Prisma__ScriptRunLogClient<$Result.GetResult<Prisma.$ScriptRunLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScriptRunLog.
     * @param {ScriptRunLogUpdateArgs} args - Arguments to update one ScriptRunLog.
     * @example
     * // Update one ScriptRunLog
     * const scriptRunLog = await prisma.scriptRunLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScriptRunLogUpdateArgs>(args: SelectSubset<T, ScriptRunLogUpdateArgs<ExtArgs>>): Prisma__ScriptRunLogClient<$Result.GetResult<Prisma.$ScriptRunLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScriptRunLogs.
     * @param {ScriptRunLogDeleteManyArgs} args - Arguments to filter ScriptRunLogs to delete.
     * @example
     * // Delete a few ScriptRunLogs
     * const { count } = await prisma.scriptRunLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScriptRunLogDeleteManyArgs>(args?: SelectSubset<T, ScriptRunLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScriptRunLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptRunLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScriptRunLogs
     * const scriptRunLog = await prisma.scriptRunLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScriptRunLogUpdateManyArgs>(args: SelectSubset<T, ScriptRunLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScriptRunLog.
     * @param {ScriptRunLogUpsertArgs} args - Arguments to update or create a ScriptRunLog.
     * @example
     * // Update or create a ScriptRunLog
     * const scriptRunLog = await prisma.scriptRunLog.upsert({
     *   create: {
     *     // ... data to create a ScriptRunLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScriptRunLog we want to update
     *   }
     * })
     */
    upsert<T extends ScriptRunLogUpsertArgs>(args: SelectSubset<T, ScriptRunLogUpsertArgs<ExtArgs>>): Prisma__ScriptRunLogClient<$Result.GetResult<Prisma.$ScriptRunLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScriptRunLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptRunLogCountArgs} args - Arguments to filter ScriptRunLogs to count.
     * @example
     * // Count the number of ScriptRunLogs
     * const count = await prisma.scriptRunLog.count({
     *   where: {
     *     // ... the filter for the ScriptRunLogs we want to count
     *   }
     * })
    **/
    count<T extends ScriptRunLogCountArgs>(
      args?: Subset<T, ScriptRunLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScriptRunLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScriptRunLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptRunLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScriptRunLogAggregateArgs>(args: Subset<T, ScriptRunLogAggregateArgs>): Prisma.PrismaPromise<GetScriptRunLogAggregateType<T>>

    /**
     * Group by ScriptRunLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptRunLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScriptRunLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScriptRunLogGroupByArgs['orderBy'] }
        : { orderBy?: ScriptRunLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScriptRunLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScriptRunLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScriptRunLog model
   */
  readonly fields: ScriptRunLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScriptRunLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScriptRunLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScriptRunLog model
   */
  interface ScriptRunLogFieldRefs {
    readonly id: FieldRef<"ScriptRunLog", 'Int'>
    readonly scriptName: FieldRef<"ScriptRunLog", 'String'>
    readonly runStartedAt: FieldRef<"ScriptRunLog", 'DateTime'>
    readonly runEndedAt: FieldRef<"ScriptRunLog", 'DateTime'>
    readonly status: FieldRef<"ScriptRunLog", 'String'>
    readonly errorMessage: FieldRef<"ScriptRunLog", 'String'>
    readonly errorStack: FieldRef<"ScriptRunLog", 'String'>
    readonly details: FieldRef<"ScriptRunLog", 'Json'>
    readonly createdAt: FieldRef<"ScriptRunLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScriptRunLog findUnique
   */
  export type ScriptRunLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptRunLog
     */
    select?: ScriptRunLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScriptRunLog
     */
    omit?: ScriptRunLogOmit<ExtArgs> | null
    /**
     * Filter, which ScriptRunLog to fetch.
     */
    where: ScriptRunLogWhereUniqueInput
  }

  /**
   * ScriptRunLog findUniqueOrThrow
   */
  export type ScriptRunLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptRunLog
     */
    select?: ScriptRunLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScriptRunLog
     */
    omit?: ScriptRunLogOmit<ExtArgs> | null
    /**
     * Filter, which ScriptRunLog to fetch.
     */
    where: ScriptRunLogWhereUniqueInput
  }

  /**
   * ScriptRunLog findFirst
   */
  export type ScriptRunLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptRunLog
     */
    select?: ScriptRunLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScriptRunLog
     */
    omit?: ScriptRunLogOmit<ExtArgs> | null
    /**
     * Filter, which ScriptRunLog to fetch.
     */
    where?: ScriptRunLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScriptRunLogs to fetch.
     */
    orderBy?: ScriptRunLogOrderByWithRelationInput | ScriptRunLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScriptRunLogs.
     */
    cursor?: ScriptRunLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScriptRunLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScriptRunLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScriptRunLogs.
     */
    distinct?: ScriptRunLogScalarFieldEnum | ScriptRunLogScalarFieldEnum[]
  }

  /**
   * ScriptRunLog findFirstOrThrow
   */
  export type ScriptRunLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptRunLog
     */
    select?: ScriptRunLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScriptRunLog
     */
    omit?: ScriptRunLogOmit<ExtArgs> | null
    /**
     * Filter, which ScriptRunLog to fetch.
     */
    where?: ScriptRunLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScriptRunLogs to fetch.
     */
    orderBy?: ScriptRunLogOrderByWithRelationInput | ScriptRunLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScriptRunLogs.
     */
    cursor?: ScriptRunLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScriptRunLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScriptRunLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScriptRunLogs.
     */
    distinct?: ScriptRunLogScalarFieldEnum | ScriptRunLogScalarFieldEnum[]
  }

  /**
   * ScriptRunLog findMany
   */
  export type ScriptRunLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptRunLog
     */
    select?: ScriptRunLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScriptRunLog
     */
    omit?: ScriptRunLogOmit<ExtArgs> | null
    /**
     * Filter, which ScriptRunLogs to fetch.
     */
    where?: ScriptRunLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScriptRunLogs to fetch.
     */
    orderBy?: ScriptRunLogOrderByWithRelationInput | ScriptRunLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScriptRunLogs.
     */
    cursor?: ScriptRunLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScriptRunLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScriptRunLogs.
     */
    skip?: number
    distinct?: ScriptRunLogScalarFieldEnum | ScriptRunLogScalarFieldEnum[]
  }

  /**
   * ScriptRunLog create
   */
  export type ScriptRunLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptRunLog
     */
    select?: ScriptRunLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScriptRunLog
     */
    omit?: ScriptRunLogOmit<ExtArgs> | null
    /**
     * The data needed to create a ScriptRunLog.
     */
    data: XOR<ScriptRunLogCreateInput, ScriptRunLogUncheckedCreateInput>
  }

  /**
   * ScriptRunLog createMany
   */
  export type ScriptRunLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScriptRunLogs.
     */
    data: ScriptRunLogCreateManyInput | ScriptRunLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScriptRunLog update
   */
  export type ScriptRunLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptRunLog
     */
    select?: ScriptRunLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScriptRunLog
     */
    omit?: ScriptRunLogOmit<ExtArgs> | null
    /**
     * The data needed to update a ScriptRunLog.
     */
    data: XOR<ScriptRunLogUpdateInput, ScriptRunLogUncheckedUpdateInput>
    /**
     * Choose, which ScriptRunLog to update.
     */
    where: ScriptRunLogWhereUniqueInput
  }

  /**
   * ScriptRunLog updateMany
   */
  export type ScriptRunLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScriptRunLogs.
     */
    data: XOR<ScriptRunLogUpdateManyMutationInput, ScriptRunLogUncheckedUpdateManyInput>
    /**
     * Filter which ScriptRunLogs to update
     */
    where?: ScriptRunLogWhereInput
    /**
     * Limit how many ScriptRunLogs to update.
     */
    limit?: number
  }

  /**
   * ScriptRunLog upsert
   */
  export type ScriptRunLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptRunLog
     */
    select?: ScriptRunLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScriptRunLog
     */
    omit?: ScriptRunLogOmit<ExtArgs> | null
    /**
     * The filter to search for the ScriptRunLog to update in case it exists.
     */
    where: ScriptRunLogWhereUniqueInput
    /**
     * In case the ScriptRunLog found by the `where` argument doesn't exist, create a new ScriptRunLog with this data.
     */
    create: XOR<ScriptRunLogCreateInput, ScriptRunLogUncheckedCreateInput>
    /**
     * In case the ScriptRunLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScriptRunLogUpdateInput, ScriptRunLogUncheckedUpdateInput>
  }

  /**
   * ScriptRunLog delete
   */
  export type ScriptRunLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptRunLog
     */
    select?: ScriptRunLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScriptRunLog
     */
    omit?: ScriptRunLogOmit<ExtArgs> | null
    /**
     * Filter which ScriptRunLog to delete.
     */
    where: ScriptRunLogWhereUniqueInput
  }

  /**
   * ScriptRunLog deleteMany
   */
  export type ScriptRunLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScriptRunLogs to delete
     */
    where?: ScriptRunLogWhereInput
    /**
     * Limit how many ScriptRunLogs to delete.
     */
    limit?: number
  }

  /**
   * ScriptRunLog without action
   */
  export type ScriptRunLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptRunLog
     */
    select?: ScriptRunLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScriptRunLog
     */
    omit?: ScriptRunLogOmit<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    emailVerified: Date | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    emailVerified: Date | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    name: string | null
    emailVerified: Date | null
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "emailVerified" | "image" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      name: string | null
      emailVerified: Date | null
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    id: number | null
    userId: number | null
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    id?: true
    userId?: true
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    id?: true
    userId?: true
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: number
    userId: number
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>



  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'Int'>
    readonly userId: FieldRef<"Account", 'Int'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: number | null
    sessionToken: string | null
    userId: number | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: number | null
    sessionToken: string | null
    userId: number | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SessionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: number
    sessionToken: string
    userId: number
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>



  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sessionToken: string
      userId: number
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'Int'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'Int'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>



  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model SyncProgress
   */

  export type AggregateSyncProgress = {
    _count: SyncProgressCountAggregateOutputType | null
    _avg: SyncProgressAvgAggregateOutputType | null
    _sum: SyncProgressSumAggregateOutputType | null
    _min: SyncProgressMinAggregateOutputType | null
    _max: SyncProgressMaxAggregateOutputType | null
  }

  export type SyncProgressAvgAggregateOutputType = {
    totalOrders: number | null
    processedOrders: number | null
    failedOrders: number | null
  }

  export type SyncProgressSumAggregateOutputType = {
    totalOrders: number | null
    processedOrders: number | null
    failedOrders: number | null
  }

  export type SyncProgressMinAggregateOutputType = {
    id: string | null
    syncType: string | null
    startTime: Date | null
    endTime: Date | null
    status: string | null
    totalOrders: number | null
    processedOrders: number | null
    failedOrders: number | null
    lastProcessedOrderId: string | null
    lastProcessedTimestamp: Date | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SyncProgressMaxAggregateOutputType = {
    id: string | null
    syncType: string | null
    startTime: Date | null
    endTime: Date | null
    status: string | null
    totalOrders: number | null
    processedOrders: number | null
    failedOrders: number | null
    lastProcessedOrderId: string | null
    lastProcessedTimestamp: Date | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SyncProgressCountAggregateOutputType = {
    id: number
    syncType: number
    startTime: number
    endTime: number
    status: number
    totalOrders: number
    processedOrders: number
    failedOrders: number
    lastProcessedOrderId: number
    lastProcessedTimestamp: number
    error: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SyncProgressAvgAggregateInputType = {
    totalOrders?: true
    processedOrders?: true
    failedOrders?: true
  }

  export type SyncProgressSumAggregateInputType = {
    totalOrders?: true
    processedOrders?: true
    failedOrders?: true
  }

  export type SyncProgressMinAggregateInputType = {
    id?: true
    syncType?: true
    startTime?: true
    endTime?: true
    status?: true
    totalOrders?: true
    processedOrders?: true
    failedOrders?: true
    lastProcessedOrderId?: true
    lastProcessedTimestamp?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SyncProgressMaxAggregateInputType = {
    id?: true
    syncType?: true
    startTime?: true
    endTime?: true
    status?: true
    totalOrders?: true
    processedOrders?: true
    failedOrders?: true
    lastProcessedOrderId?: true
    lastProcessedTimestamp?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SyncProgressCountAggregateInputType = {
    id?: true
    syncType?: true
    startTime?: true
    endTime?: true
    status?: true
    totalOrders?: true
    processedOrders?: true
    failedOrders?: true
    lastProcessedOrderId?: true
    lastProcessedTimestamp?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SyncProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncProgress to aggregate.
     */
    where?: SyncProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncProgresses to fetch.
     */
    orderBy?: SyncProgressOrderByWithRelationInput | SyncProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncProgresses
    **/
    _count?: true | SyncProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyncProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyncProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncProgressMaxAggregateInputType
  }

  export type GetSyncProgressAggregateType<T extends SyncProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncProgress[P]>
      : GetScalarType<T[P], AggregateSyncProgress[P]>
  }




  export type SyncProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncProgressWhereInput
    orderBy?: SyncProgressOrderByWithAggregationInput | SyncProgressOrderByWithAggregationInput[]
    by: SyncProgressScalarFieldEnum[] | SyncProgressScalarFieldEnum
    having?: SyncProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncProgressCountAggregateInputType | true
    _avg?: SyncProgressAvgAggregateInputType
    _sum?: SyncProgressSumAggregateInputType
    _min?: SyncProgressMinAggregateInputType
    _max?: SyncProgressMaxAggregateInputType
  }

  export type SyncProgressGroupByOutputType = {
    id: string
    syncType: string
    startTime: Date
    endTime: Date | null
    status: string
    totalOrders: number
    processedOrders: number
    failedOrders: number
    lastProcessedOrderId: string | null
    lastProcessedTimestamp: Date | null
    error: string | null
    createdAt: Date
    updatedAt: Date
    _count: SyncProgressCountAggregateOutputType | null
    _avg: SyncProgressAvgAggregateOutputType | null
    _sum: SyncProgressSumAggregateOutputType | null
    _min: SyncProgressMinAggregateOutputType | null
    _max: SyncProgressMaxAggregateOutputType | null
  }

  type GetSyncProgressGroupByPayload<T extends SyncProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncProgressGroupByOutputType[P]>
            : GetScalarType<T[P], SyncProgressGroupByOutputType[P]>
        }
      >
    >


  export type SyncProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syncType?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    totalOrders?: boolean
    processedOrders?: boolean
    failedOrders?: boolean
    lastProcessedOrderId?: boolean
    lastProcessedTimestamp?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["syncProgress"]>



  export type SyncProgressSelectScalar = {
    id?: boolean
    syncType?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    totalOrders?: boolean
    processedOrders?: boolean
    failedOrders?: boolean
    lastProcessedOrderId?: boolean
    lastProcessedTimestamp?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SyncProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "syncType" | "startTime" | "endTime" | "status" | "totalOrders" | "processedOrders" | "failedOrders" | "lastProcessedOrderId" | "lastProcessedTimestamp" | "error" | "createdAt" | "updatedAt", ExtArgs["result"]["syncProgress"]>

  export type $SyncProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncProgress"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      syncType: string
      startTime: Date
      endTime: Date | null
      status: string
      totalOrders: number
      processedOrders: number
      failedOrders: number
      lastProcessedOrderId: string | null
      lastProcessedTimestamp: Date | null
      error: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["syncProgress"]>
    composites: {}
  }

  type SyncProgressGetPayload<S extends boolean | null | undefined | SyncProgressDefaultArgs> = $Result.GetResult<Prisma.$SyncProgressPayload, S>

  type SyncProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SyncProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SyncProgressCountAggregateInputType | true
    }

  export interface SyncProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncProgress'], meta: { name: 'SyncProgress' } }
    /**
     * Find zero or one SyncProgress that matches the filter.
     * @param {SyncProgressFindUniqueArgs} args - Arguments to find a SyncProgress
     * @example
     * // Get one SyncProgress
     * const syncProgress = await prisma.syncProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncProgressFindUniqueArgs>(args: SelectSubset<T, SyncProgressFindUniqueArgs<ExtArgs>>): Prisma__SyncProgressClient<$Result.GetResult<Prisma.$SyncProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SyncProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SyncProgressFindUniqueOrThrowArgs} args - Arguments to find a SyncProgress
     * @example
     * // Get one SyncProgress
     * const syncProgress = await prisma.syncProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncProgressClient<$Result.GetResult<Prisma.$SyncProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncProgressFindFirstArgs} args - Arguments to find a SyncProgress
     * @example
     * // Get one SyncProgress
     * const syncProgress = await prisma.syncProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncProgressFindFirstArgs>(args?: SelectSubset<T, SyncProgressFindFirstArgs<ExtArgs>>): Prisma__SyncProgressClient<$Result.GetResult<Prisma.$SyncProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncProgressFindFirstOrThrowArgs} args - Arguments to find a SyncProgress
     * @example
     * // Get one SyncProgress
     * const syncProgress = await prisma.syncProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncProgressClient<$Result.GetResult<Prisma.$SyncProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SyncProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncProgresses
     * const syncProgresses = await prisma.syncProgress.findMany()
     * 
     * // Get first 10 SyncProgresses
     * const syncProgresses = await prisma.syncProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncProgressWithIdOnly = await prisma.syncProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncProgressFindManyArgs>(args?: SelectSubset<T, SyncProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SyncProgress.
     * @param {SyncProgressCreateArgs} args - Arguments to create a SyncProgress.
     * @example
     * // Create one SyncProgress
     * const SyncProgress = await prisma.syncProgress.create({
     *   data: {
     *     // ... data to create a SyncProgress
     *   }
     * })
     * 
     */
    create<T extends SyncProgressCreateArgs>(args: SelectSubset<T, SyncProgressCreateArgs<ExtArgs>>): Prisma__SyncProgressClient<$Result.GetResult<Prisma.$SyncProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SyncProgresses.
     * @param {SyncProgressCreateManyArgs} args - Arguments to create many SyncProgresses.
     * @example
     * // Create many SyncProgresses
     * const syncProgress = await prisma.syncProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncProgressCreateManyArgs>(args?: SelectSubset<T, SyncProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SyncProgress.
     * @param {SyncProgressDeleteArgs} args - Arguments to delete one SyncProgress.
     * @example
     * // Delete one SyncProgress
     * const SyncProgress = await prisma.syncProgress.delete({
     *   where: {
     *     // ... filter to delete one SyncProgress
     *   }
     * })
     * 
     */
    delete<T extends SyncProgressDeleteArgs>(args: SelectSubset<T, SyncProgressDeleteArgs<ExtArgs>>): Prisma__SyncProgressClient<$Result.GetResult<Prisma.$SyncProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SyncProgress.
     * @param {SyncProgressUpdateArgs} args - Arguments to update one SyncProgress.
     * @example
     * // Update one SyncProgress
     * const syncProgress = await prisma.syncProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncProgressUpdateArgs>(args: SelectSubset<T, SyncProgressUpdateArgs<ExtArgs>>): Prisma__SyncProgressClient<$Result.GetResult<Prisma.$SyncProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SyncProgresses.
     * @param {SyncProgressDeleteManyArgs} args - Arguments to filter SyncProgresses to delete.
     * @example
     * // Delete a few SyncProgresses
     * const { count } = await prisma.syncProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncProgressDeleteManyArgs>(args?: SelectSubset<T, SyncProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncProgresses
     * const syncProgress = await prisma.syncProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncProgressUpdateManyArgs>(args: SelectSubset<T, SyncProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SyncProgress.
     * @param {SyncProgressUpsertArgs} args - Arguments to update or create a SyncProgress.
     * @example
     * // Update or create a SyncProgress
     * const syncProgress = await prisma.syncProgress.upsert({
     *   create: {
     *     // ... data to create a SyncProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncProgress we want to update
     *   }
     * })
     */
    upsert<T extends SyncProgressUpsertArgs>(args: SelectSubset<T, SyncProgressUpsertArgs<ExtArgs>>): Prisma__SyncProgressClient<$Result.GetResult<Prisma.$SyncProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SyncProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncProgressCountArgs} args - Arguments to filter SyncProgresses to count.
     * @example
     * // Count the number of SyncProgresses
     * const count = await prisma.syncProgress.count({
     *   where: {
     *     // ... the filter for the SyncProgresses we want to count
     *   }
     * })
    **/
    count<T extends SyncProgressCountArgs>(
      args?: Subset<T, SyncProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncProgressAggregateArgs>(args: Subset<T, SyncProgressAggregateArgs>): Prisma.PrismaPromise<GetSyncProgressAggregateType<T>>

    /**
     * Group by SyncProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncProgressGroupByArgs['orderBy'] }
        : { orderBy?: SyncProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncProgress model
   */
  readonly fields: SyncProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncProgress model
   */
  interface SyncProgressFieldRefs {
    readonly id: FieldRef<"SyncProgress", 'String'>
    readonly syncType: FieldRef<"SyncProgress", 'String'>
    readonly startTime: FieldRef<"SyncProgress", 'DateTime'>
    readonly endTime: FieldRef<"SyncProgress", 'DateTime'>
    readonly status: FieldRef<"SyncProgress", 'String'>
    readonly totalOrders: FieldRef<"SyncProgress", 'Int'>
    readonly processedOrders: FieldRef<"SyncProgress", 'Int'>
    readonly failedOrders: FieldRef<"SyncProgress", 'Int'>
    readonly lastProcessedOrderId: FieldRef<"SyncProgress", 'String'>
    readonly lastProcessedTimestamp: FieldRef<"SyncProgress", 'DateTime'>
    readonly error: FieldRef<"SyncProgress", 'String'>
    readonly createdAt: FieldRef<"SyncProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"SyncProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SyncProgress findUnique
   */
  export type SyncProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncProgress
     */
    select?: SyncProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncProgress
     */
    omit?: SyncProgressOmit<ExtArgs> | null
    /**
     * Filter, which SyncProgress to fetch.
     */
    where: SyncProgressWhereUniqueInput
  }

  /**
   * SyncProgress findUniqueOrThrow
   */
  export type SyncProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncProgress
     */
    select?: SyncProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncProgress
     */
    omit?: SyncProgressOmit<ExtArgs> | null
    /**
     * Filter, which SyncProgress to fetch.
     */
    where: SyncProgressWhereUniqueInput
  }

  /**
   * SyncProgress findFirst
   */
  export type SyncProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncProgress
     */
    select?: SyncProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncProgress
     */
    omit?: SyncProgressOmit<ExtArgs> | null
    /**
     * Filter, which SyncProgress to fetch.
     */
    where?: SyncProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncProgresses to fetch.
     */
    orderBy?: SyncProgressOrderByWithRelationInput | SyncProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncProgresses.
     */
    cursor?: SyncProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncProgresses.
     */
    distinct?: SyncProgressScalarFieldEnum | SyncProgressScalarFieldEnum[]
  }

  /**
   * SyncProgress findFirstOrThrow
   */
  export type SyncProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncProgress
     */
    select?: SyncProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncProgress
     */
    omit?: SyncProgressOmit<ExtArgs> | null
    /**
     * Filter, which SyncProgress to fetch.
     */
    where?: SyncProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncProgresses to fetch.
     */
    orderBy?: SyncProgressOrderByWithRelationInput | SyncProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncProgresses.
     */
    cursor?: SyncProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncProgresses.
     */
    distinct?: SyncProgressScalarFieldEnum | SyncProgressScalarFieldEnum[]
  }

  /**
   * SyncProgress findMany
   */
  export type SyncProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncProgress
     */
    select?: SyncProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncProgress
     */
    omit?: SyncProgressOmit<ExtArgs> | null
    /**
     * Filter, which SyncProgresses to fetch.
     */
    where?: SyncProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncProgresses to fetch.
     */
    orderBy?: SyncProgressOrderByWithRelationInput | SyncProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncProgresses.
     */
    cursor?: SyncProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncProgresses.
     */
    skip?: number
    distinct?: SyncProgressScalarFieldEnum | SyncProgressScalarFieldEnum[]
  }

  /**
   * SyncProgress create
   */
  export type SyncProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncProgress
     */
    select?: SyncProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncProgress
     */
    omit?: SyncProgressOmit<ExtArgs> | null
    /**
     * The data needed to create a SyncProgress.
     */
    data: XOR<SyncProgressCreateInput, SyncProgressUncheckedCreateInput>
  }

  /**
   * SyncProgress createMany
   */
  export type SyncProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncProgresses.
     */
    data: SyncProgressCreateManyInput | SyncProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyncProgress update
   */
  export type SyncProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncProgress
     */
    select?: SyncProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncProgress
     */
    omit?: SyncProgressOmit<ExtArgs> | null
    /**
     * The data needed to update a SyncProgress.
     */
    data: XOR<SyncProgressUpdateInput, SyncProgressUncheckedUpdateInput>
    /**
     * Choose, which SyncProgress to update.
     */
    where: SyncProgressWhereUniqueInput
  }

  /**
   * SyncProgress updateMany
   */
  export type SyncProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncProgresses.
     */
    data: XOR<SyncProgressUpdateManyMutationInput, SyncProgressUncheckedUpdateManyInput>
    /**
     * Filter which SyncProgresses to update
     */
    where?: SyncProgressWhereInput
    /**
     * Limit how many SyncProgresses to update.
     */
    limit?: number
  }

  /**
   * SyncProgress upsert
   */
  export type SyncProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncProgress
     */
    select?: SyncProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncProgress
     */
    omit?: SyncProgressOmit<ExtArgs> | null
    /**
     * The filter to search for the SyncProgress to update in case it exists.
     */
    where: SyncProgressWhereUniqueInput
    /**
     * In case the SyncProgress found by the `where` argument doesn't exist, create a new SyncProgress with this data.
     */
    create: XOR<SyncProgressCreateInput, SyncProgressUncheckedCreateInput>
    /**
     * In case the SyncProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncProgressUpdateInput, SyncProgressUncheckedUpdateInput>
  }

  /**
   * SyncProgress delete
   */
  export type SyncProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncProgress
     */
    select?: SyncProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncProgress
     */
    omit?: SyncProgressOmit<ExtArgs> | null
    /**
     * Filter which SyncProgress to delete.
     */
    where: SyncProgressWhereUniqueInput
  }

  /**
   * SyncProgress deleteMany
   */
  export type SyncProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncProgresses to delete
     */
    where?: SyncProgressWhereInput
    /**
     * Limit how many SyncProgresses to delete.
     */
    limit?: number
  }

  /**
   * SyncProgress without action
   */
  export type SyncProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncProgress
     */
    select?: SyncProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncProgress
     */
    omit?: SyncProgressOmit<ExtArgs> | null
  }


  /**
   * Model SyncMetrics
   */

  export type AggregateSyncMetrics = {
    _count: SyncMetricsCountAggregateOutputType | null
    _avg: SyncMetricsAvgAggregateOutputType | null
    _sum: SyncMetricsSumAggregateOutputType | null
    _min: SyncMetricsMinAggregateOutputType | null
    _max: SyncMetricsMaxAggregateOutputType | null
  }

  export type SyncMetricsAvgAggregateOutputType = {
    totalApiCalls: number | null
    totalOrdersProcessed: number | null
    totalOrdersFailed: number | null
    totalItemsProcessed: number | null
    totalItemsFailed: number | null
    totalCustomersUpserted: number | null
    totalProductsUpserted: number | null
    avgProcessingTimePerOrder: number | null
    maxProcessingTimePerOrder: number | null
    minProcessingTimePerOrder: number | null
    totalProcessingTime: number | null
  }

  export type SyncMetricsSumAggregateOutputType = {
    totalApiCalls: number | null
    totalOrdersProcessed: number | null
    totalOrdersFailed: number | null
    totalItemsProcessed: number | null
    totalItemsFailed: number | null
    totalCustomersUpserted: number | null
    totalProductsUpserted: number | null
    avgProcessingTimePerOrder: number | null
    maxProcessingTimePerOrder: number | null
    minProcessingTimePerOrder: number | null
    totalProcessingTime: number | null
  }

  export type SyncMetricsMinAggregateOutputType = {
    id: string | null
    syncId: string | null
    totalApiCalls: number | null
    totalOrdersProcessed: number | null
    totalOrdersFailed: number | null
    totalItemsProcessed: number | null
    totalItemsFailed: number | null
    totalCustomersUpserted: number | null
    totalProductsUpserted: number | null
    avgProcessingTimePerOrder: number | null
    maxProcessingTimePerOrder: number | null
    minProcessingTimePerOrder: number | null
    totalProcessingTime: number | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
  }

  export type SyncMetricsMaxAggregateOutputType = {
    id: string | null
    syncId: string | null
    totalApiCalls: number | null
    totalOrdersProcessed: number | null
    totalOrdersFailed: number | null
    totalItemsProcessed: number | null
    totalItemsFailed: number | null
    totalCustomersUpserted: number | null
    totalProductsUpserted: number | null
    avgProcessingTimePerOrder: number | null
    maxProcessingTimePerOrder: number | null
    minProcessingTimePerOrder: number | null
    totalProcessingTime: number | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
  }

  export type SyncMetricsCountAggregateOutputType = {
    id: number
    syncId: number
    totalApiCalls: number
    totalOrdersProcessed: number
    totalOrdersFailed: number
    totalItemsProcessed: number
    totalItemsFailed: number
    totalCustomersUpserted: number
    totalProductsUpserted: number
    avgProcessingTimePerOrder: number
    maxProcessingTimePerOrder: number
    minProcessingTimePerOrder: number
    totalProcessingTime: number
    startTime: number
    endTime: number
    createdAt: number
    _all: number
  }


  export type SyncMetricsAvgAggregateInputType = {
    totalApiCalls?: true
    totalOrdersProcessed?: true
    totalOrdersFailed?: true
    totalItemsProcessed?: true
    totalItemsFailed?: true
    totalCustomersUpserted?: true
    totalProductsUpserted?: true
    avgProcessingTimePerOrder?: true
    maxProcessingTimePerOrder?: true
    minProcessingTimePerOrder?: true
    totalProcessingTime?: true
  }

  export type SyncMetricsSumAggregateInputType = {
    totalApiCalls?: true
    totalOrdersProcessed?: true
    totalOrdersFailed?: true
    totalItemsProcessed?: true
    totalItemsFailed?: true
    totalCustomersUpserted?: true
    totalProductsUpserted?: true
    avgProcessingTimePerOrder?: true
    maxProcessingTimePerOrder?: true
    minProcessingTimePerOrder?: true
    totalProcessingTime?: true
  }

  export type SyncMetricsMinAggregateInputType = {
    id?: true
    syncId?: true
    totalApiCalls?: true
    totalOrdersProcessed?: true
    totalOrdersFailed?: true
    totalItemsProcessed?: true
    totalItemsFailed?: true
    totalCustomersUpserted?: true
    totalProductsUpserted?: true
    avgProcessingTimePerOrder?: true
    maxProcessingTimePerOrder?: true
    minProcessingTimePerOrder?: true
    totalProcessingTime?: true
    startTime?: true
    endTime?: true
    createdAt?: true
  }

  export type SyncMetricsMaxAggregateInputType = {
    id?: true
    syncId?: true
    totalApiCalls?: true
    totalOrdersProcessed?: true
    totalOrdersFailed?: true
    totalItemsProcessed?: true
    totalItemsFailed?: true
    totalCustomersUpserted?: true
    totalProductsUpserted?: true
    avgProcessingTimePerOrder?: true
    maxProcessingTimePerOrder?: true
    minProcessingTimePerOrder?: true
    totalProcessingTime?: true
    startTime?: true
    endTime?: true
    createdAt?: true
  }

  export type SyncMetricsCountAggregateInputType = {
    id?: true
    syncId?: true
    totalApiCalls?: true
    totalOrdersProcessed?: true
    totalOrdersFailed?: true
    totalItemsProcessed?: true
    totalItemsFailed?: true
    totalCustomersUpserted?: true
    totalProductsUpserted?: true
    avgProcessingTimePerOrder?: true
    maxProcessingTimePerOrder?: true
    minProcessingTimePerOrder?: true
    totalProcessingTime?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    _all?: true
  }

  export type SyncMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncMetrics to aggregate.
     */
    where?: SyncMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncMetrics to fetch.
     */
    orderBy?: SyncMetricsOrderByWithRelationInput | SyncMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncMetrics
    **/
    _count?: true | SyncMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyncMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyncMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncMetricsMaxAggregateInputType
  }

  export type GetSyncMetricsAggregateType<T extends SyncMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncMetrics[P]>
      : GetScalarType<T[P], AggregateSyncMetrics[P]>
  }




  export type SyncMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncMetricsWhereInput
    orderBy?: SyncMetricsOrderByWithAggregationInput | SyncMetricsOrderByWithAggregationInput[]
    by: SyncMetricsScalarFieldEnum[] | SyncMetricsScalarFieldEnum
    having?: SyncMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncMetricsCountAggregateInputType | true
    _avg?: SyncMetricsAvgAggregateInputType
    _sum?: SyncMetricsSumAggregateInputType
    _min?: SyncMetricsMinAggregateInputType
    _max?: SyncMetricsMaxAggregateInputType
  }

  export type SyncMetricsGroupByOutputType = {
    id: string
    syncId: string
    totalApiCalls: number
    totalOrdersProcessed: number
    totalOrdersFailed: number
    totalItemsProcessed: number
    totalItemsFailed: number
    totalCustomersUpserted: number
    totalProductsUpserted: number
    avgProcessingTimePerOrder: number
    maxProcessingTimePerOrder: number
    minProcessingTimePerOrder: number
    totalProcessingTime: number
    startTime: Date
    endTime: Date | null
    createdAt: Date
    _count: SyncMetricsCountAggregateOutputType | null
    _avg: SyncMetricsAvgAggregateOutputType | null
    _sum: SyncMetricsSumAggregateOutputType | null
    _min: SyncMetricsMinAggregateOutputType | null
    _max: SyncMetricsMaxAggregateOutputType | null
  }

  type GetSyncMetricsGroupByPayload<T extends SyncMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], SyncMetricsGroupByOutputType[P]>
        }
      >
    >


  export type SyncMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syncId?: boolean
    totalApiCalls?: boolean
    totalOrdersProcessed?: boolean
    totalOrdersFailed?: boolean
    totalItemsProcessed?: boolean
    totalItemsFailed?: boolean
    totalCustomersUpserted?: boolean
    totalProductsUpserted?: boolean
    avgProcessingTimePerOrder?: boolean
    maxProcessingTimePerOrder?: boolean
    minProcessingTimePerOrder?: boolean
    totalProcessingTime?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["syncMetrics"]>



  export type SyncMetricsSelectScalar = {
    id?: boolean
    syncId?: boolean
    totalApiCalls?: boolean
    totalOrdersProcessed?: boolean
    totalOrdersFailed?: boolean
    totalItemsProcessed?: boolean
    totalItemsFailed?: boolean
    totalCustomersUpserted?: boolean
    totalProductsUpserted?: boolean
    avgProcessingTimePerOrder?: boolean
    maxProcessingTimePerOrder?: boolean
    minProcessingTimePerOrder?: boolean
    totalProcessingTime?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
  }

  export type SyncMetricsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "syncId" | "totalApiCalls" | "totalOrdersProcessed" | "totalOrdersFailed" | "totalItemsProcessed" | "totalItemsFailed" | "totalCustomersUpserted" | "totalProductsUpserted" | "avgProcessingTimePerOrder" | "maxProcessingTimePerOrder" | "minProcessingTimePerOrder" | "totalProcessingTime" | "startTime" | "endTime" | "createdAt", ExtArgs["result"]["syncMetrics"]>

  export type $SyncMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncMetrics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      syncId: string
      totalApiCalls: number
      totalOrdersProcessed: number
      totalOrdersFailed: number
      totalItemsProcessed: number
      totalItemsFailed: number
      totalCustomersUpserted: number
      totalProductsUpserted: number
      avgProcessingTimePerOrder: number
      maxProcessingTimePerOrder: number
      minProcessingTimePerOrder: number
      totalProcessingTime: number
      startTime: Date
      endTime: Date | null
      createdAt: Date
    }, ExtArgs["result"]["syncMetrics"]>
    composites: {}
  }

  type SyncMetricsGetPayload<S extends boolean | null | undefined | SyncMetricsDefaultArgs> = $Result.GetResult<Prisma.$SyncMetricsPayload, S>

  type SyncMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SyncMetricsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SyncMetricsCountAggregateInputType | true
    }

  export interface SyncMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncMetrics'], meta: { name: 'SyncMetrics' } }
    /**
     * Find zero or one SyncMetrics that matches the filter.
     * @param {SyncMetricsFindUniqueArgs} args - Arguments to find a SyncMetrics
     * @example
     * // Get one SyncMetrics
     * const syncMetrics = await prisma.syncMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncMetricsFindUniqueArgs>(args: SelectSubset<T, SyncMetricsFindUniqueArgs<ExtArgs>>): Prisma__SyncMetricsClient<$Result.GetResult<Prisma.$SyncMetricsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SyncMetrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SyncMetricsFindUniqueOrThrowArgs} args - Arguments to find a SyncMetrics
     * @example
     * // Get one SyncMetrics
     * const syncMetrics = await prisma.syncMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncMetricsClient<$Result.GetResult<Prisma.$SyncMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncMetricsFindFirstArgs} args - Arguments to find a SyncMetrics
     * @example
     * // Get one SyncMetrics
     * const syncMetrics = await prisma.syncMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncMetricsFindFirstArgs>(args?: SelectSubset<T, SyncMetricsFindFirstArgs<ExtArgs>>): Prisma__SyncMetricsClient<$Result.GetResult<Prisma.$SyncMetricsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncMetricsFindFirstOrThrowArgs} args - Arguments to find a SyncMetrics
     * @example
     * // Get one SyncMetrics
     * const syncMetrics = await prisma.syncMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncMetricsClient<$Result.GetResult<Prisma.$SyncMetricsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SyncMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncMetrics
     * const syncMetrics = await prisma.syncMetrics.findMany()
     * 
     * // Get first 10 SyncMetrics
     * const syncMetrics = await prisma.syncMetrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncMetricsWithIdOnly = await prisma.syncMetrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncMetricsFindManyArgs>(args?: SelectSubset<T, SyncMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SyncMetrics.
     * @param {SyncMetricsCreateArgs} args - Arguments to create a SyncMetrics.
     * @example
     * // Create one SyncMetrics
     * const SyncMetrics = await prisma.syncMetrics.create({
     *   data: {
     *     // ... data to create a SyncMetrics
     *   }
     * })
     * 
     */
    create<T extends SyncMetricsCreateArgs>(args: SelectSubset<T, SyncMetricsCreateArgs<ExtArgs>>): Prisma__SyncMetricsClient<$Result.GetResult<Prisma.$SyncMetricsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SyncMetrics.
     * @param {SyncMetricsCreateManyArgs} args - Arguments to create many SyncMetrics.
     * @example
     * // Create many SyncMetrics
     * const syncMetrics = await prisma.syncMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncMetricsCreateManyArgs>(args?: SelectSubset<T, SyncMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SyncMetrics.
     * @param {SyncMetricsDeleteArgs} args - Arguments to delete one SyncMetrics.
     * @example
     * // Delete one SyncMetrics
     * const SyncMetrics = await prisma.syncMetrics.delete({
     *   where: {
     *     // ... filter to delete one SyncMetrics
     *   }
     * })
     * 
     */
    delete<T extends SyncMetricsDeleteArgs>(args: SelectSubset<T, SyncMetricsDeleteArgs<ExtArgs>>): Prisma__SyncMetricsClient<$Result.GetResult<Prisma.$SyncMetricsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SyncMetrics.
     * @param {SyncMetricsUpdateArgs} args - Arguments to update one SyncMetrics.
     * @example
     * // Update one SyncMetrics
     * const syncMetrics = await prisma.syncMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncMetricsUpdateArgs>(args: SelectSubset<T, SyncMetricsUpdateArgs<ExtArgs>>): Prisma__SyncMetricsClient<$Result.GetResult<Prisma.$SyncMetricsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SyncMetrics.
     * @param {SyncMetricsDeleteManyArgs} args - Arguments to filter SyncMetrics to delete.
     * @example
     * // Delete a few SyncMetrics
     * const { count } = await prisma.syncMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncMetricsDeleteManyArgs>(args?: SelectSubset<T, SyncMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncMetrics
     * const syncMetrics = await prisma.syncMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncMetricsUpdateManyArgs>(args: SelectSubset<T, SyncMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SyncMetrics.
     * @param {SyncMetricsUpsertArgs} args - Arguments to update or create a SyncMetrics.
     * @example
     * // Update or create a SyncMetrics
     * const syncMetrics = await prisma.syncMetrics.upsert({
     *   create: {
     *     // ... data to create a SyncMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncMetrics we want to update
     *   }
     * })
     */
    upsert<T extends SyncMetricsUpsertArgs>(args: SelectSubset<T, SyncMetricsUpsertArgs<ExtArgs>>): Prisma__SyncMetricsClient<$Result.GetResult<Prisma.$SyncMetricsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SyncMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncMetricsCountArgs} args - Arguments to filter SyncMetrics to count.
     * @example
     * // Count the number of SyncMetrics
     * const count = await prisma.syncMetrics.count({
     *   where: {
     *     // ... the filter for the SyncMetrics we want to count
     *   }
     * })
    **/
    count<T extends SyncMetricsCountArgs>(
      args?: Subset<T, SyncMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncMetricsAggregateArgs>(args: Subset<T, SyncMetricsAggregateArgs>): Prisma.PrismaPromise<GetSyncMetricsAggregateType<T>>

    /**
     * Group by SyncMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncMetricsGroupByArgs['orderBy'] }
        : { orderBy?: SyncMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncMetrics model
   */
  readonly fields: SyncMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncMetrics model
   */
  interface SyncMetricsFieldRefs {
    readonly id: FieldRef<"SyncMetrics", 'String'>
    readonly syncId: FieldRef<"SyncMetrics", 'String'>
    readonly totalApiCalls: FieldRef<"SyncMetrics", 'Int'>
    readonly totalOrdersProcessed: FieldRef<"SyncMetrics", 'Int'>
    readonly totalOrdersFailed: FieldRef<"SyncMetrics", 'Int'>
    readonly totalItemsProcessed: FieldRef<"SyncMetrics", 'Int'>
    readonly totalItemsFailed: FieldRef<"SyncMetrics", 'Int'>
    readonly totalCustomersUpserted: FieldRef<"SyncMetrics", 'Int'>
    readonly totalProductsUpserted: FieldRef<"SyncMetrics", 'Int'>
    readonly avgProcessingTimePerOrder: FieldRef<"SyncMetrics", 'Int'>
    readonly maxProcessingTimePerOrder: FieldRef<"SyncMetrics", 'Int'>
    readonly minProcessingTimePerOrder: FieldRef<"SyncMetrics", 'Int'>
    readonly totalProcessingTime: FieldRef<"SyncMetrics", 'Int'>
    readonly startTime: FieldRef<"SyncMetrics", 'DateTime'>
    readonly endTime: FieldRef<"SyncMetrics", 'DateTime'>
    readonly createdAt: FieldRef<"SyncMetrics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SyncMetrics findUnique
   */
  export type SyncMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncMetrics
     */
    select?: SyncMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncMetrics
     */
    omit?: SyncMetricsOmit<ExtArgs> | null
    /**
     * Filter, which SyncMetrics to fetch.
     */
    where: SyncMetricsWhereUniqueInput
  }

  /**
   * SyncMetrics findUniqueOrThrow
   */
  export type SyncMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncMetrics
     */
    select?: SyncMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncMetrics
     */
    omit?: SyncMetricsOmit<ExtArgs> | null
    /**
     * Filter, which SyncMetrics to fetch.
     */
    where: SyncMetricsWhereUniqueInput
  }

  /**
   * SyncMetrics findFirst
   */
  export type SyncMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncMetrics
     */
    select?: SyncMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncMetrics
     */
    omit?: SyncMetricsOmit<ExtArgs> | null
    /**
     * Filter, which SyncMetrics to fetch.
     */
    where?: SyncMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncMetrics to fetch.
     */
    orderBy?: SyncMetricsOrderByWithRelationInput | SyncMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncMetrics.
     */
    cursor?: SyncMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncMetrics.
     */
    distinct?: SyncMetricsScalarFieldEnum | SyncMetricsScalarFieldEnum[]
  }

  /**
   * SyncMetrics findFirstOrThrow
   */
  export type SyncMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncMetrics
     */
    select?: SyncMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncMetrics
     */
    omit?: SyncMetricsOmit<ExtArgs> | null
    /**
     * Filter, which SyncMetrics to fetch.
     */
    where?: SyncMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncMetrics to fetch.
     */
    orderBy?: SyncMetricsOrderByWithRelationInput | SyncMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncMetrics.
     */
    cursor?: SyncMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncMetrics.
     */
    distinct?: SyncMetricsScalarFieldEnum | SyncMetricsScalarFieldEnum[]
  }

  /**
   * SyncMetrics findMany
   */
  export type SyncMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncMetrics
     */
    select?: SyncMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncMetrics
     */
    omit?: SyncMetricsOmit<ExtArgs> | null
    /**
     * Filter, which SyncMetrics to fetch.
     */
    where?: SyncMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncMetrics to fetch.
     */
    orderBy?: SyncMetricsOrderByWithRelationInput | SyncMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncMetrics.
     */
    cursor?: SyncMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncMetrics.
     */
    skip?: number
    distinct?: SyncMetricsScalarFieldEnum | SyncMetricsScalarFieldEnum[]
  }

  /**
   * SyncMetrics create
   */
  export type SyncMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncMetrics
     */
    select?: SyncMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncMetrics
     */
    omit?: SyncMetricsOmit<ExtArgs> | null
    /**
     * The data needed to create a SyncMetrics.
     */
    data: XOR<SyncMetricsCreateInput, SyncMetricsUncheckedCreateInput>
  }

  /**
   * SyncMetrics createMany
   */
  export type SyncMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncMetrics.
     */
    data: SyncMetricsCreateManyInput | SyncMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyncMetrics update
   */
  export type SyncMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncMetrics
     */
    select?: SyncMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncMetrics
     */
    omit?: SyncMetricsOmit<ExtArgs> | null
    /**
     * The data needed to update a SyncMetrics.
     */
    data: XOR<SyncMetricsUpdateInput, SyncMetricsUncheckedUpdateInput>
    /**
     * Choose, which SyncMetrics to update.
     */
    where: SyncMetricsWhereUniqueInput
  }

  /**
   * SyncMetrics updateMany
   */
  export type SyncMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncMetrics.
     */
    data: XOR<SyncMetricsUpdateManyMutationInput, SyncMetricsUncheckedUpdateManyInput>
    /**
     * Filter which SyncMetrics to update
     */
    where?: SyncMetricsWhereInput
    /**
     * Limit how many SyncMetrics to update.
     */
    limit?: number
  }

  /**
   * SyncMetrics upsert
   */
  export type SyncMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncMetrics
     */
    select?: SyncMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncMetrics
     */
    omit?: SyncMetricsOmit<ExtArgs> | null
    /**
     * The filter to search for the SyncMetrics to update in case it exists.
     */
    where: SyncMetricsWhereUniqueInput
    /**
     * In case the SyncMetrics found by the `where` argument doesn't exist, create a new SyncMetrics with this data.
     */
    create: XOR<SyncMetricsCreateInput, SyncMetricsUncheckedCreateInput>
    /**
     * In case the SyncMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncMetricsUpdateInput, SyncMetricsUncheckedUpdateInput>
  }

  /**
   * SyncMetrics delete
   */
  export type SyncMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncMetrics
     */
    select?: SyncMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncMetrics
     */
    omit?: SyncMetricsOmit<ExtArgs> | null
    /**
     * Filter which SyncMetrics to delete.
     */
    where: SyncMetricsWhereUniqueInput
  }

  /**
   * SyncMetrics deleteMany
   */
  export type SyncMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncMetrics to delete
     */
    where?: SyncMetricsWhereInput
    /**
     * Limit how many SyncMetrics to delete.
     */
    limit?: number
  }

  /**
   * SyncMetrics without action
   */
  export type SyncMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncMetrics
     */
    select?: SyncMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncMetrics
     */
    omit?: SyncMetricsOmit<ExtArgs> | null
  }


  /**
   * Model AiCallLog
   */

  export type AggregateAiCallLog = {
    _count: AiCallLogCountAggregateOutputType | null
    _avg: AiCallLogAvgAggregateOutputType | null
    _sum: AiCallLogSumAggregateOutputType | null
    _min: AiCallLogMinAggregateOutputType | null
    _max: AiCallLogMaxAggregateOutputType | null
  }

  export type AiCallLogAvgAggregateOutputType = {
    orderId: number | null
    processingTimeMs: number | null
    tasksGenerated: number | null
    needsReviewCount: number | null
  }

  export type AiCallLogSumAggregateOutputType = {
    orderId: number | null
    processingTimeMs: number | null
    tasksGenerated: number | null
    needsReviewCount: number | null
  }

  export type AiCallLogMinAggregateOutputType = {
    id: string | null
    scriptName: string | null
    orderId: number | null
    orderNumber: string | null
    marketplace: string | null
    aiProvider: string | null
    modelUsed: string | null
    promptSent: string | null
    rawResponse: string | null
    processingTimeMs: number | null
    success: boolean | null
    errorMessage: string | null
    tasksGenerated: number | null
    needsReviewCount: number | null
    createdAt: Date | null
  }

  export type AiCallLogMaxAggregateOutputType = {
    id: string | null
    scriptName: string | null
    orderId: number | null
    orderNumber: string | null
    marketplace: string | null
    aiProvider: string | null
    modelUsed: string | null
    promptSent: string | null
    rawResponse: string | null
    processingTimeMs: number | null
    success: boolean | null
    errorMessage: string | null
    tasksGenerated: number | null
    needsReviewCount: number | null
    createdAt: Date | null
  }

  export type AiCallLogCountAggregateOutputType = {
    id: number
    scriptName: number
    orderId: number
    orderNumber: number
    marketplace: number
    aiProvider: number
    modelUsed: number
    promptSent: number
    rawResponse: number
    processingTimeMs: number
    success: number
    errorMessage: number
    tasksGenerated: number
    needsReviewCount: number
    createdAt: number
    _all: number
  }


  export type AiCallLogAvgAggregateInputType = {
    orderId?: true
    processingTimeMs?: true
    tasksGenerated?: true
    needsReviewCount?: true
  }

  export type AiCallLogSumAggregateInputType = {
    orderId?: true
    processingTimeMs?: true
    tasksGenerated?: true
    needsReviewCount?: true
  }

  export type AiCallLogMinAggregateInputType = {
    id?: true
    scriptName?: true
    orderId?: true
    orderNumber?: true
    marketplace?: true
    aiProvider?: true
    modelUsed?: true
    promptSent?: true
    rawResponse?: true
    processingTimeMs?: true
    success?: true
    errorMessage?: true
    tasksGenerated?: true
    needsReviewCount?: true
    createdAt?: true
  }

  export type AiCallLogMaxAggregateInputType = {
    id?: true
    scriptName?: true
    orderId?: true
    orderNumber?: true
    marketplace?: true
    aiProvider?: true
    modelUsed?: true
    promptSent?: true
    rawResponse?: true
    processingTimeMs?: true
    success?: true
    errorMessage?: true
    tasksGenerated?: true
    needsReviewCount?: true
    createdAt?: true
  }

  export type AiCallLogCountAggregateInputType = {
    id?: true
    scriptName?: true
    orderId?: true
    orderNumber?: true
    marketplace?: true
    aiProvider?: true
    modelUsed?: true
    promptSent?: true
    rawResponse?: true
    processingTimeMs?: true
    success?: true
    errorMessage?: true
    tasksGenerated?: true
    needsReviewCount?: true
    createdAt?: true
    _all?: true
  }

  export type AiCallLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiCallLog to aggregate.
     */
    where?: AiCallLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiCallLogs to fetch.
     */
    orderBy?: AiCallLogOrderByWithRelationInput | AiCallLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiCallLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiCallLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiCallLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiCallLogs
    **/
    _count?: true | AiCallLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiCallLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiCallLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiCallLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiCallLogMaxAggregateInputType
  }

  export type GetAiCallLogAggregateType<T extends AiCallLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAiCallLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiCallLog[P]>
      : GetScalarType<T[P], AggregateAiCallLog[P]>
  }




  export type AiCallLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiCallLogWhereInput
    orderBy?: AiCallLogOrderByWithAggregationInput | AiCallLogOrderByWithAggregationInput[]
    by: AiCallLogScalarFieldEnum[] | AiCallLogScalarFieldEnum
    having?: AiCallLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiCallLogCountAggregateInputType | true
    _avg?: AiCallLogAvgAggregateInputType
    _sum?: AiCallLogSumAggregateInputType
    _min?: AiCallLogMinAggregateInputType
    _max?: AiCallLogMaxAggregateInputType
  }

  export type AiCallLogGroupByOutputType = {
    id: string
    scriptName: string
    orderId: number
    orderNumber: string | null
    marketplace: string | null
    aiProvider: string
    modelUsed: string
    promptSent: string
    rawResponse: string
    processingTimeMs: number
    success: boolean
    errorMessage: string | null
    tasksGenerated: number
    needsReviewCount: number
    createdAt: Date
    _count: AiCallLogCountAggregateOutputType | null
    _avg: AiCallLogAvgAggregateOutputType | null
    _sum: AiCallLogSumAggregateOutputType | null
    _min: AiCallLogMinAggregateOutputType | null
    _max: AiCallLogMaxAggregateOutputType | null
  }

  type GetAiCallLogGroupByPayload<T extends AiCallLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiCallLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiCallLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiCallLogGroupByOutputType[P]>
            : GetScalarType<T[P], AiCallLogGroupByOutputType[P]>
        }
      >
    >


  export type AiCallLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scriptName?: boolean
    orderId?: boolean
    orderNumber?: boolean
    marketplace?: boolean
    aiProvider?: boolean
    modelUsed?: boolean
    promptSent?: boolean
    rawResponse?: boolean
    processingTimeMs?: boolean
    success?: boolean
    errorMessage?: boolean
    tasksGenerated?: boolean
    needsReviewCount?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aiCallLog"]>



  export type AiCallLogSelectScalar = {
    id?: boolean
    scriptName?: boolean
    orderId?: boolean
    orderNumber?: boolean
    marketplace?: boolean
    aiProvider?: boolean
    modelUsed?: boolean
    promptSent?: boolean
    rawResponse?: boolean
    processingTimeMs?: boolean
    success?: boolean
    errorMessage?: boolean
    tasksGenerated?: boolean
    needsReviewCount?: boolean
    createdAt?: boolean
  }

  export type AiCallLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "scriptName" | "orderId" | "orderNumber" | "marketplace" | "aiProvider" | "modelUsed" | "promptSent" | "rawResponse" | "processingTimeMs" | "success" | "errorMessage" | "tasksGenerated" | "needsReviewCount" | "createdAt", ExtArgs["result"]["aiCallLog"]>

  export type $AiCallLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiCallLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      scriptName: string
      orderId: number
      orderNumber: string | null
      marketplace: string | null
      aiProvider: string
      modelUsed: string
      promptSent: string
      rawResponse: string
      processingTimeMs: number
      success: boolean
      errorMessage: string | null
      tasksGenerated: number
      needsReviewCount: number
      createdAt: Date
    }, ExtArgs["result"]["aiCallLog"]>
    composites: {}
  }

  type AiCallLogGetPayload<S extends boolean | null | undefined | AiCallLogDefaultArgs> = $Result.GetResult<Prisma.$AiCallLogPayload, S>

  type AiCallLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiCallLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiCallLogCountAggregateInputType | true
    }

  export interface AiCallLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiCallLog'], meta: { name: 'AiCallLog' } }
    /**
     * Find zero or one AiCallLog that matches the filter.
     * @param {AiCallLogFindUniqueArgs} args - Arguments to find a AiCallLog
     * @example
     * // Get one AiCallLog
     * const aiCallLog = await prisma.aiCallLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiCallLogFindUniqueArgs>(args: SelectSubset<T, AiCallLogFindUniqueArgs<ExtArgs>>): Prisma__AiCallLogClient<$Result.GetResult<Prisma.$AiCallLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiCallLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiCallLogFindUniqueOrThrowArgs} args - Arguments to find a AiCallLog
     * @example
     * // Get one AiCallLog
     * const aiCallLog = await prisma.aiCallLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiCallLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AiCallLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiCallLogClient<$Result.GetResult<Prisma.$AiCallLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiCallLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiCallLogFindFirstArgs} args - Arguments to find a AiCallLog
     * @example
     * // Get one AiCallLog
     * const aiCallLog = await prisma.aiCallLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiCallLogFindFirstArgs>(args?: SelectSubset<T, AiCallLogFindFirstArgs<ExtArgs>>): Prisma__AiCallLogClient<$Result.GetResult<Prisma.$AiCallLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiCallLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiCallLogFindFirstOrThrowArgs} args - Arguments to find a AiCallLog
     * @example
     * // Get one AiCallLog
     * const aiCallLog = await prisma.aiCallLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiCallLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AiCallLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiCallLogClient<$Result.GetResult<Prisma.$AiCallLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiCallLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiCallLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiCallLogs
     * const aiCallLogs = await prisma.aiCallLog.findMany()
     * 
     * // Get first 10 AiCallLogs
     * const aiCallLogs = await prisma.aiCallLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiCallLogWithIdOnly = await prisma.aiCallLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiCallLogFindManyArgs>(args?: SelectSubset<T, AiCallLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiCallLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiCallLog.
     * @param {AiCallLogCreateArgs} args - Arguments to create a AiCallLog.
     * @example
     * // Create one AiCallLog
     * const AiCallLog = await prisma.aiCallLog.create({
     *   data: {
     *     // ... data to create a AiCallLog
     *   }
     * })
     * 
     */
    create<T extends AiCallLogCreateArgs>(args: SelectSubset<T, AiCallLogCreateArgs<ExtArgs>>): Prisma__AiCallLogClient<$Result.GetResult<Prisma.$AiCallLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiCallLogs.
     * @param {AiCallLogCreateManyArgs} args - Arguments to create many AiCallLogs.
     * @example
     * // Create many AiCallLogs
     * const aiCallLog = await prisma.aiCallLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiCallLogCreateManyArgs>(args?: SelectSubset<T, AiCallLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AiCallLog.
     * @param {AiCallLogDeleteArgs} args - Arguments to delete one AiCallLog.
     * @example
     * // Delete one AiCallLog
     * const AiCallLog = await prisma.aiCallLog.delete({
     *   where: {
     *     // ... filter to delete one AiCallLog
     *   }
     * })
     * 
     */
    delete<T extends AiCallLogDeleteArgs>(args: SelectSubset<T, AiCallLogDeleteArgs<ExtArgs>>): Prisma__AiCallLogClient<$Result.GetResult<Prisma.$AiCallLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiCallLog.
     * @param {AiCallLogUpdateArgs} args - Arguments to update one AiCallLog.
     * @example
     * // Update one AiCallLog
     * const aiCallLog = await prisma.aiCallLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiCallLogUpdateArgs>(args: SelectSubset<T, AiCallLogUpdateArgs<ExtArgs>>): Prisma__AiCallLogClient<$Result.GetResult<Prisma.$AiCallLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiCallLogs.
     * @param {AiCallLogDeleteManyArgs} args - Arguments to filter AiCallLogs to delete.
     * @example
     * // Delete a few AiCallLogs
     * const { count } = await prisma.aiCallLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiCallLogDeleteManyArgs>(args?: SelectSubset<T, AiCallLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiCallLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiCallLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiCallLogs
     * const aiCallLog = await prisma.aiCallLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiCallLogUpdateManyArgs>(args: SelectSubset<T, AiCallLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AiCallLog.
     * @param {AiCallLogUpsertArgs} args - Arguments to update or create a AiCallLog.
     * @example
     * // Update or create a AiCallLog
     * const aiCallLog = await prisma.aiCallLog.upsert({
     *   create: {
     *     // ... data to create a AiCallLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiCallLog we want to update
     *   }
     * })
     */
    upsert<T extends AiCallLogUpsertArgs>(args: SelectSubset<T, AiCallLogUpsertArgs<ExtArgs>>): Prisma__AiCallLogClient<$Result.GetResult<Prisma.$AiCallLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiCallLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiCallLogCountArgs} args - Arguments to filter AiCallLogs to count.
     * @example
     * // Count the number of AiCallLogs
     * const count = await prisma.aiCallLog.count({
     *   where: {
     *     // ... the filter for the AiCallLogs we want to count
     *   }
     * })
    **/
    count<T extends AiCallLogCountArgs>(
      args?: Subset<T, AiCallLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiCallLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiCallLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiCallLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiCallLogAggregateArgs>(args: Subset<T, AiCallLogAggregateArgs>): Prisma.PrismaPromise<GetAiCallLogAggregateType<T>>

    /**
     * Group by AiCallLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiCallLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiCallLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiCallLogGroupByArgs['orderBy'] }
        : { orderBy?: AiCallLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiCallLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiCallLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiCallLog model
   */
  readonly fields: AiCallLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiCallLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiCallLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiCallLog model
   */
  interface AiCallLogFieldRefs {
    readonly id: FieldRef<"AiCallLog", 'String'>
    readonly scriptName: FieldRef<"AiCallLog", 'String'>
    readonly orderId: FieldRef<"AiCallLog", 'Int'>
    readonly orderNumber: FieldRef<"AiCallLog", 'String'>
    readonly marketplace: FieldRef<"AiCallLog", 'String'>
    readonly aiProvider: FieldRef<"AiCallLog", 'String'>
    readonly modelUsed: FieldRef<"AiCallLog", 'String'>
    readonly promptSent: FieldRef<"AiCallLog", 'String'>
    readonly rawResponse: FieldRef<"AiCallLog", 'String'>
    readonly processingTimeMs: FieldRef<"AiCallLog", 'Int'>
    readonly success: FieldRef<"AiCallLog", 'Boolean'>
    readonly errorMessage: FieldRef<"AiCallLog", 'String'>
    readonly tasksGenerated: FieldRef<"AiCallLog", 'Int'>
    readonly needsReviewCount: FieldRef<"AiCallLog", 'Int'>
    readonly createdAt: FieldRef<"AiCallLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiCallLog findUnique
   */
  export type AiCallLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiCallLog
     */
    select?: AiCallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiCallLog
     */
    omit?: AiCallLogOmit<ExtArgs> | null
    /**
     * Filter, which AiCallLog to fetch.
     */
    where: AiCallLogWhereUniqueInput
  }

  /**
   * AiCallLog findUniqueOrThrow
   */
  export type AiCallLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiCallLog
     */
    select?: AiCallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiCallLog
     */
    omit?: AiCallLogOmit<ExtArgs> | null
    /**
     * Filter, which AiCallLog to fetch.
     */
    where: AiCallLogWhereUniqueInput
  }

  /**
   * AiCallLog findFirst
   */
  export type AiCallLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiCallLog
     */
    select?: AiCallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiCallLog
     */
    omit?: AiCallLogOmit<ExtArgs> | null
    /**
     * Filter, which AiCallLog to fetch.
     */
    where?: AiCallLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiCallLogs to fetch.
     */
    orderBy?: AiCallLogOrderByWithRelationInput | AiCallLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiCallLogs.
     */
    cursor?: AiCallLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiCallLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiCallLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiCallLogs.
     */
    distinct?: AiCallLogScalarFieldEnum | AiCallLogScalarFieldEnum[]
  }

  /**
   * AiCallLog findFirstOrThrow
   */
  export type AiCallLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiCallLog
     */
    select?: AiCallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiCallLog
     */
    omit?: AiCallLogOmit<ExtArgs> | null
    /**
     * Filter, which AiCallLog to fetch.
     */
    where?: AiCallLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiCallLogs to fetch.
     */
    orderBy?: AiCallLogOrderByWithRelationInput | AiCallLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiCallLogs.
     */
    cursor?: AiCallLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiCallLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiCallLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiCallLogs.
     */
    distinct?: AiCallLogScalarFieldEnum | AiCallLogScalarFieldEnum[]
  }

  /**
   * AiCallLog findMany
   */
  export type AiCallLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiCallLog
     */
    select?: AiCallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiCallLog
     */
    omit?: AiCallLogOmit<ExtArgs> | null
    /**
     * Filter, which AiCallLogs to fetch.
     */
    where?: AiCallLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiCallLogs to fetch.
     */
    orderBy?: AiCallLogOrderByWithRelationInput | AiCallLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiCallLogs.
     */
    cursor?: AiCallLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiCallLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiCallLogs.
     */
    skip?: number
    distinct?: AiCallLogScalarFieldEnum | AiCallLogScalarFieldEnum[]
  }

  /**
   * AiCallLog create
   */
  export type AiCallLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiCallLog
     */
    select?: AiCallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiCallLog
     */
    omit?: AiCallLogOmit<ExtArgs> | null
    /**
     * The data needed to create a AiCallLog.
     */
    data: XOR<AiCallLogCreateInput, AiCallLogUncheckedCreateInput>
  }

  /**
   * AiCallLog createMany
   */
  export type AiCallLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiCallLogs.
     */
    data: AiCallLogCreateManyInput | AiCallLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiCallLog update
   */
  export type AiCallLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiCallLog
     */
    select?: AiCallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiCallLog
     */
    omit?: AiCallLogOmit<ExtArgs> | null
    /**
     * The data needed to update a AiCallLog.
     */
    data: XOR<AiCallLogUpdateInput, AiCallLogUncheckedUpdateInput>
    /**
     * Choose, which AiCallLog to update.
     */
    where: AiCallLogWhereUniqueInput
  }

  /**
   * AiCallLog updateMany
   */
  export type AiCallLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiCallLogs.
     */
    data: XOR<AiCallLogUpdateManyMutationInput, AiCallLogUncheckedUpdateManyInput>
    /**
     * Filter which AiCallLogs to update
     */
    where?: AiCallLogWhereInput
    /**
     * Limit how many AiCallLogs to update.
     */
    limit?: number
  }

  /**
   * AiCallLog upsert
   */
  export type AiCallLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiCallLog
     */
    select?: AiCallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiCallLog
     */
    omit?: AiCallLogOmit<ExtArgs> | null
    /**
     * The filter to search for the AiCallLog to update in case it exists.
     */
    where: AiCallLogWhereUniqueInput
    /**
     * In case the AiCallLog found by the `where` argument doesn't exist, create a new AiCallLog with this data.
     */
    create: XOR<AiCallLogCreateInput, AiCallLogUncheckedCreateInput>
    /**
     * In case the AiCallLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiCallLogUpdateInput, AiCallLogUncheckedUpdateInput>
  }

  /**
   * AiCallLog delete
   */
  export type AiCallLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiCallLog
     */
    select?: AiCallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiCallLog
     */
    omit?: AiCallLogOmit<ExtArgs> | null
    /**
     * Filter which AiCallLog to delete.
     */
    where: AiCallLogWhereUniqueInput
  }

  /**
   * AiCallLog deleteMany
   */
  export type AiCallLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiCallLogs to delete
     */
    where?: AiCallLogWhereInput
    /**
     * Limit how many AiCallLogs to delete.
     */
    limit?: number
  }

  /**
   * AiCallLog without action
   */
  export type AiCallLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiCallLog
     */
    select?: AiCallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiCallLog
     */
    omit?: AiCallLogOmit<ExtArgs> | null
  }


  /**
   * Model Metric
   */

  export type AggregateMetric = {
    _count: MetricCountAggregateOutputType | null
    _avg: MetricAvgAggregateOutputType | null
    _sum: MetricSumAggregateOutputType | null
    _min: MetricMinAggregateOutputType | null
    _max: MetricMaxAggregateOutputType | null
  }

  export type MetricAvgAggregateOutputType = {
    id: number | null
    value: number | null
  }

  export type MetricSumAggregateOutputType = {
    id: number | null
    value: number | null
  }

  export type MetricMinAggregateOutputType = {
    id: number | null
    name: string | null
    value: number | null
    timestamp: Date | null
  }

  export type MetricMaxAggregateOutputType = {
    id: number | null
    name: string | null
    value: number | null
    timestamp: Date | null
  }

  export type MetricCountAggregateOutputType = {
    id: number
    name: number
    value: number
    tags: number
    timestamp: number
    _all: number
  }


  export type MetricAvgAggregateInputType = {
    id?: true
    value?: true
  }

  export type MetricSumAggregateInputType = {
    id?: true
    value?: true
  }

  export type MetricMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    timestamp?: true
  }

  export type MetricMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    timestamp?: true
  }

  export type MetricCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    tags?: true
    timestamp?: true
    _all?: true
  }

  export type MetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Metric to aggregate.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Metrics
    **/
    _count?: true | MetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetricMaxAggregateInputType
  }

  export type GetMetricAggregateType<T extends MetricAggregateArgs> = {
        [P in keyof T & keyof AggregateMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetric[P]>
      : GetScalarType<T[P], AggregateMetric[P]>
  }




  export type MetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MetricWhereInput
    orderBy?: MetricOrderByWithAggregationInput | MetricOrderByWithAggregationInput[]
    by: MetricScalarFieldEnum[] | MetricScalarFieldEnum
    having?: MetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetricCountAggregateInputType | true
    _avg?: MetricAvgAggregateInputType
    _sum?: MetricSumAggregateInputType
    _min?: MetricMinAggregateInputType
    _max?: MetricMaxAggregateInputType
  }

  export type MetricGroupByOutputType = {
    id: number
    name: string
    value: number
    tags: JsonValue | null
    timestamp: Date
    _count: MetricCountAggregateOutputType | null
    _avg: MetricAvgAggregateOutputType | null
    _sum: MetricSumAggregateOutputType | null
    _min: MetricMinAggregateOutputType | null
    _max: MetricMaxAggregateOutputType | null
  }

  type GetMetricGroupByPayload<T extends MetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetricGroupByOutputType[P]>
            : GetScalarType<T[P], MetricGroupByOutputType[P]>
        }
      >
    >


  export type MetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    tags?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["metric"]>



  export type MetricSelectScalar = {
    id?: boolean
    name?: boolean
    value?: boolean
    tags?: boolean
    timestamp?: boolean
  }

  export type MetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "value" | "tags" | "timestamp", ExtArgs["result"]["metric"]>

  export type $MetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Metric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      value: number
      tags: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["metric"]>
    composites: {}
  }

  type MetricGetPayload<S extends boolean | null | undefined | MetricDefaultArgs> = $Result.GetResult<Prisma.$MetricPayload, S>

  type MetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MetricCountAggregateInputType | true
    }

  export interface MetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Metric'], meta: { name: 'Metric' } }
    /**
     * Find zero or one Metric that matches the filter.
     * @param {MetricFindUniqueArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MetricFindUniqueArgs>(args: SelectSubset<T, MetricFindUniqueArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Metric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MetricFindUniqueOrThrowArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MetricFindUniqueOrThrowArgs>(args: SelectSubset<T, MetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Metric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricFindFirstArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MetricFindFirstArgs>(args?: SelectSubset<T, MetricFindFirstArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Metric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricFindFirstOrThrowArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MetricFindFirstOrThrowArgs>(args?: SelectSubset<T, MetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Metrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Metrics
     * const metrics = await prisma.metric.findMany()
     * 
     * // Get first 10 Metrics
     * const metrics = await prisma.metric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metricWithIdOnly = await prisma.metric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MetricFindManyArgs>(args?: SelectSubset<T, MetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Metric.
     * @param {MetricCreateArgs} args - Arguments to create a Metric.
     * @example
     * // Create one Metric
     * const Metric = await prisma.metric.create({
     *   data: {
     *     // ... data to create a Metric
     *   }
     * })
     * 
     */
    create<T extends MetricCreateArgs>(args: SelectSubset<T, MetricCreateArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Metrics.
     * @param {MetricCreateManyArgs} args - Arguments to create many Metrics.
     * @example
     * // Create many Metrics
     * const metric = await prisma.metric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MetricCreateManyArgs>(args?: SelectSubset<T, MetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Metric.
     * @param {MetricDeleteArgs} args - Arguments to delete one Metric.
     * @example
     * // Delete one Metric
     * const Metric = await prisma.metric.delete({
     *   where: {
     *     // ... filter to delete one Metric
     *   }
     * })
     * 
     */
    delete<T extends MetricDeleteArgs>(args: SelectSubset<T, MetricDeleteArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Metric.
     * @param {MetricUpdateArgs} args - Arguments to update one Metric.
     * @example
     * // Update one Metric
     * const metric = await prisma.metric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MetricUpdateArgs>(args: SelectSubset<T, MetricUpdateArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Metrics.
     * @param {MetricDeleteManyArgs} args - Arguments to filter Metrics to delete.
     * @example
     * // Delete a few Metrics
     * const { count } = await prisma.metric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MetricDeleteManyArgs>(args?: SelectSubset<T, MetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Metrics
     * const metric = await prisma.metric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MetricUpdateManyArgs>(args: SelectSubset<T, MetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Metric.
     * @param {MetricUpsertArgs} args - Arguments to update or create a Metric.
     * @example
     * // Update or create a Metric
     * const metric = await prisma.metric.upsert({
     *   create: {
     *     // ... data to create a Metric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Metric we want to update
     *   }
     * })
     */
    upsert<T extends MetricUpsertArgs>(args: SelectSubset<T, MetricUpsertArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricCountArgs} args - Arguments to filter Metrics to count.
     * @example
     * // Count the number of Metrics
     * const count = await prisma.metric.count({
     *   where: {
     *     // ... the filter for the Metrics we want to count
     *   }
     * })
    **/
    count<T extends MetricCountArgs>(
      args?: Subset<T, MetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Metric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetricAggregateArgs>(args: Subset<T, MetricAggregateArgs>): Prisma.PrismaPromise<GetMetricAggregateType<T>>

    /**
     * Group by Metric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetricGroupByArgs['orderBy'] }
        : { orderBy?: MetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Metric model
   */
  readonly fields: MetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Metric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Metric model
   */
  interface MetricFieldRefs {
    readonly id: FieldRef<"Metric", 'Int'>
    readonly name: FieldRef<"Metric", 'String'>
    readonly value: FieldRef<"Metric", 'Float'>
    readonly tags: FieldRef<"Metric", 'Json'>
    readonly timestamp: FieldRef<"Metric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Metric findUnique
   */
  export type MetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric findUniqueOrThrow
   */
  export type MetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric findFirst
   */
  export type MetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Metrics.
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Metrics.
     */
    distinct?: MetricScalarFieldEnum | MetricScalarFieldEnum[]
  }

  /**
   * Metric findFirstOrThrow
   */
  export type MetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Metrics.
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Metrics.
     */
    distinct?: MetricScalarFieldEnum | MetricScalarFieldEnum[]
  }

  /**
   * Metric findMany
   */
  export type MetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * Filter, which Metrics to fetch.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Metrics.
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    distinct?: MetricScalarFieldEnum | MetricScalarFieldEnum[]
  }

  /**
   * Metric create
   */
  export type MetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * The data needed to create a Metric.
     */
    data: XOR<MetricCreateInput, MetricUncheckedCreateInput>
  }

  /**
   * Metric createMany
   */
  export type MetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Metrics.
     */
    data: MetricCreateManyInput | MetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Metric update
   */
  export type MetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * The data needed to update a Metric.
     */
    data: XOR<MetricUpdateInput, MetricUncheckedUpdateInput>
    /**
     * Choose, which Metric to update.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric updateMany
   */
  export type MetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Metrics.
     */
    data: XOR<MetricUpdateManyMutationInput, MetricUncheckedUpdateManyInput>
    /**
     * Filter which Metrics to update
     */
    where?: MetricWhereInput
    /**
     * Limit how many Metrics to update.
     */
    limit?: number
  }

  /**
   * Metric upsert
   */
  export type MetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * The filter to search for the Metric to update in case it exists.
     */
    where: MetricWhereUniqueInput
    /**
     * In case the Metric found by the `where` argument doesn't exist, create a new Metric with this data.
     */
    create: XOR<MetricCreateInput, MetricUncheckedCreateInput>
    /**
     * In case the Metric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MetricUpdateInput, MetricUncheckedUpdateInput>
  }

  /**
   * Metric delete
   */
  export type MetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * Filter which Metric to delete.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric deleteMany
   */
  export type MetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Metrics to delete
     */
    where?: MetricWhereInput
    /**
     * Limit how many Metrics to delete.
     */
    limit?: number
  }

  /**
   * Metric without action
   */
  export type MetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
  }


  /**
   * Model AiReportDefinition
   */

  export type AggregateAiReportDefinition = {
    _count: AiReportDefinitionCountAggregateOutputType | null
    _min: AiReportDefinitionMinAggregateOutputType | null
    _max: AiReportDefinitionMaxAggregateOutputType | null
  }

  export type AiReportDefinitionMinAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    description: string | null
    systemPrompt: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiReportDefinitionMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    description: string | null
    systemPrompt: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiReportDefinitionCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    description: number
    systemPrompt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AiReportDefinitionMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    systemPrompt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiReportDefinitionMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    systemPrompt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiReportDefinitionCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    systemPrompt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AiReportDefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiReportDefinition to aggregate.
     */
    where?: AiReportDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiReportDefinitions to fetch.
     */
    orderBy?: AiReportDefinitionOrderByWithRelationInput | AiReportDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiReportDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiReportDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiReportDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiReportDefinitions
    **/
    _count?: true | AiReportDefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiReportDefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiReportDefinitionMaxAggregateInputType
  }

  export type GetAiReportDefinitionAggregateType<T extends AiReportDefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateAiReportDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiReportDefinition[P]>
      : GetScalarType<T[P], AggregateAiReportDefinition[P]>
  }




  export type AiReportDefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiReportDefinitionWhereInput
    orderBy?: AiReportDefinitionOrderByWithAggregationInput | AiReportDefinitionOrderByWithAggregationInput[]
    by: AiReportDefinitionScalarFieldEnum[] | AiReportDefinitionScalarFieldEnum
    having?: AiReportDefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiReportDefinitionCountAggregateInputType | true
    _min?: AiReportDefinitionMinAggregateInputType
    _max?: AiReportDefinitionMaxAggregateInputType
  }

  export type AiReportDefinitionGroupByOutputType = {
    id: string
    slug: string
    name: string
    description: string
    systemPrompt: string
    createdAt: Date
    updatedAt: Date
    _count: AiReportDefinitionCountAggregateOutputType | null
    _min: AiReportDefinitionMinAggregateOutputType | null
    _max: AiReportDefinitionMaxAggregateOutputType | null
  }

  type GetAiReportDefinitionGroupByPayload<T extends AiReportDefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiReportDefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiReportDefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiReportDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], AiReportDefinitionGroupByOutputType[P]>
        }
      >
    >


  export type AiReportDefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    systemPrompt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runs?: boolean | AiReportDefinition$runsArgs<ExtArgs>
    _count?: boolean | AiReportDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiReportDefinition"]>



  export type AiReportDefinitionSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    systemPrompt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AiReportDefinitionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "name" | "description" | "systemPrompt" | "createdAt" | "updatedAt", ExtArgs["result"]["aiReportDefinition"]>
  export type AiReportDefinitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runs?: boolean | AiReportDefinition$runsArgs<ExtArgs>
    _count?: boolean | AiReportDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AiReportDefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiReportDefinition"
    objects: {
      runs: Prisma.$AiReportRunPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      name: string
      description: string
      systemPrompt: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aiReportDefinition"]>
    composites: {}
  }

  type AiReportDefinitionGetPayload<S extends boolean | null | undefined | AiReportDefinitionDefaultArgs> = $Result.GetResult<Prisma.$AiReportDefinitionPayload, S>

  type AiReportDefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiReportDefinitionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiReportDefinitionCountAggregateInputType | true
    }

  export interface AiReportDefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiReportDefinition'], meta: { name: 'AiReportDefinition' } }
    /**
     * Find zero or one AiReportDefinition that matches the filter.
     * @param {AiReportDefinitionFindUniqueArgs} args - Arguments to find a AiReportDefinition
     * @example
     * // Get one AiReportDefinition
     * const aiReportDefinition = await prisma.aiReportDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiReportDefinitionFindUniqueArgs>(args: SelectSubset<T, AiReportDefinitionFindUniqueArgs<ExtArgs>>): Prisma__AiReportDefinitionClient<$Result.GetResult<Prisma.$AiReportDefinitionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiReportDefinition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiReportDefinitionFindUniqueOrThrowArgs} args - Arguments to find a AiReportDefinition
     * @example
     * // Get one AiReportDefinition
     * const aiReportDefinition = await prisma.aiReportDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiReportDefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, AiReportDefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiReportDefinitionClient<$Result.GetResult<Prisma.$AiReportDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiReportDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiReportDefinitionFindFirstArgs} args - Arguments to find a AiReportDefinition
     * @example
     * // Get one AiReportDefinition
     * const aiReportDefinition = await prisma.aiReportDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiReportDefinitionFindFirstArgs>(args?: SelectSubset<T, AiReportDefinitionFindFirstArgs<ExtArgs>>): Prisma__AiReportDefinitionClient<$Result.GetResult<Prisma.$AiReportDefinitionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiReportDefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiReportDefinitionFindFirstOrThrowArgs} args - Arguments to find a AiReportDefinition
     * @example
     * // Get one AiReportDefinition
     * const aiReportDefinition = await prisma.aiReportDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiReportDefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, AiReportDefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiReportDefinitionClient<$Result.GetResult<Prisma.$AiReportDefinitionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiReportDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiReportDefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiReportDefinitions
     * const aiReportDefinitions = await prisma.aiReportDefinition.findMany()
     * 
     * // Get first 10 AiReportDefinitions
     * const aiReportDefinitions = await prisma.aiReportDefinition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiReportDefinitionWithIdOnly = await prisma.aiReportDefinition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiReportDefinitionFindManyArgs>(args?: SelectSubset<T, AiReportDefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiReportDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiReportDefinition.
     * @param {AiReportDefinitionCreateArgs} args - Arguments to create a AiReportDefinition.
     * @example
     * // Create one AiReportDefinition
     * const AiReportDefinition = await prisma.aiReportDefinition.create({
     *   data: {
     *     // ... data to create a AiReportDefinition
     *   }
     * })
     * 
     */
    create<T extends AiReportDefinitionCreateArgs>(args: SelectSubset<T, AiReportDefinitionCreateArgs<ExtArgs>>): Prisma__AiReportDefinitionClient<$Result.GetResult<Prisma.$AiReportDefinitionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiReportDefinitions.
     * @param {AiReportDefinitionCreateManyArgs} args - Arguments to create many AiReportDefinitions.
     * @example
     * // Create many AiReportDefinitions
     * const aiReportDefinition = await prisma.aiReportDefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiReportDefinitionCreateManyArgs>(args?: SelectSubset<T, AiReportDefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AiReportDefinition.
     * @param {AiReportDefinitionDeleteArgs} args - Arguments to delete one AiReportDefinition.
     * @example
     * // Delete one AiReportDefinition
     * const AiReportDefinition = await prisma.aiReportDefinition.delete({
     *   where: {
     *     // ... filter to delete one AiReportDefinition
     *   }
     * })
     * 
     */
    delete<T extends AiReportDefinitionDeleteArgs>(args: SelectSubset<T, AiReportDefinitionDeleteArgs<ExtArgs>>): Prisma__AiReportDefinitionClient<$Result.GetResult<Prisma.$AiReportDefinitionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiReportDefinition.
     * @param {AiReportDefinitionUpdateArgs} args - Arguments to update one AiReportDefinition.
     * @example
     * // Update one AiReportDefinition
     * const aiReportDefinition = await prisma.aiReportDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiReportDefinitionUpdateArgs>(args: SelectSubset<T, AiReportDefinitionUpdateArgs<ExtArgs>>): Prisma__AiReportDefinitionClient<$Result.GetResult<Prisma.$AiReportDefinitionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiReportDefinitions.
     * @param {AiReportDefinitionDeleteManyArgs} args - Arguments to filter AiReportDefinitions to delete.
     * @example
     * // Delete a few AiReportDefinitions
     * const { count } = await prisma.aiReportDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiReportDefinitionDeleteManyArgs>(args?: SelectSubset<T, AiReportDefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiReportDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiReportDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiReportDefinitions
     * const aiReportDefinition = await prisma.aiReportDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiReportDefinitionUpdateManyArgs>(args: SelectSubset<T, AiReportDefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AiReportDefinition.
     * @param {AiReportDefinitionUpsertArgs} args - Arguments to update or create a AiReportDefinition.
     * @example
     * // Update or create a AiReportDefinition
     * const aiReportDefinition = await prisma.aiReportDefinition.upsert({
     *   create: {
     *     // ... data to create a AiReportDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiReportDefinition we want to update
     *   }
     * })
     */
    upsert<T extends AiReportDefinitionUpsertArgs>(args: SelectSubset<T, AiReportDefinitionUpsertArgs<ExtArgs>>): Prisma__AiReportDefinitionClient<$Result.GetResult<Prisma.$AiReportDefinitionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiReportDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiReportDefinitionCountArgs} args - Arguments to filter AiReportDefinitions to count.
     * @example
     * // Count the number of AiReportDefinitions
     * const count = await prisma.aiReportDefinition.count({
     *   where: {
     *     // ... the filter for the AiReportDefinitions we want to count
     *   }
     * })
    **/
    count<T extends AiReportDefinitionCountArgs>(
      args?: Subset<T, AiReportDefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiReportDefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiReportDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiReportDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiReportDefinitionAggregateArgs>(args: Subset<T, AiReportDefinitionAggregateArgs>): Prisma.PrismaPromise<GetAiReportDefinitionAggregateType<T>>

    /**
     * Group by AiReportDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiReportDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiReportDefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiReportDefinitionGroupByArgs['orderBy'] }
        : { orderBy?: AiReportDefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiReportDefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiReportDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiReportDefinition model
   */
  readonly fields: AiReportDefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiReportDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiReportDefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    runs<T extends AiReportDefinition$runsArgs<ExtArgs> = {}>(args?: Subset<T, AiReportDefinition$runsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiReportRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiReportDefinition model
   */
  interface AiReportDefinitionFieldRefs {
    readonly id: FieldRef<"AiReportDefinition", 'String'>
    readonly slug: FieldRef<"AiReportDefinition", 'String'>
    readonly name: FieldRef<"AiReportDefinition", 'String'>
    readonly description: FieldRef<"AiReportDefinition", 'String'>
    readonly systemPrompt: FieldRef<"AiReportDefinition", 'String'>
    readonly createdAt: FieldRef<"AiReportDefinition", 'DateTime'>
    readonly updatedAt: FieldRef<"AiReportDefinition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiReportDefinition findUnique
   */
  export type AiReportDefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportDefinition
     */
    select?: AiReportDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportDefinition
     */
    omit?: AiReportDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which AiReportDefinition to fetch.
     */
    where: AiReportDefinitionWhereUniqueInput
  }

  /**
   * AiReportDefinition findUniqueOrThrow
   */
  export type AiReportDefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportDefinition
     */
    select?: AiReportDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportDefinition
     */
    omit?: AiReportDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which AiReportDefinition to fetch.
     */
    where: AiReportDefinitionWhereUniqueInput
  }

  /**
   * AiReportDefinition findFirst
   */
  export type AiReportDefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportDefinition
     */
    select?: AiReportDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportDefinition
     */
    omit?: AiReportDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which AiReportDefinition to fetch.
     */
    where?: AiReportDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiReportDefinitions to fetch.
     */
    orderBy?: AiReportDefinitionOrderByWithRelationInput | AiReportDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiReportDefinitions.
     */
    cursor?: AiReportDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiReportDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiReportDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiReportDefinitions.
     */
    distinct?: AiReportDefinitionScalarFieldEnum | AiReportDefinitionScalarFieldEnum[]
  }

  /**
   * AiReportDefinition findFirstOrThrow
   */
  export type AiReportDefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportDefinition
     */
    select?: AiReportDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportDefinition
     */
    omit?: AiReportDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which AiReportDefinition to fetch.
     */
    where?: AiReportDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiReportDefinitions to fetch.
     */
    orderBy?: AiReportDefinitionOrderByWithRelationInput | AiReportDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiReportDefinitions.
     */
    cursor?: AiReportDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiReportDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiReportDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiReportDefinitions.
     */
    distinct?: AiReportDefinitionScalarFieldEnum | AiReportDefinitionScalarFieldEnum[]
  }

  /**
   * AiReportDefinition findMany
   */
  export type AiReportDefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportDefinition
     */
    select?: AiReportDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportDefinition
     */
    omit?: AiReportDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which AiReportDefinitions to fetch.
     */
    where?: AiReportDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiReportDefinitions to fetch.
     */
    orderBy?: AiReportDefinitionOrderByWithRelationInput | AiReportDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiReportDefinitions.
     */
    cursor?: AiReportDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiReportDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiReportDefinitions.
     */
    skip?: number
    distinct?: AiReportDefinitionScalarFieldEnum | AiReportDefinitionScalarFieldEnum[]
  }

  /**
   * AiReportDefinition create
   */
  export type AiReportDefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportDefinition
     */
    select?: AiReportDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportDefinition
     */
    omit?: AiReportDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to create a AiReportDefinition.
     */
    data: XOR<AiReportDefinitionCreateInput, AiReportDefinitionUncheckedCreateInput>
  }

  /**
   * AiReportDefinition createMany
   */
  export type AiReportDefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiReportDefinitions.
     */
    data: AiReportDefinitionCreateManyInput | AiReportDefinitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiReportDefinition update
   */
  export type AiReportDefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportDefinition
     */
    select?: AiReportDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportDefinition
     */
    omit?: AiReportDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to update a AiReportDefinition.
     */
    data: XOR<AiReportDefinitionUpdateInput, AiReportDefinitionUncheckedUpdateInput>
    /**
     * Choose, which AiReportDefinition to update.
     */
    where: AiReportDefinitionWhereUniqueInput
  }

  /**
   * AiReportDefinition updateMany
   */
  export type AiReportDefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiReportDefinitions.
     */
    data: XOR<AiReportDefinitionUpdateManyMutationInput, AiReportDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which AiReportDefinitions to update
     */
    where?: AiReportDefinitionWhereInput
    /**
     * Limit how many AiReportDefinitions to update.
     */
    limit?: number
  }

  /**
   * AiReportDefinition upsert
   */
  export type AiReportDefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportDefinition
     */
    select?: AiReportDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportDefinition
     */
    omit?: AiReportDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportDefinitionInclude<ExtArgs> | null
    /**
     * The filter to search for the AiReportDefinition to update in case it exists.
     */
    where: AiReportDefinitionWhereUniqueInput
    /**
     * In case the AiReportDefinition found by the `where` argument doesn't exist, create a new AiReportDefinition with this data.
     */
    create: XOR<AiReportDefinitionCreateInput, AiReportDefinitionUncheckedCreateInput>
    /**
     * In case the AiReportDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiReportDefinitionUpdateInput, AiReportDefinitionUncheckedUpdateInput>
  }

  /**
   * AiReportDefinition delete
   */
  export type AiReportDefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportDefinition
     */
    select?: AiReportDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportDefinition
     */
    omit?: AiReportDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportDefinitionInclude<ExtArgs> | null
    /**
     * Filter which AiReportDefinition to delete.
     */
    where: AiReportDefinitionWhereUniqueInput
  }

  /**
   * AiReportDefinition deleteMany
   */
  export type AiReportDefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiReportDefinitions to delete
     */
    where?: AiReportDefinitionWhereInput
    /**
     * Limit how many AiReportDefinitions to delete.
     */
    limit?: number
  }

  /**
   * AiReportDefinition.runs
   */
  export type AiReportDefinition$runsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportRun
     */
    select?: AiReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportRun
     */
    omit?: AiReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportRunInclude<ExtArgs> | null
    where?: AiReportRunWhereInput
    orderBy?: AiReportRunOrderByWithRelationInput | AiReportRunOrderByWithRelationInput[]
    cursor?: AiReportRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiReportRunScalarFieldEnum | AiReportRunScalarFieldEnum[]
  }

  /**
   * AiReportDefinition without action
   */
  export type AiReportDefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportDefinition
     */
    select?: AiReportDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportDefinition
     */
    omit?: AiReportDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportDefinitionInclude<ExtArgs> | null
  }


  /**
   * Model AiReportRun
   */

  export type AggregateAiReportRun = {
    _count: AiReportRunCountAggregateOutputType | null
    _min: AiReportRunMinAggregateOutputType | null
    _max: AiReportRunMaxAggregateOutputType | null
  }

  export type AiReportRunMinAggregateOutputType = {
    id: string | null
    reportId: string | null
    rawResponse: string | null
    status: string | null
    errorMsg: string | null
    createdAt: Date | null
    finishedAt: Date | null
  }

  export type AiReportRunMaxAggregateOutputType = {
    id: string | null
    reportId: string | null
    rawResponse: string | null
    status: string | null
    errorMsg: string | null
    createdAt: Date | null
    finishedAt: Date | null
  }

  export type AiReportRunCountAggregateOutputType = {
    id: number
    reportId: number
    inputJson: number
    outputJson: number
    rawResponse: number
    status: number
    errorMsg: number
    createdAt: number
    finishedAt: number
    _all: number
  }


  export type AiReportRunMinAggregateInputType = {
    id?: true
    reportId?: true
    rawResponse?: true
    status?: true
    errorMsg?: true
    createdAt?: true
    finishedAt?: true
  }

  export type AiReportRunMaxAggregateInputType = {
    id?: true
    reportId?: true
    rawResponse?: true
    status?: true
    errorMsg?: true
    createdAt?: true
    finishedAt?: true
  }

  export type AiReportRunCountAggregateInputType = {
    id?: true
    reportId?: true
    inputJson?: true
    outputJson?: true
    rawResponse?: true
    status?: true
    errorMsg?: true
    createdAt?: true
    finishedAt?: true
    _all?: true
  }

  export type AiReportRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiReportRun to aggregate.
     */
    where?: AiReportRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiReportRuns to fetch.
     */
    orderBy?: AiReportRunOrderByWithRelationInput | AiReportRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiReportRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiReportRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiReportRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiReportRuns
    **/
    _count?: true | AiReportRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiReportRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiReportRunMaxAggregateInputType
  }

  export type GetAiReportRunAggregateType<T extends AiReportRunAggregateArgs> = {
        [P in keyof T & keyof AggregateAiReportRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiReportRun[P]>
      : GetScalarType<T[P], AggregateAiReportRun[P]>
  }




  export type AiReportRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiReportRunWhereInput
    orderBy?: AiReportRunOrderByWithAggregationInput | AiReportRunOrderByWithAggregationInput[]
    by: AiReportRunScalarFieldEnum[] | AiReportRunScalarFieldEnum
    having?: AiReportRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiReportRunCountAggregateInputType | true
    _min?: AiReportRunMinAggregateInputType
    _max?: AiReportRunMaxAggregateInputType
  }

  export type AiReportRunGroupByOutputType = {
    id: string
    reportId: string
    inputJson: JsonValue
    outputJson: JsonValue | null
    rawResponse: string | null
    status: string
    errorMsg: string | null
    createdAt: Date
    finishedAt: Date | null
    _count: AiReportRunCountAggregateOutputType | null
    _min: AiReportRunMinAggregateOutputType | null
    _max: AiReportRunMaxAggregateOutputType | null
  }

  type GetAiReportRunGroupByPayload<T extends AiReportRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiReportRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiReportRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiReportRunGroupByOutputType[P]>
            : GetScalarType<T[P], AiReportRunGroupByOutputType[P]>
        }
      >
    >


  export type AiReportRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportId?: boolean
    inputJson?: boolean
    outputJson?: boolean
    rawResponse?: boolean
    status?: boolean
    errorMsg?: boolean
    createdAt?: boolean
    finishedAt?: boolean
    report?: boolean | AiReportDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiReportRun"]>



  export type AiReportRunSelectScalar = {
    id?: boolean
    reportId?: boolean
    inputJson?: boolean
    outputJson?: boolean
    rawResponse?: boolean
    status?: boolean
    errorMsg?: boolean
    createdAt?: boolean
    finishedAt?: boolean
  }

  export type AiReportRunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reportId" | "inputJson" | "outputJson" | "rawResponse" | "status" | "errorMsg" | "createdAt" | "finishedAt", ExtArgs["result"]["aiReportRun"]>
  export type AiReportRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | AiReportDefinitionDefaultArgs<ExtArgs>
  }

  export type $AiReportRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiReportRun"
    objects: {
      report: Prisma.$AiReportDefinitionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reportId: string
      inputJson: Prisma.JsonValue
      outputJson: Prisma.JsonValue | null
      rawResponse: string | null
      status: string
      errorMsg: string | null
      createdAt: Date
      finishedAt: Date | null
    }, ExtArgs["result"]["aiReportRun"]>
    composites: {}
  }

  type AiReportRunGetPayload<S extends boolean | null | undefined | AiReportRunDefaultArgs> = $Result.GetResult<Prisma.$AiReportRunPayload, S>

  type AiReportRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiReportRunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiReportRunCountAggregateInputType | true
    }

  export interface AiReportRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiReportRun'], meta: { name: 'AiReportRun' } }
    /**
     * Find zero or one AiReportRun that matches the filter.
     * @param {AiReportRunFindUniqueArgs} args - Arguments to find a AiReportRun
     * @example
     * // Get one AiReportRun
     * const aiReportRun = await prisma.aiReportRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiReportRunFindUniqueArgs>(args: SelectSubset<T, AiReportRunFindUniqueArgs<ExtArgs>>): Prisma__AiReportRunClient<$Result.GetResult<Prisma.$AiReportRunPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiReportRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiReportRunFindUniqueOrThrowArgs} args - Arguments to find a AiReportRun
     * @example
     * // Get one AiReportRun
     * const aiReportRun = await prisma.aiReportRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiReportRunFindUniqueOrThrowArgs>(args: SelectSubset<T, AiReportRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiReportRunClient<$Result.GetResult<Prisma.$AiReportRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiReportRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiReportRunFindFirstArgs} args - Arguments to find a AiReportRun
     * @example
     * // Get one AiReportRun
     * const aiReportRun = await prisma.aiReportRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiReportRunFindFirstArgs>(args?: SelectSubset<T, AiReportRunFindFirstArgs<ExtArgs>>): Prisma__AiReportRunClient<$Result.GetResult<Prisma.$AiReportRunPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiReportRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiReportRunFindFirstOrThrowArgs} args - Arguments to find a AiReportRun
     * @example
     * // Get one AiReportRun
     * const aiReportRun = await prisma.aiReportRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiReportRunFindFirstOrThrowArgs>(args?: SelectSubset<T, AiReportRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiReportRunClient<$Result.GetResult<Prisma.$AiReportRunPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiReportRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiReportRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiReportRuns
     * const aiReportRuns = await prisma.aiReportRun.findMany()
     * 
     * // Get first 10 AiReportRuns
     * const aiReportRuns = await prisma.aiReportRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiReportRunWithIdOnly = await prisma.aiReportRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiReportRunFindManyArgs>(args?: SelectSubset<T, AiReportRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiReportRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiReportRun.
     * @param {AiReportRunCreateArgs} args - Arguments to create a AiReportRun.
     * @example
     * // Create one AiReportRun
     * const AiReportRun = await prisma.aiReportRun.create({
     *   data: {
     *     // ... data to create a AiReportRun
     *   }
     * })
     * 
     */
    create<T extends AiReportRunCreateArgs>(args: SelectSubset<T, AiReportRunCreateArgs<ExtArgs>>): Prisma__AiReportRunClient<$Result.GetResult<Prisma.$AiReportRunPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiReportRuns.
     * @param {AiReportRunCreateManyArgs} args - Arguments to create many AiReportRuns.
     * @example
     * // Create many AiReportRuns
     * const aiReportRun = await prisma.aiReportRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiReportRunCreateManyArgs>(args?: SelectSubset<T, AiReportRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AiReportRun.
     * @param {AiReportRunDeleteArgs} args - Arguments to delete one AiReportRun.
     * @example
     * // Delete one AiReportRun
     * const AiReportRun = await prisma.aiReportRun.delete({
     *   where: {
     *     // ... filter to delete one AiReportRun
     *   }
     * })
     * 
     */
    delete<T extends AiReportRunDeleteArgs>(args: SelectSubset<T, AiReportRunDeleteArgs<ExtArgs>>): Prisma__AiReportRunClient<$Result.GetResult<Prisma.$AiReportRunPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiReportRun.
     * @param {AiReportRunUpdateArgs} args - Arguments to update one AiReportRun.
     * @example
     * // Update one AiReportRun
     * const aiReportRun = await prisma.aiReportRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiReportRunUpdateArgs>(args: SelectSubset<T, AiReportRunUpdateArgs<ExtArgs>>): Prisma__AiReportRunClient<$Result.GetResult<Prisma.$AiReportRunPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiReportRuns.
     * @param {AiReportRunDeleteManyArgs} args - Arguments to filter AiReportRuns to delete.
     * @example
     * // Delete a few AiReportRuns
     * const { count } = await prisma.aiReportRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiReportRunDeleteManyArgs>(args?: SelectSubset<T, AiReportRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiReportRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiReportRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiReportRuns
     * const aiReportRun = await prisma.aiReportRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiReportRunUpdateManyArgs>(args: SelectSubset<T, AiReportRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AiReportRun.
     * @param {AiReportRunUpsertArgs} args - Arguments to update or create a AiReportRun.
     * @example
     * // Update or create a AiReportRun
     * const aiReportRun = await prisma.aiReportRun.upsert({
     *   create: {
     *     // ... data to create a AiReportRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiReportRun we want to update
     *   }
     * })
     */
    upsert<T extends AiReportRunUpsertArgs>(args: SelectSubset<T, AiReportRunUpsertArgs<ExtArgs>>): Prisma__AiReportRunClient<$Result.GetResult<Prisma.$AiReportRunPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiReportRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiReportRunCountArgs} args - Arguments to filter AiReportRuns to count.
     * @example
     * // Count the number of AiReportRuns
     * const count = await prisma.aiReportRun.count({
     *   where: {
     *     // ... the filter for the AiReportRuns we want to count
     *   }
     * })
    **/
    count<T extends AiReportRunCountArgs>(
      args?: Subset<T, AiReportRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiReportRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiReportRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiReportRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiReportRunAggregateArgs>(args: Subset<T, AiReportRunAggregateArgs>): Prisma.PrismaPromise<GetAiReportRunAggregateType<T>>

    /**
     * Group by AiReportRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiReportRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiReportRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiReportRunGroupByArgs['orderBy'] }
        : { orderBy?: AiReportRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiReportRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiReportRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiReportRun model
   */
  readonly fields: AiReportRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiReportRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiReportRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    report<T extends AiReportDefinitionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiReportDefinitionDefaultArgs<ExtArgs>>): Prisma__AiReportDefinitionClient<$Result.GetResult<Prisma.$AiReportDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiReportRun model
   */
  interface AiReportRunFieldRefs {
    readonly id: FieldRef<"AiReportRun", 'String'>
    readonly reportId: FieldRef<"AiReportRun", 'String'>
    readonly inputJson: FieldRef<"AiReportRun", 'Json'>
    readonly outputJson: FieldRef<"AiReportRun", 'Json'>
    readonly rawResponse: FieldRef<"AiReportRun", 'String'>
    readonly status: FieldRef<"AiReportRun", 'String'>
    readonly errorMsg: FieldRef<"AiReportRun", 'String'>
    readonly createdAt: FieldRef<"AiReportRun", 'DateTime'>
    readonly finishedAt: FieldRef<"AiReportRun", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiReportRun findUnique
   */
  export type AiReportRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportRun
     */
    select?: AiReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportRun
     */
    omit?: AiReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportRunInclude<ExtArgs> | null
    /**
     * Filter, which AiReportRun to fetch.
     */
    where: AiReportRunWhereUniqueInput
  }

  /**
   * AiReportRun findUniqueOrThrow
   */
  export type AiReportRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportRun
     */
    select?: AiReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportRun
     */
    omit?: AiReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportRunInclude<ExtArgs> | null
    /**
     * Filter, which AiReportRun to fetch.
     */
    where: AiReportRunWhereUniqueInput
  }

  /**
   * AiReportRun findFirst
   */
  export type AiReportRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportRun
     */
    select?: AiReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportRun
     */
    omit?: AiReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportRunInclude<ExtArgs> | null
    /**
     * Filter, which AiReportRun to fetch.
     */
    where?: AiReportRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiReportRuns to fetch.
     */
    orderBy?: AiReportRunOrderByWithRelationInput | AiReportRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiReportRuns.
     */
    cursor?: AiReportRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiReportRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiReportRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiReportRuns.
     */
    distinct?: AiReportRunScalarFieldEnum | AiReportRunScalarFieldEnum[]
  }

  /**
   * AiReportRun findFirstOrThrow
   */
  export type AiReportRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportRun
     */
    select?: AiReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportRun
     */
    omit?: AiReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportRunInclude<ExtArgs> | null
    /**
     * Filter, which AiReportRun to fetch.
     */
    where?: AiReportRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiReportRuns to fetch.
     */
    orderBy?: AiReportRunOrderByWithRelationInput | AiReportRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiReportRuns.
     */
    cursor?: AiReportRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiReportRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiReportRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiReportRuns.
     */
    distinct?: AiReportRunScalarFieldEnum | AiReportRunScalarFieldEnum[]
  }

  /**
   * AiReportRun findMany
   */
  export type AiReportRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportRun
     */
    select?: AiReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportRun
     */
    omit?: AiReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportRunInclude<ExtArgs> | null
    /**
     * Filter, which AiReportRuns to fetch.
     */
    where?: AiReportRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiReportRuns to fetch.
     */
    orderBy?: AiReportRunOrderByWithRelationInput | AiReportRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiReportRuns.
     */
    cursor?: AiReportRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiReportRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiReportRuns.
     */
    skip?: number
    distinct?: AiReportRunScalarFieldEnum | AiReportRunScalarFieldEnum[]
  }

  /**
   * AiReportRun create
   */
  export type AiReportRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportRun
     */
    select?: AiReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportRun
     */
    omit?: AiReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportRunInclude<ExtArgs> | null
    /**
     * The data needed to create a AiReportRun.
     */
    data: XOR<AiReportRunCreateInput, AiReportRunUncheckedCreateInput>
  }

  /**
   * AiReportRun createMany
   */
  export type AiReportRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiReportRuns.
     */
    data: AiReportRunCreateManyInput | AiReportRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiReportRun update
   */
  export type AiReportRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportRun
     */
    select?: AiReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportRun
     */
    omit?: AiReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportRunInclude<ExtArgs> | null
    /**
     * The data needed to update a AiReportRun.
     */
    data: XOR<AiReportRunUpdateInput, AiReportRunUncheckedUpdateInput>
    /**
     * Choose, which AiReportRun to update.
     */
    where: AiReportRunWhereUniqueInput
  }

  /**
   * AiReportRun updateMany
   */
  export type AiReportRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiReportRuns.
     */
    data: XOR<AiReportRunUpdateManyMutationInput, AiReportRunUncheckedUpdateManyInput>
    /**
     * Filter which AiReportRuns to update
     */
    where?: AiReportRunWhereInput
    /**
     * Limit how many AiReportRuns to update.
     */
    limit?: number
  }

  /**
   * AiReportRun upsert
   */
  export type AiReportRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportRun
     */
    select?: AiReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportRun
     */
    omit?: AiReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportRunInclude<ExtArgs> | null
    /**
     * The filter to search for the AiReportRun to update in case it exists.
     */
    where: AiReportRunWhereUniqueInput
    /**
     * In case the AiReportRun found by the `where` argument doesn't exist, create a new AiReportRun with this data.
     */
    create: XOR<AiReportRunCreateInput, AiReportRunUncheckedCreateInput>
    /**
     * In case the AiReportRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiReportRunUpdateInput, AiReportRunUncheckedUpdateInput>
  }

  /**
   * AiReportRun delete
   */
  export type AiReportRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportRun
     */
    select?: AiReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportRun
     */
    omit?: AiReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportRunInclude<ExtArgs> | null
    /**
     * Filter which AiReportRun to delete.
     */
    where: AiReportRunWhereUniqueInput
  }

  /**
   * AiReportRun deleteMany
   */
  export type AiReportRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiReportRuns to delete
     */
    where?: AiReportRunWhereInput
    /**
     * Limit how many AiReportRuns to delete.
     */
    limit?: number
  }

  /**
   * AiReportRun without action
   */
  export type AiReportRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiReportRun
     */
    select?: AiReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiReportRun
     */
    omit?: AiReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiReportRunInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ProductScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    name: 'name',
    imageUrl: 'imageUrl',
    weight: 'weight',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    fulfillment_sku: 'fulfillment_sku',
    item_weight_units: 'item_weight_units',
    item_weight_value: 'item_weight_value',
    shipstation_product_id: 'shipstation_product_id',
    upc: 'upc',
    warehouse_location: 'warehouse_location'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    shipstation_order_id: 'shipstation_order_id',
    shipstation_order_number: 'shipstation_order_number',
    customerId: 'customerId',
    customer_name: 'customer_name',
    order_status: 'order_status',
    order_key: 'order_key',
    order_date: 'order_date',
    payment_date: 'payment_date',
    ship_by_date: 'ship_by_date',
    shipping_price: 'shipping_price',
    tax_amount: 'tax_amount',
    discount_amount: 'discount_amount',
    shipping_amount_paid: 'shipping_amount_paid',
    shipping_tax: 'shipping_tax',
    total_price: 'total_price',
    gift: 'gift',
    gift_message: 'gift_message',
    gift_email: 'gift_email',
    requested_shipping_service: 'requested_shipping_service',
    carrier_code: 'carrier_code',
    service_code: 'service_code',
    package_code: 'package_code',
    confirmation: 'confirmation',
    tracking_number: 'tracking_number',
    shipped_date: 'shipped_date',
    warehouse_id: 'warehouse_id',
    customer_notes: 'customer_notes',
    internal_notes: 'internal_notes',
    last_sync_date: 'last_sync_date',
    notes: 'notes',
    created_at: 'created_at',
    updated_at: 'updated_at',
    marketplace: 'marketplace',
    amount_paid: 'amount_paid',
    order_weight_units: 'order_weight_units',
    order_weight_value: 'order_weight_value',
    payment_method: 'payment_method',
    shipstation_store_id: 'shipstation_store_id',
    tag_ids: 'tag_ids',
    dimensions_height: 'dimensions_height',
    dimensions_length: 'dimensions_length',
    dimensions_units: 'dimensions_units',
    dimensions_width: 'dimensions_width',
    insurance_insure_shipment: 'insurance_insure_shipment',
    insurance_insured_value: 'insurance_insured_value',
    insurance_provider: 'insurance_provider',
    internal_status: 'internal_status',
    is_voided: 'is_voided',
    marketplace_notified: 'marketplace_notified',
    void_date: 'void_date'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    shipstation_customer_id: 'shipstation_customer_id',
    company: 'company',
    street1: 'street1',
    street2: 'street2',
    street3: 'street3',
    city: 'city',
    state: 'state',
    postal_code: 'postal_code',
    country: 'country',
    country_code: 'country_code',
    customer_notes: 'customer_notes',
    created_at: 'created_at',
    updated_at: 'updated_at',
    address_verified_status: 'address_verified_status',
    is_residential: 'is_residential'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    quantity: 'quantity',
    unit_price: 'unit_price',
    print_settings: 'print_settings',
    created_at: 'created_at',
    updated_at: 'updated_at',
    shipstationLineItemKey: 'shipstationLineItemKey',
    productId: 'productId'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const PrintOrderTaskScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    marketplace_order_number: 'marketplace_order_number',
    customerId: 'customerId',
    custom_text: 'custom_text',
    quantity: 'quantity',
    color_1: 'color_1',
    color_2: 'color_2',
    ship_by_date: 'ship_by_date',
    status: 'status',
    stl_render_state: 'stl_render_state',
    stl_path: 'stl_path',
    render_retries: 'render_retries',
    needs_review: 'needs_review',
    review_reason: 'review_reason',
    created_at: 'created_at',
    updated_at: 'updated_at',
    orderItemId: 'orderItemId',
    taskIndex: 'taskIndex',
    productId: 'productId',
    shorthandProductName: 'shorthandProductName',
    annotation: 'annotation'
  };

  export type PrintOrderTaskScalarFieldEnum = (typeof PrintOrderTaskScalarFieldEnum)[keyof typeof PrintOrderTaskScalarFieldEnum]


  export const AmazonCustomizationFileScalarFieldEnum: {
    id: 'id',
    orderItemId: 'orderItemId',
    originalUrl: 'originalUrl',
    localFilePath: 'localFilePath',
    downloadStatus: 'downloadStatus',
    processingStatus: 'processingStatus',
    customText: 'customText',
    color1: 'color1',
    color2: 'color2',
    rawJsonData: 'rawJsonData',
    errorMessage: 'errorMessage',
    retryCount: 'retryCount',
    lastProcessedAt: 'lastProcessedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AmazonCustomizationFileScalarFieldEnum = (typeof AmazonCustomizationFileScalarFieldEnum)[keyof typeof AmazonCustomizationFileScalarFieldEnum]


  export const System_logsScalarFieldEnum: {
    id: 'id',
    message: 'message',
    level: 'level',
    timestamp: 'timestamp'
  };

  export type System_logsScalarFieldEnum = (typeof System_logsScalarFieldEnum)[keyof typeof System_logsScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    shipstation_tag_id: 'shipstation_tag_id',
    name: 'name',
    color_hex: 'color_hex',
    last_synced: 'last_synced'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const ScriptRunLogScalarFieldEnum: {
    id: 'id',
    scriptName: 'scriptName',
    runStartedAt: 'runStartedAt',
    runEndedAt: 'runEndedAt',
    status: 'status',
    errorMessage: 'errorMessage',
    errorStack: 'errorStack',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type ScriptRunLogScalarFieldEnum = (typeof ScriptRunLogScalarFieldEnum)[keyof typeof ScriptRunLogScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const SyncProgressScalarFieldEnum: {
    id: 'id',
    syncType: 'syncType',
    startTime: 'startTime',
    endTime: 'endTime',
    status: 'status',
    totalOrders: 'totalOrders',
    processedOrders: 'processedOrders',
    failedOrders: 'failedOrders',
    lastProcessedOrderId: 'lastProcessedOrderId',
    lastProcessedTimestamp: 'lastProcessedTimestamp',
    error: 'error',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SyncProgressScalarFieldEnum = (typeof SyncProgressScalarFieldEnum)[keyof typeof SyncProgressScalarFieldEnum]


  export const SyncMetricsScalarFieldEnum: {
    id: 'id',
    syncId: 'syncId',
    totalApiCalls: 'totalApiCalls',
    totalOrdersProcessed: 'totalOrdersProcessed',
    totalOrdersFailed: 'totalOrdersFailed',
    totalItemsProcessed: 'totalItemsProcessed',
    totalItemsFailed: 'totalItemsFailed',
    totalCustomersUpserted: 'totalCustomersUpserted',
    totalProductsUpserted: 'totalProductsUpserted',
    avgProcessingTimePerOrder: 'avgProcessingTimePerOrder',
    maxProcessingTimePerOrder: 'maxProcessingTimePerOrder',
    minProcessingTimePerOrder: 'minProcessingTimePerOrder',
    totalProcessingTime: 'totalProcessingTime',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt'
  };

  export type SyncMetricsScalarFieldEnum = (typeof SyncMetricsScalarFieldEnum)[keyof typeof SyncMetricsScalarFieldEnum]


  export const AiCallLogScalarFieldEnum: {
    id: 'id',
    scriptName: 'scriptName',
    orderId: 'orderId',
    orderNumber: 'orderNumber',
    marketplace: 'marketplace',
    aiProvider: 'aiProvider',
    modelUsed: 'modelUsed',
    promptSent: 'promptSent',
    rawResponse: 'rawResponse',
    processingTimeMs: 'processingTimeMs',
    success: 'success',
    errorMessage: 'errorMessage',
    tasksGenerated: 'tasksGenerated',
    needsReviewCount: 'needsReviewCount',
    createdAt: 'createdAt'
  };

  export type AiCallLogScalarFieldEnum = (typeof AiCallLogScalarFieldEnum)[keyof typeof AiCallLogScalarFieldEnum]


  export const MetricScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    tags: 'tags',
    timestamp: 'timestamp'
  };

  export type MetricScalarFieldEnum = (typeof MetricScalarFieldEnum)[keyof typeof MetricScalarFieldEnum]


  export const AiReportDefinitionScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    description: 'description',
    systemPrompt: 'systemPrompt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AiReportDefinitionScalarFieldEnum = (typeof AiReportDefinitionScalarFieldEnum)[keyof typeof AiReportDefinitionScalarFieldEnum]


  export const AiReportRunScalarFieldEnum: {
    id: 'id',
    reportId: 'reportId',
    inputJson: 'inputJson',
    outputJson: 'outputJson',
    rawResponse: 'rawResponse',
    status: 'status',
    errorMsg: 'errorMsg',
    createdAt: 'createdAt',
    finishedAt: 'finishedAt'
  };

  export type AiReportRunScalarFieldEnum = (typeof AiReportRunScalarFieldEnum)[keyof typeof AiReportRunScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const ProductOrderByRelevanceFieldEnum: {
    sku: 'sku',
    name: 'name',
    imageUrl: 'imageUrl',
    notes: 'notes',
    fulfillment_sku: 'fulfillment_sku',
    item_weight_units: 'item_weight_units',
    upc: 'upc',
    warehouse_location: 'warehouse_location'
  };

  export type ProductOrderByRelevanceFieldEnum = (typeof ProductOrderByRelevanceFieldEnum)[keyof typeof ProductOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const OrderOrderByRelevanceFieldEnum: {
    shipstation_order_id: 'shipstation_order_id',
    shipstation_order_number: 'shipstation_order_number',
    customer_name: 'customer_name',
    order_status: 'order_status',
    order_key: 'order_key',
    gift_message: 'gift_message',
    gift_email: 'gift_email',
    requested_shipping_service: 'requested_shipping_service',
    carrier_code: 'carrier_code',
    service_code: 'service_code',
    package_code: 'package_code',
    confirmation: 'confirmation',
    tracking_number: 'tracking_number',
    warehouse_id: 'warehouse_id',
    customer_notes: 'customer_notes',
    internal_notes: 'internal_notes',
    notes: 'notes',
    marketplace: 'marketplace',
    order_weight_units: 'order_weight_units',
    payment_method: 'payment_method',
    dimensions_units: 'dimensions_units',
    insurance_provider: 'insurance_provider'
  };

  export type OrderOrderByRelevanceFieldEnum = (typeof OrderOrderByRelevanceFieldEnum)[keyof typeof OrderOrderByRelevanceFieldEnum]


  export const CustomerOrderByRelevanceFieldEnum: {
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    shipstation_customer_id: 'shipstation_customer_id',
    company: 'company',
    street1: 'street1',
    street2: 'street2',
    street3: 'street3',
    city: 'city',
    state: 'state',
    postal_code: 'postal_code',
    country: 'country',
    country_code: 'country_code',
    customer_notes: 'customer_notes',
    address_verified_status: 'address_verified_status'
  };

  export type CustomerOrderByRelevanceFieldEnum = (typeof CustomerOrderByRelevanceFieldEnum)[keyof typeof CustomerOrderByRelevanceFieldEnum]


  export const OrderItemOrderByRelevanceFieldEnum: {
    shipstationLineItemKey: 'shipstationLineItemKey'
  };

  export type OrderItemOrderByRelevanceFieldEnum = (typeof OrderItemOrderByRelevanceFieldEnum)[keyof typeof OrderItemOrderByRelevanceFieldEnum]


  export const PrintOrderTaskOrderByRelevanceFieldEnum: {
    marketplace_order_number: 'marketplace_order_number',
    custom_text: 'custom_text',
    color_1: 'color_1',
    color_2: 'color_2',
    stl_path: 'stl_path',
    review_reason: 'review_reason',
    shorthandProductName: 'shorthandProductName',
    annotation: 'annotation'
  };

  export type PrintOrderTaskOrderByRelevanceFieldEnum = (typeof PrintOrderTaskOrderByRelevanceFieldEnum)[keyof typeof PrintOrderTaskOrderByRelevanceFieldEnum]


  export const AmazonCustomizationFileOrderByRelevanceFieldEnum: {
    originalUrl: 'originalUrl',
    localFilePath: 'localFilePath',
    downloadStatus: 'downloadStatus',
    processingStatus: 'processingStatus',
    customText: 'customText',
    color1: 'color1',
    color2: 'color2',
    errorMessage: 'errorMessage'
  };

  export type AmazonCustomizationFileOrderByRelevanceFieldEnum = (typeof AmazonCustomizationFileOrderByRelevanceFieldEnum)[keyof typeof AmazonCustomizationFileOrderByRelevanceFieldEnum]


  export const system_logsOrderByRelevanceFieldEnum: {
    message: 'message',
    level: 'level'
  };

  export type system_logsOrderByRelevanceFieldEnum = (typeof system_logsOrderByRelevanceFieldEnum)[keyof typeof system_logsOrderByRelevanceFieldEnum]


  export const TagOrderByRelevanceFieldEnum: {
    name: 'name',
    color_hex: 'color_hex'
  };

  export type TagOrderByRelevanceFieldEnum = (typeof TagOrderByRelevanceFieldEnum)[keyof typeof TagOrderByRelevanceFieldEnum]


  export const ScriptRunLogOrderByRelevanceFieldEnum: {
    scriptName: 'scriptName',
    status: 'status',
    errorMessage: 'errorMessage',
    errorStack: 'errorStack'
  };

  export type ScriptRunLogOrderByRelevanceFieldEnum = (typeof ScriptRunLogOrderByRelevanceFieldEnum)[keyof typeof ScriptRunLogOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    email: 'email',
    password: 'password',
    name: 'name',
    image: 'image'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const AccountOrderByRelevanceFieldEnum: {
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountOrderByRelevanceFieldEnum = (typeof AccountOrderByRelevanceFieldEnum)[keyof typeof AccountOrderByRelevanceFieldEnum]


  export const SessionOrderByRelevanceFieldEnum: {
    sessionToken: 'sessionToken'
  };

  export type SessionOrderByRelevanceFieldEnum = (typeof SessionOrderByRelevanceFieldEnum)[keyof typeof SessionOrderByRelevanceFieldEnum]


  export const VerificationTokenOrderByRelevanceFieldEnum: {
    identifier: 'identifier',
    token: 'token'
  };

  export type VerificationTokenOrderByRelevanceFieldEnum = (typeof VerificationTokenOrderByRelevanceFieldEnum)[keyof typeof VerificationTokenOrderByRelevanceFieldEnum]


  export const SyncProgressOrderByRelevanceFieldEnum: {
    id: 'id',
    syncType: 'syncType',
    status: 'status',
    lastProcessedOrderId: 'lastProcessedOrderId',
    error: 'error'
  };

  export type SyncProgressOrderByRelevanceFieldEnum = (typeof SyncProgressOrderByRelevanceFieldEnum)[keyof typeof SyncProgressOrderByRelevanceFieldEnum]


  export const SyncMetricsOrderByRelevanceFieldEnum: {
    id: 'id',
    syncId: 'syncId'
  };

  export type SyncMetricsOrderByRelevanceFieldEnum = (typeof SyncMetricsOrderByRelevanceFieldEnum)[keyof typeof SyncMetricsOrderByRelevanceFieldEnum]


  export const AiCallLogOrderByRelevanceFieldEnum: {
    id: 'id',
    scriptName: 'scriptName',
    orderNumber: 'orderNumber',
    marketplace: 'marketplace',
    aiProvider: 'aiProvider',
    modelUsed: 'modelUsed',
    promptSent: 'promptSent',
    rawResponse: 'rawResponse',
    errorMessage: 'errorMessage'
  };

  export type AiCallLogOrderByRelevanceFieldEnum = (typeof AiCallLogOrderByRelevanceFieldEnum)[keyof typeof AiCallLogOrderByRelevanceFieldEnum]


  export const MetricOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type MetricOrderByRelevanceFieldEnum = (typeof MetricOrderByRelevanceFieldEnum)[keyof typeof MetricOrderByRelevanceFieldEnum]


  export const AiReportDefinitionOrderByRelevanceFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    description: 'description',
    systemPrompt: 'systemPrompt'
  };

  export type AiReportDefinitionOrderByRelevanceFieldEnum = (typeof AiReportDefinitionOrderByRelevanceFieldEnum)[keyof typeof AiReportDefinitionOrderByRelevanceFieldEnum]


  export const AiReportRunOrderByRelevanceFieldEnum: {
    id: 'id',
    reportId: 'reportId',
    rawResponse: 'rawResponse',
    status: 'status',
    errorMsg: 'errorMsg'
  };

  export type AiReportRunOrderByRelevanceFieldEnum = (typeof AiReportRunOrderByRelevanceFieldEnum)[keyof typeof AiReportRunOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'InternalOrderStatus'
   */
  export type EnumInternalOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InternalOrderStatus'>
    


  /**
   * Reference to a field of type 'PrintTaskStatus'
   */
  export type EnumPrintTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrintTaskStatus'>
    


  /**
   * Reference to a field of type 'StlRenderStatus'
   */
  export type EnumStlRenderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StlRenderStatus'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    sku?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    imageUrl?: StringNullableFilter<"Product"> | string | null
    weight?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    fulfillment_sku?: StringNullableFilter<"Product"> | string | null
    item_weight_units?: StringNullableFilter<"Product"> | string | null
    item_weight_value?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    shipstation_product_id?: IntNullableFilter<"Product"> | number | null
    upc?: StringNullableFilter<"Product"> | string | null
    warehouse_location?: StringNullableFilter<"Product"> | string | null
    orderItems?: OrderItemListRelationFilter
    printTasks?: PrintOrderTaskListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrderInput | SortOrder
    name?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fulfillment_sku?: SortOrderInput | SortOrder
    item_weight_units?: SortOrderInput | SortOrder
    item_weight_value?: SortOrderInput | SortOrder
    shipstation_product_id?: SortOrderInput | SortOrder
    upc?: SortOrderInput | SortOrder
    warehouse_location?: SortOrderInput | SortOrder
    orderItems?: OrderItemOrderByRelationAggregateInput
    printTasks?: PrintOrderTaskOrderByRelationAggregateInput
    _relevance?: ProductOrderByRelevanceInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sku?: string
    shipstation_product_id?: number
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    imageUrl?: StringNullableFilter<"Product"> | string | null
    weight?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    fulfillment_sku?: StringNullableFilter<"Product"> | string | null
    item_weight_units?: StringNullableFilter<"Product"> | string | null
    item_weight_value?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    upc?: StringNullableFilter<"Product"> | string | null
    warehouse_location?: StringNullableFilter<"Product"> | string | null
    orderItems?: OrderItemListRelationFilter
    printTasks?: PrintOrderTaskListRelationFilter
  }, "id" | "sku" | "shipstation_product_id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrderInput | SortOrder
    name?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fulfillment_sku?: SortOrderInput | SortOrder
    item_weight_units?: SortOrderInput | SortOrder
    item_weight_value?: SortOrderInput | SortOrder
    shipstation_product_id?: SortOrderInput | SortOrder
    upc?: SortOrderInput | SortOrder
    warehouse_location?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    sku?: StringNullableWithAggregatesFilter<"Product"> | string | null
    name?: StringWithAggregatesFilter<"Product"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    weight?: DecimalNullableWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    fulfillment_sku?: StringNullableWithAggregatesFilter<"Product"> | string | null
    item_weight_units?: StringNullableWithAggregatesFilter<"Product"> | string | null
    item_weight_value?: DecimalNullableWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    shipstation_product_id?: IntNullableWithAggregatesFilter<"Product"> | number | null
    upc?: StringNullableWithAggregatesFilter<"Product"> | string | null
    warehouse_location?: StringNullableWithAggregatesFilter<"Product"> | string | null
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: IntFilter<"Order"> | number
    shipstation_order_id?: StringNullableFilter<"Order"> | string | null
    shipstation_order_number?: StringNullableFilter<"Order"> | string | null
    customerId?: IntNullableFilter<"Order"> | number | null
    customer_name?: StringNullableFilter<"Order"> | string | null
    order_status?: StringFilter<"Order"> | string
    order_key?: StringNullableFilter<"Order"> | string | null
    order_date?: DateTimeNullableFilter<"Order"> | Date | string | null
    payment_date?: DateTimeNullableFilter<"Order"> | Date | string | null
    ship_by_date?: DateTimeNullableFilter<"Order"> | Date | string | null
    shipping_price?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    tax_amount?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    discount_amount?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    shipping_tax?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    total_price?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    gift?: BoolFilter<"Order"> | boolean
    gift_message?: StringNullableFilter<"Order"> | string | null
    gift_email?: StringNullableFilter<"Order"> | string | null
    requested_shipping_service?: StringNullableFilter<"Order"> | string | null
    carrier_code?: StringNullableFilter<"Order"> | string | null
    service_code?: StringNullableFilter<"Order"> | string | null
    package_code?: StringNullableFilter<"Order"> | string | null
    confirmation?: StringNullableFilter<"Order"> | string | null
    tracking_number?: StringNullableFilter<"Order"> | string | null
    shipped_date?: DateTimeNullableFilter<"Order"> | Date | string | null
    warehouse_id?: StringNullableFilter<"Order"> | string | null
    customer_notes?: StringNullableFilter<"Order"> | string | null
    internal_notes?: StringNullableFilter<"Order"> | string | null
    last_sync_date?: DateTimeNullableFilter<"Order"> | Date | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    created_at?: DateTimeFilter<"Order"> | Date | string
    updated_at?: DateTimeNullableFilter<"Order"> | Date | string | null
    marketplace?: StringNullableFilter<"Order"> | string | null
    amount_paid?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    order_weight_units?: StringNullableFilter<"Order"> | string | null
    order_weight_value?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    payment_method?: StringNullableFilter<"Order"> | string | null
    shipstation_store_id?: IntNullableFilter<"Order"> | number | null
    tag_ids?: JsonNullableFilter<"Order">
    dimensions_height?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    dimensions_length?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    dimensions_units?: StringNullableFilter<"Order"> | string | null
    dimensions_width?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: BoolNullableFilter<"Order"> | boolean | null
    insurance_insured_value?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    insurance_provider?: StringNullableFilter<"Order"> | string | null
    internal_status?: EnumInternalOrderStatusFilter<"Order"> | $Enums.InternalOrderStatus
    is_voided?: BoolNullableFilter<"Order"> | boolean | null
    marketplace_notified?: BoolFilter<"Order"> | boolean
    void_date?: DateTimeNullableFilter<"Order"> | Date | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    items?: OrderItemListRelationFilter
    printTasks?: PrintOrderTaskListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    shipstation_order_id?: SortOrderInput | SortOrder
    shipstation_order_number?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customer_name?: SortOrderInput | SortOrder
    order_status?: SortOrder
    order_key?: SortOrderInput | SortOrder
    order_date?: SortOrderInput | SortOrder
    payment_date?: SortOrderInput | SortOrder
    ship_by_date?: SortOrderInput | SortOrder
    shipping_price?: SortOrderInput | SortOrder
    tax_amount?: SortOrderInput | SortOrder
    discount_amount?: SortOrderInput | SortOrder
    shipping_amount_paid?: SortOrderInput | SortOrder
    shipping_tax?: SortOrderInput | SortOrder
    total_price?: SortOrder
    gift?: SortOrder
    gift_message?: SortOrderInput | SortOrder
    gift_email?: SortOrderInput | SortOrder
    requested_shipping_service?: SortOrderInput | SortOrder
    carrier_code?: SortOrderInput | SortOrder
    service_code?: SortOrderInput | SortOrder
    package_code?: SortOrderInput | SortOrder
    confirmation?: SortOrderInput | SortOrder
    tracking_number?: SortOrderInput | SortOrder
    shipped_date?: SortOrderInput | SortOrder
    warehouse_id?: SortOrderInput | SortOrder
    customer_notes?: SortOrderInput | SortOrder
    internal_notes?: SortOrderInput | SortOrder
    last_sync_date?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    marketplace?: SortOrderInput | SortOrder
    amount_paid?: SortOrderInput | SortOrder
    order_weight_units?: SortOrderInput | SortOrder
    order_weight_value?: SortOrderInput | SortOrder
    payment_method?: SortOrderInput | SortOrder
    shipstation_store_id?: SortOrderInput | SortOrder
    tag_ids?: SortOrderInput | SortOrder
    dimensions_height?: SortOrderInput | SortOrder
    dimensions_length?: SortOrderInput | SortOrder
    dimensions_units?: SortOrderInput | SortOrder
    dimensions_width?: SortOrderInput | SortOrder
    insurance_insure_shipment?: SortOrderInput | SortOrder
    insurance_insured_value?: SortOrderInput | SortOrder
    insurance_provider?: SortOrderInput | SortOrder
    internal_status?: SortOrder
    is_voided?: SortOrderInput | SortOrder
    marketplace_notified?: SortOrder
    void_date?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
    printTasks?: PrintOrderTaskOrderByRelationAggregateInput
    _relevance?: OrderOrderByRelevanceInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    shipstation_order_id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    shipstation_order_number?: StringNullableFilter<"Order"> | string | null
    customerId?: IntNullableFilter<"Order"> | number | null
    customer_name?: StringNullableFilter<"Order"> | string | null
    order_status?: StringFilter<"Order"> | string
    order_key?: StringNullableFilter<"Order"> | string | null
    order_date?: DateTimeNullableFilter<"Order"> | Date | string | null
    payment_date?: DateTimeNullableFilter<"Order"> | Date | string | null
    ship_by_date?: DateTimeNullableFilter<"Order"> | Date | string | null
    shipping_price?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    tax_amount?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    discount_amount?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    shipping_tax?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    total_price?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    gift?: BoolFilter<"Order"> | boolean
    gift_message?: StringNullableFilter<"Order"> | string | null
    gift_email?: StringNullableFilter<"Order"> | string | null
    requested_shipping_service?: StringNullableFilter<"Order"> | string | null
    carrier_code?: StringNullableFilter<"Order"> | string | null
    service_code?: StringNullableFilter<"Order"> | string | null
    package_code?: StringNullableFilter<"Order"> | string | null
    confirmation?: StringNullableFilter<"Order"> | string | null
    tracking_number?: StringNullableFilter<"Order"> | string | null
    shipped_date?: DateTimeNullableFilter<"Order"> | Date | string | null
    warehouse_id?: StringNullableFilter<"Order"> | string | null
    customer_notes?: StringNullableFilter<"Order"> | string | null
    internal_notes?: StringNullableFilter<"Order"> | string | null
    last_sync_date?: DateTimeNullableFilter<"Order"> | Date | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    created_at?: DateTimeFilter<"Order"> | Date | string
    updated_at?: DateTimeNullableFilter<"Order"> | Date | string | null
    marketplace?: StringNullableFilter<"Order"> | string | null
    amount_paid?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    order_weight_units?: StringNullableFilter<"Order"> | string | null
    order_weight_value?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    payment_method?: StringNullableFilter<"Order"> | string | null
    shipstation_store_id?: IntNullableFilter<"Order"> | number | null
    tag_ids?: JsonNullableFilter<"Order">
    dimensions_height?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    dimensions_length?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    dimensions_units?: StringNullableFilter<"Order"> | string | null
    dimensions_width?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: BoolNullableFilter<"Order"> | boolean | null
    insurance_insured_value?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    insurance_provider?: StringNullableFilter<"Order"> | string | null
    internal_status?: EnumInternalOrderStatusFilter<"Order"> | $Enums.InternalOrderStatus
    is_voided?: BoolNullableFilter<"Order"> | boolean | null
    marketplace_notified?: BoolFilter<"Order"> | boolean
    void_date?: DateTimeNullableFilter<"Order"> | Date | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    items?: OrderItemListRelationFilter
    printTasks?: PrintOrderTaskListRelationFilter
  }, "id" | "shipstation_order_id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    shipstation_order_id?: SortOrderInput | SortOrder
    shipstation_order_number?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customer_name?: SortOrderInput | SortOrder
    order_status?: SortOrder
    order_key?: SortOrderInput | SortOrder
    order_date?: SortOrderInput | SortOrder
    payment_date?: SortOrderInput | SortOrder
    ship_by_date?: SortOrderInput | SortOrder
    shipping_price?: SortOrderInput | SortOrder
    tax_amount?: SortOrderInput | SortOrder
    discount_amount?: SortOrderInput | SortOrder
    shipping_amount_paid?: SortOrderInput | SortOrder
    shipping_tax?: SortOrderInput | SortOrder
    total_price?: SortOrder
    gift?: SortOrder
    gift_message?: SortOrderInput | SortOrder
    gift_email?: SortOrderInput | SortOrder
    requested_shipping_service?: SortOrderInput | SortOrder
    carrier_code?: SortOrderInput | SortOrder
    service_code?: SortOrderInput | SortOrder
    package_code?: SortOrderInput | SortOrder
    confirmation?: SortOrderInput | SortOrder
    tracking_number?: SortOrderInput | SortOrder
    shipped_date?: SortOrderInput | SortOrder
    warehouse_id?: SortOrderInput | SortOrder
    customer_notes?: SortOrderInput | SortOrder
    internal_notes?: SortOrderInput | SortOrder
    last_sync_date?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    marketplace?: SortOrderInput | SortOrder
    amount_paid?: SortOrderInput | SortOrder
    order_weight_units?: SortOrderInput | SortOrder
    order_weight_value?: SortOrderInput | SortOrder
    payment_method?: SortOrderInput | SortOrder
    shipstation_store_id?: SortOrderInput | SortOrder
    tag_ids?: SortOrderInput | SortOrder
    dimensions_height?: SortOrderInput | SortOrder
    dimensions_length?: SortOrderInput | SortOrder
    dimensions_units?: SortOrderInput | SortOrder
    dimensions_width?: SortOrderInput | SortOrder
    insurance_insure_shipment?: SortOrderInput | SortOrder
    insurance_insured_value?: SortOrderInput | SortOrder
    insurance_provider?: SortOrderInput | SortOrder
    internal_status?: SortOrder
    is_voided?: SortOrderInput | SortOrder
    marketplace_notified?: SortOrder
    void_date?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Order"> | number
    shipstation_order_id?: StringNullableWithAggregatesFilter<"Order"> | string | null
    shipstation_order_number?: StringNullableWithAggregatesFilter<"Order"> | string | null
    customerId?: IntNullableWithAggregatesFilter<"Order"> | number | null
    customer_name?: StringNullableWithAggregatesFilter<"Order"> | string | null
    order_status?: StringWithAggregatesFilter<"Order"> | string
    order_key?: StringNullableWithAggregatesFilter<"Order"> | string | null
    order_date?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    payment_date?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    ship_by_date?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    shipping_price?: DecimalNullableWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    tax_amount?: DecimalNullableWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    discount_amount?: DecimalNullableWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: DecimalNullableWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    shipping_tax?: DecimalNullableWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    total_price?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    gift?: BoolWithAggregatesFilter<"Order"> | boolean
    gift_message?: StringNullableWithAggregatesFilter<"Order"> | string | null
    gift_email?: StringNullableWithAggregatesFilter<"Order"> | string | null
    requested_shipping_service?: StringNullableWithAggregatesFilter<"Order"> | string | null
    carrier_code?: StringNullableWithAggregatesFilter<"Order"> | string | null
    service_code?: StringNullableWithAggregatesFilter<"Order"> | string | null
    package_code?: StringNullableWithAggregatesFilter<"Order"> | string | null
    confirmation?: StringNullableWithAggregatesFilter<"Order"> | string | null
    tracking_number?: StringNullableWithAggregatesFilter<"Order"> | string | null
    shipped_date?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    warehouse_id?: StringNullableWithAggregatesFilter<"Order"> | string | null
    customer_notes?: StringNullableWithAggregatesFilter<"Order"> | string | null
    internal_notes?: StringNullableWithAggregatesFilter<"Order"> | string | null
    last_sync_date?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Order"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    marketplace?: StringNullableWithAggregatesFilter<"Order"> | string | null
    amount_paid?: DecimalNullableWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    order_weight_units?: StringNullableWithAggregatesFilter<"Order"> | string | null
    order_weight_value?: DecimalNullableWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    payment_method?: StringNullableWithAggregatesFilter<"Order"> | string | null
    shipstation_store_id?: IntNullableWithAggregatesFilter<"Order"> | number | null
    tag_ids?: JsonNullableWithAggregatesFilter<"Order">
    dimensions_height?: DecimalNullableWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    dimensions_length?: DecimalNullableWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    dimensions_units?: StringNullableWithAggregatesFilter<"Order"> | string | null
    dimensions_width?: DecimalNullableWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: BoolNullableWithAggregatesFilter<"Order"> | boolean | null
    insurance_insured_value?: DecimalNullableWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    insurance_provider?: StringNullableWithAggregatesFilter<"Order"> | string | null
    internal_status?: EnumInternalOrderStatusWithAggregatesFilter<"Order"> | $Enums.InternalOrderStatus
    is_voided?: BoolNullableWithAggregatesFilter<"Order"> | boolean | null
    marketplace_notified?: BoolWithAggregatesFilter<"Order"> | boolean
    void_date?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: IntFilter<"Customer"> | number
    name?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    shipstation_customer_id?: StringNullableFilter<"Customer"> | string | null
    company?: StringNullableFilter<"Customer"> | string | null
    street1?: StringNullableFilter<"Customer"> | string | null
    street2?: StringNullableFilter<"Customer"> | string | null
    street3?: StringNullableFilter<"Customer"> | string | null
    city?: StringNullableFilter<"Customer"> | string | null
    state?: StringNullableFilter<"Customer"> | string | null
    postal_code?: StringNullableFilter<"Customer"> | string | null
    country?: StringNullableFilter<"Customer"> | string | null
    country_code?: StringNullableFilter<"Customer"> | string | null
    customer_notes?: StringNullableFilter<"Customer"> | string | null
    created_at?: DateTimeFilter<"Customer"> | Date | string
    updated_at?: DateTimeNullableFilter<"Customer"> | Date | string | null
    address_verified_status?: StringNullableFilter<"Customer"> | string | null
    is_residential?: BoolNullableFilter<"Customer"> | boolean | null
    orders?: OrderListRelationFilter
    printTasks?: PrintOrderTaskListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    shipstation_customer_id?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    street1?: SortOrderInput | SortOrder
    street2?: SortOrderInput | SortOrder
    street3?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    country_code?: SortOrderInput | SortOrder
    customer_notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    address_verified_status?: SortOrderInput | SortOrder
    is_residential?: SortOrderInput | SortOrder
    orders?: OrderOrderByRelationAggregateInput
    printTasks?: PrintOrderTaskOrderByRelationAggregateInput
    _relevance?: CustomerOrderByRelevanceInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    shipstation_customer_id?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    company?: StringNullableFilter<"Customer"> | string | null
    street1?: StringNullableFilter<"Customer"> | string | null
    street2?: StringNullableFilter<"Customer"> | string | null
    street3?: StringNullableFilter<"Customer"> | string | null
    city?: StringNullableFilter<"Customer"> | string | null
    state?: StringNullableFilter<"Customer"> | string | null
    postal_code?: StringNullableFilter<"Customer"> | string | null
    country?: StringNullableFilter<"Customer"> | string | null
    country_code?: StringNullableFilter<"Customer"> | string | null
    customer_notes?: StringNullableFilter<"Customer"> | string | null
    created_at?: DateTimeFilter<"Customer"> | Date | string
    updated_at?: DateTimeNullableFilter<"Customer"> | Date | string | null
    address_verified_status?: StringNullableFilter<"Customer"> | string | null
    is_residential?: BoolNullableFilter<"Customer"> | boolean | null
    orders?: OrderListRelationFilter
    printTasks?: PrintOrderTaskListRelationFilter
  }, "id" | "email" | "shipstation_customer_id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    shipstation_customer_id?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    street1?: SortOrderInput | SortOrder
    street2?: SortOrderInput | SortOrder
    street3?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    country_code?: SortOrderInput | SortOrder
    customer_notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    address_verified_status?: SortOrderInput | SortOrder
    is_residential?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customer"> | number
    name?: StringWithAggregatesFilter<"Customer"> | string
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    shipstation_customer_id?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    company?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    street1?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    street2?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    street3?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    city?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    state?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    postal_code?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    country?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    country_code?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    customer_notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    address_verified_status?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    is_residential?: BoolNullableWithAggregatesFilter<"Customer"> | boolean | null
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    unit_price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    print_settings?: JsonNullableFilter<"OrderItem">
    created_at?: DateTimeFilter<"OrderItem"> | Date | string
    updated_at?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    shipstationLineItemKey?: StringNullableFilter<"OrderItem"> | string | null
    productId?: IntFilter<"OrderItem"> | number
    amazonCustomizationFiles?: XOR<AmazonCustomizationFileNullableScalarRelationFilter, AmazonCustomizationFileWhereInput> | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    printTasks?: PrintOrderTaskListRelationFilter
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    print_settings?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    shipstationLineItemKey?: SortOrderInput | SortOrder
    productId?: SortOrder
    amazonCustomizationFiles?: AmazonCustomizationFileOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    printTasks?: PrintOrderTaskOrderByRelationAggregateInput
    _relevance?: OrderItemOrderByRelevanceInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    shipstationLineItemKey?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    unit_price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    print_settings?: JsonNullableFilter<"OrderItem">
    created_at?: DateTimeFilter<"OrderItem"> | Date | string
    updated_at?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    productId?: IntFilter<"OrderItem"> | number
    amazonCustomizationFiles?: XOR<AmazonCustomizationFileNullableScalarRelationFilter, AmazonCustomizationFileWhereInput> | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    printTasks?: PrintOrderTaskListRelationFilter
  }, "id" | "shipstationLineItemKey">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    print_settings?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    shipstationLineItemKey?: SortOrderInput | SortOrder
    productId?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderItem"> | number
    orderId?: IntWithAggregatesFilter<"OrderItem"> | number
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    unit_price?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    print_settings?: JsonNullableWithAggregatesFilter<"OrderItem">
    created_at?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"OrderItem"> | Date | string | null
    shipstationLineItemKey?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    productId?: IntWithAggregatesFilter<"OrderItem"> | number
  }

  export type PrintOrderTaskWhereInput = {
    AND?: PrintOrderTaskWhereInput | PrintOrderTaskWhereInput[]
    OR?: PrintOrderTaskWhereInput[]
    NOT?: PrintOrderTaskWhereInput | PrintOrderTaskWhereInput[]
    id?: IntFilter<"PrintOrderTask"> | number
    orderId?: IntFilter<"PrintOrderTask"> | number
    marketplace_order_number?: StringNullableFilter<"PrintOrderTask"> | string | null
    customerId?: IntNullableFilter<"PrintOrderTask"> | number | null
    custom_text?: StringNullableFilter<"PrintOrderTask"> | string | null
    quantity?: IntFilter<"PrintOrderTask"> | number
    color_1?: StringNullableFilter<"PrintOrderTask"> | string | null
    color_2?: StringNullableFilter<"PrintOrderTask"> | string | null
    ship_by_date?: DateTimeNullableFilter<"PrintOrderTask"> | Date | string | null
    status?: EnumPrintTaskStatusFilter<"PrintOrderTask"> | $Enums.PrintTaskStatus
    stl_render_state?: EnumStlRenderStatusFilter<"PrintOrderTask"> | $Enums.StlRenderStatus
    stl_path?: StringNullableFilter<"PrintOrderTask"> | string | null
    render_retries?: IntFilter<"PrintOrderTask"> | number
    needs_review?: BoolFilter<"PrintOrderTask"> | boolean
    review_reason?: StringNullableFilter<"PrintOrderTask"> | string | null
    created_at?: DateTimeFilter<"PrintOrderTask"> | Date | string
    updated_at?: DateTimeNullableFilter<"PrintOrderTask"> | Date | string | null
    orderItemId?: IntFilter<"PrintOrderTask"> | number
    taskIndex?: IntFilter<"PrintOrderTask"> | number
    productId?: IntFilter<"PrintOrderTask"> | number
    shorthandProductName?: StringNullableFilter<"PrintOrderTask"> | string | null
    annotation?: StringNullableFilter<"PrintOrderTask"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type PrintOrderTaskOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    marketplace_order_number?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    custom_text?: SortOrderInput | SortOrder
    quantity?: SortOrder
    color_1?: SortOrderInput | SortOrder
    color_2?: SortOrderInput | SortOrder
    ship_by_date?: SortOrderInput | SortOrder
    status?: SortOrder
    stl_render_state?: SortOrder
    stl_path?: SortOrderInput | SortOrder
    render_retries?: SortOrder
    needs_review?: SortOrder
    review_reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    orderItemId?: SortOrder
    taskIndex?: SortOrder
    productId?: SortOrder
    shorthandProductName?: SortOrderInput | SortOrder
    annotation?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    orderItem?: OrderItemOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    _relevance?: PrintOrderTaskOrderByRelevanceInput
  }

  export type PrintOrderTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderItemId_taskIndex?: PrintOrderTaskOrderItemIdTaskIndexCompoundUniqueInput
    AND?: PrintOrderTaskWhereInput | PrintOrderTaskWhereInput[]
    OR?: PrintOrderTaskWhereInput[]
    NOT?: PrintOrderTaskWhereInput | PrintOrderTaskWhereInput[]
    orderId?: IntFilter<"PrintOrderTask"> | number
    marketplace_order_number?: StringNullableFilter<"PrintOrderTask"> | string | null
    customerId?: IntNullableFilter<"PrintOrderTask"> | number | null
    custom_text?: StringNullableFilter<"PrintOrderTask"> | string | null
    quantity?: IntFilter<"PrintOrderTask"> | number
    color_1?: StringNullableFilter<"PrintOrderTask"> | string | null
    color_2?: StringNullableFilter<"PrintOrderTask"> | string | null
    ship_by_date?: DateTimeNullableFilter<"PrintOrderTask"> | Date | string | null
    status?: EnumPrintTaskStatusFilter<"PrintOrderTask"> | $Enums.PrintTaskStatus
    stl_render_state?: EnumStlRenderStatusFilter<"PrintOrderTask"> | $Enums.StlRenderStatus
    stl_path?: StringNullableFilter<"PrintOrderTask"> | string | null
    render_retries?: IntFilter<"PrintOrderTask"> | number
    needs_review?: BoolFilter<"PrintOrderTask"> | boolean
    review_reason?: StringNullableFilter<"PrintOrderTask"> | string | null
    created_at?: DateTimeFilter<"PrintOrderTask"> | Date | string
    updated_at?: DateTimeNullableFilter<"PrintOrderTask"> | Date | string | null
    orderItemId?: IntFilter<"PrintOrderTask"> | number
    taskIndex?: IntFilter<"PrintOrderTask"> | number
    productId?: IntFilter<"PrintOrderTask"> | number
    shorthandProductName?: StringNullableFilter<"PrintOrderTask"> | string | null
    annotation?: StringNullableFilter<"PrintOrderTask"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "orderItemId_taskIndex">

  export type PrintOrderTaskOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    marketplace_order_number?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    custom_text?: SortOrderInput | SortOrder
    quantity?: SortOrder
    color_1?: SortOrderInput | SortOrder
    color_2?: SortOrderInput | SortOrder
    ship_by_date?: SortOrderInput | SortOrder
    status?: SortOrder
    stl_render_state?: SortOrder
    stl_path?: SortOrderInput | SortOrder
    render_retries?: SortOrder
    needs_review?: SortOrder
    review_reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    orderItemId?: SortOrder
    taskIndex?: SortOrder
    productId?: SortOrder
    shorthandProductName?: SortOrderInput | SortOrder
    annotation?: SortOrderInput | SortOrder
    _count?: PrintOrderTaskCountOrderByAggregateInput
    _avg?: PrintOrderTaskAvgOrderByAggregateInput
    _max?: PrintOrderTaskMaxOrderByAggregateInput
    _min?: PrintOrderTaskMinOrderByAggregateInput
    _sum?: PrintOrderTaskSumOrderByAggregateInput
  }

  export type PrintOrderTaskScalarWhereWithAggregatesInput = {
    AND?: PrintOrderTaskScalarWhereWithAggregatesInput | PrintOrderTaskScalarWhereWithAggregatesInput[]
    OR?: PrintOrderTaskScalarWhereWithAggregatesInput[]
    NOT?: PrintOrderTaskScalarWhereWithAggregatesInput | PrintOrderTaskScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PrintOrderTask"> | number
    orderId?: IntWithAggregatesFilter<"PrintOrderTask"> | number
    marketplace_order_number?: StringNullableWithAggregatesFilter<"PrintOrderTask"> | string | null
    customerId?: IntNullableWithAggregatesFilter<"PrintOrderTask"> | number | null
    custom_text?: StringNullableWithAggregatesFilter<"PrintOrderTask"> | string | null
    quantity?: IntWithAggregatesFilter<"PrintOrderTask"> | number
    color_1?: StringNullableWithAggregatesFilter<"PrintOrderTask"> | string | null
    color_2?: StringNullableWithAggregatesFilter<"PrintOrderTask"> | string | null
    ship_by_date?: DateTimeNullableWithAggregatesFilter<"PrintOrderTask"> | Date | string | null
    status?: EnumPrintTaskStatusWithAggregatesFilter<"PrintOrderTask"> | $Enums.PrintTaskStatus
    stl_render_state?: EnumStlRenderStatusWithAggregatesFilter<"PrintOrderTask"> | $Enums.StlRenderStatus
    stl_path?: StringNullableWithAggregatesFilter<"PrintOrderTask"> | string | null
    render_retries?: IntWithAggregatesFilter<"PrintOrderTask"> | number
    needs_review?: BoolWithAggregatesFilter<"PrintOrderTask"> | boolean
    review_reason?: StringNullableWithAggregatesFilter<"PrintOrderTask"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"PrintOrderTask"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"PrintOrderTask"> | Date | string | null
    orderItemId?: IntWithAggregatesFilter<"PrintOrderTask"> | number
    taskIndex?: IntWithAggregatesFilter<"PrintOrderTask"> | number
    productId?: IntWithAggregatesFilter<"PrintOrderTask"> | number
    shorthandProductName?: StringNullableWithAggregatesFilter<"PrintOrderTask"> | string | null
    annotation?: StringNullableWithAggregatesFilter<"PrintOrderTask"> | string | null
  }

  export type AmazonCustomizationFileWhereInput = {
    AND?: AmazonCustomizationFileWhereInput | AmazonCustomizationFileWhereInput[]
    OR?: AmazonCustomizationFileWhereInput[]
    NOT?: AmazonCustomizationFileWhereInput | AmazonCustomizationFileWhereInput[]
    id?: IntFilter<"AmazonCustomizationFile"> | number
    orderItemId?: IntFilter<"AmazonCustomizationFile"> | number
    originalUrl?: StringFilter<"AmazonCustomizationFile"> | string
    localFilePath?: StringNullableFilter<"AmazonCustomizationFile"> | string | null
    downloadStatus?: StringFilter<"AmazonCustomizationFile"> | string
    processingStatus?: StringFilter<"AmazonCustomizationFile"> | string
    customText?: StringNullableFilter<"AmazonCustomizationFile"> | string | null
    color1?: StringNullableFilter<"AmazonCustomizationFile"> | string | null
    color2?: StringNullableFilter<"AmazonCustomizationFile"> | string | null
    rawJsonData?: JsonNullableFilter<"AmazonCustomizationFile">
    errorMessage?: StringNullableFilter<"AmazonCustomizationFile"> | string | null
    retryCount?: IntFilter<"AmazonCustomizationFile"> | number
    lastProcessedAt?: DateTimeNullableFilter<"AmazonCustomizationFile"> | Date | string | null
    createdAt?: DateTimeFilter<"AmazonCustomizationFile"> | Date | string
    updatedAt?: DateTimeFilter<"AmazonCustomizationFile"> | Date | string
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
  }

  export type AmazonCustomizationFileOrderByWithRelationInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    originalUrl?: SortOrder
    localFilePath?: SortOrderInput | SortOrder
    downloadStatus?: SortOrder
    processingStatus?: SortOrder
    customText?: SortOrderInput | SortOrder
    color1?: SortOrderInput | SortOrder
    color2?: SortOrderInput | SortOrder
    rawJsonData?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    lastProcessedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderItem?: OrderItemOrderByWithRelationInput
    _relevance?: AmazonCustomizationFileOrderByRelevanceInput
  }

  export type AmazonCustomizationFileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderItemId?: number
    AND?: AmazonCustomizationFileWhereInput | AmazonCustomizationFileWhereInput[]
    OR?: AmazonCustomizationFileWhereInput[]
    NOT?: AmazonCustomizationFileWhereInput | AmazonCustomizationFileWhereInput[]
    originalUrl?: StringFilter<"AmazonCustomizationFile"> | string
    localFilePath?: StringNullableFilter<"AmazonCustomizationFile"> | string | null
    downloadStatus?: StringFilter<"AmazonCustomizationFile"> | string
    processingStatus?: StringFilter<"AmazonCustomizationFile"> | string
    customText?: StringNullableFilter<"AmazonCustomizationFile"> | string | null
    color1?: StringNullableFilter<"AmazonCustomizationFile"> | string | null
    color2?: StringNullableFilter<"AmazonCustomizationFile"> | string | null
    rawJsonData?: JsonNullableFilter<"AmazonCustomizationFile">
    errorMessage?: StringNullableFilter<"AmazonCustomizationFile"> | string | null
    retryCount?: IntFilter<"AmazonCustomizationFile"> | number
    lastProcessedAt?: DateTimeNullableFilter<"AmazonCustomizationFile"> | Date | string | null
    createdAt?: DateTimeFilter<"AmazonCustomizationFile"> | Date | string
    updatedAt?: DateTimeFilter<"AmazonCustomizationFile"> | Date | string
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
  }, "id" | "orderItemId">

  export type AmazonCustomizationFileOrderByWithAggregationInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    originalUrl?: SortOrder
    localFilePath?: SortOrderInput | SortOrder
    downloadStatus?: SortOrder
    processingStatus?: SortOrder
    customText?: SortOrderInput | SortOrder
    color1?: SortOrderInput | SortOrder
    color2?: SortOrderInput | SortOrder
    rawJsonData?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    lastProcessedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AmazonCustomizationFileCountOrderByAggregateInput
    _avg?: AmazonCustomizationFileAvgOrderByAggregateInput
    _max?: AmazonCustomizationFileMaxOrderByAggregateInput
    _min?: AmazonCustomizationFileMinOrderByAggregateInput
    _sum?: AmazonCustomizationFileSumOrderByAggregateInput
  }

  export type AmazonCustomizationFileScalarWhereWithAggregatesInput = {
    AND?: AmazonCustomizationFileScalarWhereWithAggregatesInput | AmazonCustomizationFileScalarWhereWithAggregatesInput[]
    OR?: AmazonCustomizationFileScalarWhereWithAggregatesInput[]
    NOT?: AmazonCustomizationFileScalarWhereWithAggregatesInput | AmazonCustomizationFileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AmazonCustomizationFile"> | number
    orderItemId?: IntWithAggregatesFilter<"AmazonCustomizationFile"> | number
    originalUrl?: StringWithAggregatesFilter<"AmazonCustomizationFile"> | string
    localFilePath?: StringNullableWithAggregatesFilter<"AmazonCustomizationFile"> | string | null
    downloadStatus?: StringWithAggregatesFilter<"AmazonCustomizationFile"> | string
    processingStatus?: StringWithAggregatesFilter<"AmazonCustomizationFile"> | string
    customText?: StringNullableWithAggregatesFilter<"AmazonCustomizationFile"> | string | null
    color1?: StringNullableWithAggregatesFilter<"AmazonCustomizationFile"> | string | null
    color2?: StringNullableWithAggregatesFilter<"AmazonCustomizationFile"> | string | null
    rawJsonData?: JsonNullableWithAggregatesFilter<"AmazonCustomizationFile">
    errorMessage?: StringNullableWithAggregatesFilter<"AmazonCustomizationFile"> | string | null
    retryCount?: IntWithAggregatesFilter<"AmazonCustomizationFile"> | number
    lastProcessedAt?: DateTimeNullableWithAggregatesFilter<"AmazonCustomizationFile"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AmazonCustomizationFile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AmazonCustomizationFile"> | Date | string
  }

  export type system_logsWhereInput = {
    AND?: system_logsWhereInput | system_logsWhereInput[]
    OR?: system_logsWhereInput[]
    NOT?: system_logsWhereInput | system_logsWhereInput[]
    id?: IntFilter<"system_logs"> | number
    message?: StringNullableFilter<"system_logs"> | string | null
    level?: StringNullableFilter<"system_logs"> | string | null
    timestamp?: DateTimeFilter<"system_logs"> | Date | string
  }

  export type system_logsOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _relevance?: system_logsOrderByRelevanceInput
  }

  export type system_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: system_logsWhereInput | system_logsWhereInput[]
    OR?: system_logsWhereInput[]
    NOT?: system_logsWhereInput | system_logsWhereInput[]
    message?: StringNullableFilter<"system_logs"> | string | null
    level?: StringNullableFilter<"system_logs"> | string | null
    timestamp?: DateTimeFilter<"system_logs"> | Date | string
  }, "id">

  export type system_logsOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: system_logsCountOrderByAggregateInput
    _avg?: system_logsAvgOrderByAggregateInput
    _max?: system_logsMaxOrderByAggregateInput
    _min?: system_logsMinOrderByAggregateInput
    _sum?: system_logsSumOrderByAggregateInput
  }

  export type system_logsScalarWhereWithAggregatesInput = {
    AND?: system_logsScalarWhereWithAggregatesInput | system_logsScalarWhereWithAggregatesInput[]
    OR?: system_logsScalarWhereWithAggregatesInput[]
    NOT?: system_logsScalarWhereWithAggregatesInput | system_logsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"system_logs"> | number
    message?: StringNullableWithAggregatesFilter<"system_logs"> | string | null
    level?: StringNullableWithAggregatesFilter<"system_logs"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"system_logs"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: IntFilter<"Tag"> | number
    shipstation_tag_id?: IntFilter<"Tag"> | number
    name?: StringFilter<"Tag"> | string
    color_hex?: StringNullableFilter<"Tag"> | string | null
    last_synced?: DateTimeFilter<"Tag"> | Date | string
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    shipstation_tag_id?: SortOrder
    name?: SortOrder
    color_hex?: SortOrderInput | SortOrder
    last_synced?: SortOrder
    _relevance?: TagOrderByRelevanceInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    shipstation_tag_id?: number
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    name?: StringFilter<"Tag"> | string
    color_hex?: StringNullableFilter<"Tag"> | string | null
    last_synced?: DateTimeFilter<"Tag"> | Date | string
  }, "id" | "shipstation_tag_id">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    shipstation_tag_id?: SortOrder
    name?: SortOrder
    color_hex?: SortOrderInput | SortOrder
    last_synced?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tag"> | number
    shipstation_tag_id?: IntWithAggregatesFilter<"Tag"> | number
    name?: StringWithAggregatesFilter<"Tag"> | string
    color_hex?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    last_synced?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type ScriptRunLogWhereInput = {
    AND?: ScriptRunLogWhereInput | ScriptRunLogWhereInput[]
    OR?: ScriptRunLogWhereInput[]
    NOT?: ScriptRunLogWhereInput | ScriptRunLogWhereInput[]
    id?: IntFilter<"ScriptRunLog"> | number
    scriptName?: StringFilter<"ScriptRunLog"> | string
    runStartedAt?: DateTimeFilter<"ScriptRunLog"> | Date | string
    runEndedAt?: DateTimeNullableFilter<"ScriptRunLog"> | Date | string | null
    status?: StringFilter<"ScriptRunLog"> | string
    errorMessage?: StringNullableFilter<"ScriptRunLog"> | string | null
    errorStack?: StringNullableFilter<"ScriptRunLog"> | string | null
    details?: JsonNullableFilter<"ScriptRunLog">
    createdAt?: DateTimeFilter<"ScriptRunLog"> | Date | string
  }

  export type ScriptRunLogOrderByWithRelationInput = {
    id?: SortOrder
    scriptName?: SortOrder
    runStartedAt?: SortOrder
    runEndedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorStack?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _relevance?: ScriptRunLogOrderByRelevanceInput
  }

  export type ScriptRunLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ScriptRunLogWhereInput | ScriptRunLogWhereInput[]
    OR?: ScriptRunLogWhereInput[]
    NOT?: ScriptRunLogWhereInput | ScriptRunLogWhereInput[]
    scriptName?: StringFilter<"ScriptRunLog"> | string
    runStartedAt?: DateTimeFilter<"ScriptRunLog"> | Date | string
    runEndedAt?: DateTimeNullableFilter<"ScriptRunLog"> | Date | string | null
    status?: StringFilter<"ScriptRunLog"> | string
    errorMessage?: StringNullableFilter<"ScriptRunLog"> | string | null
    errorStack?: StringNullableFilter<"ScriptRunLog"> | string | null
    details?: JsonNullableFilter<"ScriptRunLog">
    createdAt?: DateTimeFilter<"ScriptRunLog"> | Date | string
  }, "id">

  export type ScriptRunLogOrderByWithAggregationInput = {
    id?: SortOrder
    scriptName?: SortOrder
    runStartedAt?: SortOrder
    runEndedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorStack?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ScriptRunLogCountOrderByAggregateInput
    _avg?: ScriptRunLogAvgOrderByAggregateInput
    _max?: ScriptRunLogMaxOrderByAggregateInput
    _min?: ScriptRunLogMinOrderByAggregateInput
    _sum?: ScriptRunLogSumOrderByAggregateInput
  }

  export type ScriptRunLogScalarWhereWithAggregatesInput = {
    AND?: ScriptRunLogScalarWhereWithAggregatesInput | ScriptRunLogScalarWhereWithAggregatesInput[]
    OR?: ScriptRunLogScalarWhereWithAggregatesInput[]
    NOT?: ScriptRunLogScalarWhereWithAggregatesInput | ScriptRunLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ScriptRunLog"> | number
    scriptName?: StringWithAggregatesFilter<"ScriptRunLog"> | string
    runStartedAt?: DateTimeWithAggregatesFilter<"ScriptRunLog"> | Date | string
    runEndedAt?: DateTimeNullableWithAggregatesFilter<"ScriptRunLog"> | Date | string | null
    status?: StringWithAggregatesFilter<"ScriptRunLog"> | string
    errorMessage?: StringNullableWithAggregatesFilter<"ScriptRunLog"> | string | null
    errorStack?: StringNullableWithAggregatesFilter<"ScriptRunLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"ScriptRunLog">
    createdAt?: DateTimeWithAggregatesFilter<"ScriptRunLog"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: IntFilter<"Account"> | number
    userId?: IntFilter<"Account"> | number
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: AccountOrderByRelevanceInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: IntFilter<"Account"> | number
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Account"> | number
    userId?: IntWithAggregatesFilter<"Account"> | number
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: IntFilter<"Session"> | number
    sessionToken?: StringFilter<"Session"> | string
    userId?: IntFilter<"Session"> | number
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: SessionOrderByRelevanceInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: IntFilter<"Session"> | number
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Session"> | number
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: IntWithAggregatesFilter<"Session"> | number
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _relevance?: VerificationTokenOrderByRelevanceInput
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type SyncProgressWhereInput = {
    AND?: SyncProgressWhereInput | SyncProgressWhereInput[]
    OR?: SyncProgressWhereInput[]
    NOT?: SyncProgressWhereInput | SyncProgressWhereInput[]
    id?: StringFilter<"SyncProgress"> | string
    syncType?: StringFilter<"SyncProgress"> | string
    startTime?: DateTimeFilter<"SyncProgress"> | Date | string
    endTime?: DateTimeNullableFilter<"SyncProgress"> | Date | string | null
    status?: StringFilter<"SyncProgress"> | string
    totalOrders?: IntFilter<"SyncProgress"> | number
    processedOrders?: IntFilter<"SyncProgress"> | number
    failedOrders?: IntFilter<"SyncProgress"> | number
    lastProcessedOrderId?: StringNullableFilter<"SyncProgress"> | string | null
    lastProcessedTimestamp?: DateTimeNullableFilter<"SyncProgress"> | Date | string | null
    error?: StringNullableFilter<"SyncProgress"> | string | null
    createdAt?: DateTimeFilter<"SyncProgress"> | Date | string
    updatedAt?: DateTimeFilter<"SyncProgress"> | Date | string
  }

  export type SyncProgressOrderByWithRelationInput = {
    id?: SortOrder
    syncType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    status?: SortOrder
    totalOrders?: SortOrder
    processedOrders?: SortOrder
    failedOrders?: SortOrder
    lastProcessedOrderId?: SortOrderInput | SortOrder
    lastProcessedTimestamp?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: SyncProgressOrderByRelevanceInput
  }

  export type SyncProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SyncProgressWhereInput | SyncProgressWhereInput[]
    OR?: SyncProgressWhereInput[]
    NOT?: SyncProgressWhereInput | SyncProgressWhereInput[]
    syncType?: StringFilter<"SyncProgress"> | string
    startTime?: DateTimeFilter<"SyncProgress"> | Date | string
    endTime?: DateTimeNullableFilter<"SyncProgress"> | Date | string | null
    status?: StringFilter<"SyncProgress"> | string
    totalOrders?: IntFilter<"SyncProgress"> | number
    processedOrders?: IntFilter<"SyncProgress"> | number
    failedOrders?: IntFilter<"SyncProgress"> | number
    lastProcessedOrderId?: StringNullableFilter<"SyncProgress"> | string | null
    lastProcessedTimestamp?: DateTimeNullableFilter<"SyncProgress"> | Date | string | null
    error?: StringNullableFilter<"SyncProgress"> | string | null
    createdAt?: DateTimeFilter<"SyncProgress"> | Date | string
    updatedAt?: DateTimeFilter<"SyncProgress"> | Date | string
  }, "id">

  export type SyncProgressOrderByWithAggregationInput = {
    id?: SortOrder
    syncType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    status?: SortOrder
    totalOrders?: SortOrder
    processedOrders?: SortOrder
    failedOrders?: SortOrder
    lastProcessedOrderId?: SortOrderInput | SortOrder
    lastProcessedTimestamp?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SyncProgressCountOrderByAggregateInput
    _avg?: SyncProgressAvgOrderByAggregateInput
    _max?: SyncProgressMaxOrderByAggregateInput
    _min?: SyncProgressMinOrderByAggregateInput
    _sum?: SyncProgressSumOrderByAggregateInput
  }

  export type SyncProgressScalarWhereWithAggregatesInput = {
    AND?: SyncProgressScalarWhereWithAggregatesInput | SyncProgressScalarWhereWithAggregatesInput[]
    OR?: SyncProgressScalarWhereWithAggregatesInput[]
    NOT?: SyncProgressScalarWhereWithAggregatesInput | SyncProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SyncProgress"> | string
    syncType?: StringWithAggregatesFilter<"SyncProgress"> | string
    startTime?: DateTimeWithAggregatesFilter<"SyncProgress"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"SyncProgress"> | Date | string | null
    status?: StringWithAggregatesFilter<"SyncProgress"> | string
    totalOrders?: IntWithAggregatesFilter<"SyncProgress"> | number
    processedOrders?: IntWithAggregatesFilter<"SyncProgress"> | number
    failedOrders?: IntWithAggregatesFilter<"SyncProgress"> | number
    lastProcessedOrderId?: StringNullableWithAggregatesFilter<"SyncProgress"> | string | null
    lastProcessedTimestamp?: DateTimeNullableWithAggregatesFilter<"SyncProgress"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"SyncProgress"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SyncProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SyncProgress"> | Date | string
  }

  export type SyncMetricsWhereInput = {
    AND?: SyncMetricsWhereInput | SyncMetricsWhereInput[]
    OR?: SyncMetricsWhereInput[]
    NOT?: SyncMetricsWhereInput | SyncMetricsWhereInput[]
    id?: StringFilter<"SyncMetrics"> | string
    syncId?: StringFilter<"SyncMetrics"> | string
    totalApiCalls?: IntFilter<"SyncMetrics"> | number
    totalOrdersProcessed?: IntFilter<"SyncMetrics"> | number
    totalOrdersFailed?: IntFilter<"SyncMetrics"> | number
    totalItemsProcessed?: IntFilter<"SyncMetrics"> | number
    totalItemsFailed?: IntFilter<"SyncMetrics"> | number
    totalCustomersUpserted?: IntFilter<"SyncMetrics"> | number
    totalProductsUpserted?: IntFilter<"SyncMetrics"> | number
    avgProcessingTimePerOrder?: IntFilter<"SyncMetrics"> | number
    maxProcessingTimePerOrder?: IntFilter<"SyncMetrics"> | number
    minProcessingTimePerOrder?: IntFilter<"SyncMetrics"> | number
    totalProcessingTime?: IntFilter<"SyncMetrics"> | number
    startTime?: DateTimeFilter<"SyncMetrics"> | Date | string
    endTime?: DateTimeNullableFilter<"SyncMetrics"> | Date | string | null
    createdAt?: DateTimeFilter<"SyncMetrics"> | Date | string
  }

  export type SyncMetricsOrderByWithRelationInput = {
    id?: SortOrder
    syncId?: SortOrder
    totalApiCalls?: SortOrder
    totalOrdersProcessed?: SortOrder
    totalOrdersFailed?: SortOrder
    totalItemsProcessed?: SortOrder
    totalItemsFailed?: SortOrder
    totalCustomersUpserted?: SortOrder
    totalProductsUpserted?: SortOrder
    avgProcessingTimePerOrder?: SortOrder
    maxProcessingTimePerOrder?: SortOrder
    minProcessingTimePerOrder?: SortOrder
    totalProcessingTime?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _relevance?: SyncMetricsOrderByRelevanceInput
  }

  export type SyncMetricsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SyncMetricsWhereInput | SyncMetricsWhereInput[]
    OR?: SyncMetricsWhereInput[]
    NOT?: SyncMetricsWhereInput | SyncMetricsWhereInput[]
    syncId?: StringFilter<"SyncMetrics"> | string
    totalApiCalls?: IntFilter<"SyncMetrics"> | number
    totalOrdersProcessed?: IntFilter<"SyncMetrics"> | number
    totalOrdersFailed?: IntFilter<"SyncMetrics"> | number
    totalItemsProcessed?: IntFilter<"SyncMetrics"> | number
    totalItemsFailed?: IntFilter<"SyncMetrics"> | number
    totalCustomersUpserted?: IntFilter<"SyncMetrics"> | number
    totalProductsUpserted?: IntFilter<"SyncMetrics"> | number
    avgProcessingTimePerOrder?: IntFilter<"SyncMetrics"> | number
    maxProcessingTimePerOrder?: IntFilter<"SyncMetrics"> | number
    minProcessingTimePerOrder?: IntFilter<"SyncMetrics"> | number
    totalProcessingTime?: IntFilter<"SyncMetrics"> | number
    startTime?: DateTimeFilter<"SyncMetrics"> | Date | string
    endTime?: DateTimeNullableFilter<"SyncMetrics"> | Date | string | null
    createdAt?: DateTimeFilter<"SyncMetrics"> | Date | string
  }, "id">

  export type SyncMetricsOrderByWithAggregationInput = {
    id?: SortOrder
    syncId?: SortOrder
    totalApiCalls?: SortOrder
    totalOrdersProcessed?: SortOrder
    totalOrdersFailed?: SortOrder
    totalItemsProcessed?: SortOrder
    totalItemsFailed?: SortOrder
    totalCustomersUpserted?: SortOrder
    totalProductsUpserted?: SortOrder
    avgProcessingTimePerOrder?: SortOrder
    maxProcessingTimePerOrder?: SortOrder
    minProcessingTimePerOrder?: SortOrder
    totalProcessingTime?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SyncMetricsCountOrderByAggregateInput
    _avg?: SyncMetricsAvgOrderByAggregateInput
    _max?: SyncMetricsMaxOrderByAggregateInput
    _min?: SyncMetricsMinOrderByAggregateInput
    _sum?: SyncMetricsSumOrderByAggregateInput
  }

  export type SyncMetricsScalarWhereWithAggregatesInput = {
    AND?: SyncMetricsScalarWhereWithAggregatesInput | SyncMetricsScalarWhereWithAggregatesInput[]
    OR?: SyncMetricsScalarWhereWithAggregatesInput[]
    NOT?: SyncMetricsScalarWhereWithAggregatesInput | SyncMetricsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SyncMetrics"> | string
    syncId?: StringWithAggregatesFilter<"SyncMetrics"> | string
    totalApiCalls?: IntWithAggregatesFilter<"SyncMetrics"> | number
    totalOrdersProcessed?: IntWithAggregatesFilter<"SyncMetrics"> | number
    totalOrdersFailed?: IntWithAggregatesFilter<"SyncMetrics"> | number
    totalItemsProcessed?: IntWithAggregatesFilter<"SyncMetrics"> | number
    totalItemsFailed?: IntWithAggregatesFilter<"SyncMetrics"> | number
    totalCustomersUpserted?: IntWithAggregatesFilter<"SyncMetrics"> | number
    totalProductsUpserted?: IntWithAggregatesFilter<"SyncMetrics"> | number
    avgProcessingTimePerOrder?: IntWithAggregatesFilter<"SyncMetrics"> | number
    maxProcessingTimePerOrder?: IntWithAggregatesFilter<"SyncMetrics"> | number
    minProcessingTimePerOrder?: IntWithAggregatesFilter<"SyncMetrics"> | number
    totalProcessingTime?: IntWithAggregatesFilter<"SyncMetrics"> | number
    startTime?: DateTimeWithAggregatesFilter<"SyncMetrics"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"SyncMetrics"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SyncMetrics"> | Date | string
  }

  export type AiCallLogWhereInput = {
    AND?: AiCallLogWhereInput | AiCallLogWhereInput[]
    OR?: AiCallLogWhereInput[]
    NOT?: AiCallLogWhereInput | AiCallLogWhereInput[]
    id?: StringFilter<"AiCallLog"> | string
    scriptName?: StringFilter<"AiCallLog"> | string
    orderId?: IntFilter<"AiCallLog"> | number
    orderNumber?: StringNullableFilter<"AiCallLog"> | string | null
    marketplace?: StringNullableFilter<"AiCallLog"> | string | null
    aiProvider?: StringFilter<"AiCallLog"> | string
    modelUsed?: StringFilter<"AiCallLog"> | string
    promptSent?: StringFilter<"AiCallLog"> | string
    rawResponse?: StringFilter<"AiCallLog"> | string
    processingTimeMs?: IntFilter<"AiCallLog"> | number
    success?: BoolFilter<"AiCallLog"> | boolean
    errorMessage?: StringNullableFilter<"AiCallLog"> | string | null
    tasksGenerated?: IntFilter<"AiCallLog"> | number
    needsReviewCount?: IntFilter<"AiCallLog"> | number
    createdAt?: DateTimeFilter<"AiCallLog"> | Date | string
  }

  export type AiCallLogOrderByWithRelationInput = {
    id?: SortOrder
    scriptName?: SortOrder
    orderId?: SortOrder
    orderNumber?: SortOrderInput | SortOrder
    marketplace?: SortOrderInput | SortOrder
    aiProvider?: SortOrder
    modelUsed?: SortOrder
    promptSent?: SortOrder
    rawResponse?: SortOrder
    processingTimeMs?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    tasksGenerated?: SortOrder
    needsReviewCount?: SortOrder
    createdAt?: SortOrder
    _relevance?: AiCallLogOrderByRelevanceInput
  }

  export type AiCallLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiCallLogWhereInput | AiCallLogWhereInput[]
    OR?: AiCallLogWhereInput[]
    NOT?: AiCallLogWhereInput | AiCallLogWhereInput[]
    scriptName?: StringFilter<"AiCallLog"> | string
    orderId?: IntFilter<"AiCallLog"> | number
    orderNumber?: StringNullableFilter<"AiCallLog"> | string | null
    marketplace?: StringNullableFilter<"AiCallLog"> | string | null
    aiProvider?: StringFilter<"AiCallLog"> | string
    modelUsed?: StringFilter<"AiCallLog"> | string
    promptSent?: StringFilter<"AiCallLog"> | string
    rawResponse?: StringFilter<"AiCallLog"> | string
    processingTimeMs?: IntFilter<"AiCallLog"> | number
    success?: BoolFilter<"AiCallLog"> | boolean
    errorMessage?: StringNullableFilter<"AiCallLog"> | string | null
    tasksGenerated?: IntFilter<"AiCallLog"> | number
    needsReviewCount?: IntFilter<"AiCallLog"> | number
    createdAt?: DateTimeFilter<"AiCallLog"> | Date | string
  }, "id">

  export type AiCallLogOrderByWithAggregationInput = {
    id?: SortOrder
    scriptName?: SortOrder
    orderId?: SortOrder
    orderNumber?: SortOrderInput | SortOrder
    marketplace?: SortOrderInput | SortOrder
    aiProvider?: SortOrder
    modelUsed?: SortOrder
    promptSent?: SortOrder
    rawResponse?: SortOrder
    processingTimeMs?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    tasksGenerated?: SortOrder
    needsReviewCount?: SortOrder
    createdAt?: SortOrder
    _count?: AiCallLogCountOrderByAggregateInput
    _avg?: AiCallLogAvgOrderByAggregateInput
    _max?: AiCallLogMaxOrderByAggregateInput
    _min?: AiCallLogMinOrderByAggregateInput
    _sum?: AiCallLogSumOrderByAggregateInput
  }

  export type AiCallLogScalarWhereWithAggregatesInput = {
    AND?: AiCallLogScalarWhereWithAggregatesInput | AiCallLogScalarWhereWithAggregatesInput[]
    OR?: AiCallLogScalarWhereWithAggregatesInput[]
    NOT?: AiCallLogScalarWhereWithAggregatesInput | AiCallLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiCallLog"> | string
    scriptName?: StringWithAggregatesFilter<"AiCallLog"> | string
    orderId?: IntWithAggregatesFilter<"AiCallLog"> | number
    orderNumber?: StringNullableWithAggregatesFilter<"AiCallLog"> | string | null
    marketplace?: StringNullableWithAggregatesFilter<"AiCallLog"> | string | null
    aiProvider?: StringWithAggregatesFilter<"AiCallLog"> | string
    modelUsed?: StringWithAggregatesFilter<"AiCallLog"> | string
    promptSent?: StringWithAggregatesFilter<"AiCallLog"> | string
    rawResponse?: StringWithAggregatesFilter<"AiCallLog"> | string
    processingTimeMs?: IntWithAggregatesFilter<"AiCallLog"> | number
    success?: BoolWithAggregatesFilter<"AiCallLog"> | boolean
    errorMessage?: StringNullableWithAggregatesFilter<"AiCallLog"> | string | null
    tasksGenerated?: IntWithAggregatesFilter<"AiCallLog"> | number
    needsReviewCount?: IntWithAggregatesFilter<"AiCallLog"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AiCallLog"> | Date | string
  }

  export type MetricWhereInput = {
    AND?: MetricWhereInput | MetricWhereInput[]
    OR?: MetricWhereInput[]
    NOT?: MetricWhereInput | MetricWhereInput[]
    id?: IntFilter<"Metric"> | number
    name?: StringFilter<"Metric"> | string
    value?: FloatFilter<"Metric"> | number
    tags?: JsonNullableFilter<"Metric">
    timestamp?: DateTimeFilter<"Metric"> | Date | string
  }

  export type MetricOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    tags?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _relevance?: MetricOrderByRelevanceInput
  }

  export type MetricWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MetricWhereInput | MetricWhereInput[]
    OR?: MetricWhereInput[]
    NOT?: MetricWhereInput | MetricWhereInput[]
    name?: StringFilter<"Metric"> | string
    value?: FloatFilter<"Metric"> | number
    tags?: JsonNullableFilter<"Metric">
    timestamp?: DateTimeFilter<"Metric"> | Date | string
  }, "id">

  export type MetricOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    tags?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: MetricCountOrderByAggregateInput
    _avg?: MetricAvgOrderByAggregateInput
    _max?: MetricMaxOrderByAggregateInput
    _min?: MetricMinOrderByAggregateInput
    _sum?: MetricSumOrderByAggregateInput
  }

  export type MetricScalarWhereWithAggregatesInput = {
    AND?: MetricScalarWhereWithAggregatesInput | MetricScalarWhereWithAggregatesInput[]
    OR?: MetricScalarWhereWithAggregatesInput[]
    NOT?: MetricScalarWhereWithAggregatesInput | MetricScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Metric"> | number
    name?: StringWithAggregatesFilter<"Metric"> | string
    value?: FloatWithAggregatesFilter<"Metric"> | number
    tags?: JsonNullableWithAggregatesFilter<"Metric">
    timestamp?: DateTimeWithAggregatesFilter<"Metric"> | Date | string
  }

  export type AiReportDefinitionWhereInput = {
    AND?: AiReportDefinitionWhereInput | AiReportDefinitionWhereInput[]
    OR?: AiReportDefinitionWhereInput[]
    NOT?: AiReportDefinitionWhereInput | AiReportDefinitionWhereInput[]
    id?: StringFilter<"AiReportDefinition"> | string
    slug?: StringFilter<"AiReportDefinition"> | string
    name?: StringFilter<"AiReportDefinition"> | string
    description?: StringFilter<"AiReportDefinition"> | string
    systemPrompt?: StringFilter<"AiReportDefinition"> | string
    createdAt?: DateTimeFilter<"AiReportDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"AiReportDefinition"> | Date | string
    runs?: AiReportRunListRelationFilter
  }

  export type AiReportDefinitionOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    systemPrompt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    runs?: AiReportRunOrderByRelationAggregateInput
    _relevance?: AiReportDefinitionOrderByRelevanceInput
  }

  export type AiReportDefinitionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: AiReportDefinitionWhereInput | AiReportDefinitionWhereInput[]
    OR?: AiReportDefinitionWhereInput[]
    NOT?: AiReportDefinitionWhereInput | AiReportDefinitionWhereInput[]
    name?: StringFilter<"AiReportDefinition"> | string
    description?: StringFilter<"AiReportDefinition"> | string
    systemPrompt?: StringFilter<"AiReportDefinition"> | string
    createdAt?: DateTimeFilter<"AiReportDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"AiReportDefinition"> | Date | string
    runs?: AiReportRunListRelationFilter
  }, "id" | "slug">

  export type AiReportDefinitionOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    systemPrompt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AiReportDefinitionCountOrderByAggregateInput
    _max?: AiReportDefinitionMaxOrderByAggregateInput
    _min?: AiReportDefinitionMinOrderByAggregateInput
  }

  export type AiReportDefinitionScalarWhereWithAggregatesInput = {
    AND?: AiReportDefinitionScalarWhereWithAggregatesInput | AiReportDefinitionScalarWhereWithAggregatesInput[]
    OR?: AiReportDefinitionScalarWhereWithAggregatesInput[]
    NOT?: AiReportDefinitionScalarWhereWithAggregatesInput | AiReportDefinitionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiReportDefinition"> | string
    slug?: StringWithAggregatesFilter<"AiReportDefinition"> | string
    name?: StringWithAggregatesFilter<"AiReportDefinition"> | string
    description?: StringWithAggregatesFilter<"AiReportDefinition"> | string
    systemPrompt?: StringWithAggregatesFilter<"AiReportDefinition"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AiReportDefinition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AiReportDefinition"> | Date | string
  }

  export type AiReportRunWhereInput = {
    AND?: AiReportRunWhereInput | AiReportRunWhereInput[]
    OR?: AiReportRunWhereInput[]
    NOT?: AiReportRunWhereInput | AiReportRunWhereInput[]
    id?: StringFilter<"AiReportRun"> | string
    reportId?: StringFilter<"AiReportRun"> | string
    inputJson?: JsonFilter<"AiReportRun">
    outputJson?: JsonNullableFilter<"AiReportRun">
    rawResponse?: StringNullableFilter<"AiReportRun"> | string | null
    status?: StringFilter<"AiReportRun"> | string
    errorMsg?: StringNullableFilter<"AiReportRun"> | string | null
    createdAt?: DateTimeFilter<"AiReportRun"> | Date | string
    finishedAt?: DateTimeNullableFilter<"AiReportRun"> | Date | string | null
    report?: XOR<AiReportDefinitionScalarRelationFilter, AiReportDefinitionWhereInput>
  }

  export type AiReportRunOrderByWithRelationInput = {
    id?: SortOrder
    reportId?: SortOrder
    inputJson?: SortOrder
    outputJson?: SortOrderInput | SortOrder
    rawResponse?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMsg?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    report?: AiReportDefinitionOrderByWithRelationInput
    _relevance?: AiReportRunOrderByRelevanceInput
  }

  export type AiReportRunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiReportRunWhereInput | AiReportRunWhereInput[]
    OR?: AiReportRunWhereInput[]
    NOT?: AiReportRunWhereInput | AiReportRunWhereInput[]
    reportId?: StringFilter<"AiReportRun"> | string
    inputJson?: JsonFilter<"AiReportRun">
    outputJson?: JsonNullableFilter<"AiReportRun">
    rawResponse?: StringNullableFilter<"AiReportRun"> | string | null
    status?: StringFilter<"AiReportRun"> | string
    errorMsg?: StringNullableFilter<"AiReportRun"> | string | null
    createdAt?: DateTimeFilter<"AiReportRun"> | Date | string
    finishedAt?: DateTimeNullableFilter<"AiReportRun"> | Date | string | null
    report?: XOR<AiReportDefinitionScalarRelationFilter, AiReportDefinitionWhereInput>
  }, "id">

  export type AiReportRunOrderByWithAggregationInput = {
    id?: SortOrder
    reportId?: SortOrder
    inputJson?: SortOrder
    outputJson?: SortOrderInput | SortOrder
    rawResponse?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMsg?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    _count?: AiReportRunCountOrderByAggregateInput
    _max?: AiReportRunMaxOrderByAggregateInput
    _min?: AiReportRunMinOrderByAggregateInput
  }

  export type AiReportRunScalarWhereWithAggregatesInput = {
    AND?: AiReportRunScalarWhereWithAggregatesInput | AiReportRunScalarWhereWithAggregatesInput[]
    OR?: AiReportRunScalarWhereWithAggregatesInput[]
    NOT?: AiReportRunScalarWhereWithAggregatesInput | AiReportRunScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiReportRun"> | string
    reportId?: StringWithAggregatesFilter<"AiReportRun"> | string
    inputJson?: JsonWithAggregatesFilter<"AiReportRun">
    outputJson?: JsonNullableWithAggregatesFilter<"AiReportRun">
    rawResponse?: StringNullableWithAggregatesFilter<"AiReportRun"> | string | null
    status?: StringWithAggregatesFilter<"AiReportRun"> | string
    errorMsg?: StringNullableWithAggregatesFilter<"AiReportRun"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AiReportRun"> | Date | string
    finishedAt?: DateTimeNullableWithAggregatesFilter<"AiReportRun"> | Date | string | null
  }

  export type ProductCreateInput = {
    sku?: string | null
    name: string
    imageUrl?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fulfillment_sku?: string | null
    item_weight_units?: string | null
    item_weight_value?: Decimal | DecimalJsLike | number | string | null
    shipstation_product_id?: number | null
    upc?: string | null
    warehouse_location?: string | null
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    printTasks?: PrintOrderTaskCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    sku?: string | null
    name: string
    imageUrl?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fulfillment_sku?: string | null
    item_weight_units?: string | null
    item_weight_value?: Decimal | DecimalJsLike | number | string | null
    shipstation_product_id?: number | null
    upc?: string | null
    warehouse_location?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    printTasks?: PrintOrderTaskUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfillment_sku?: NullableStringFieldUpdateOperationsInput | string | null
    item_weight_units?: NullableStringFieldUpdateOperationsInput | string | null
    item_weight_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipstation_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    warehouse_location?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    printTasks?: PrintOrderTaskUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfillment_sku?: NullableStringFieldUpdateOperationsInput | string | null
    item_weight_units?: NullableStringFieldUpdateOperationsInput | string | null
    item_weight_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipstation_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    warehouse_location?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    printTasks?: PrintOrderTaskUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    sku?: string | null
    name: string
    imageUrl?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fulfillment_sku?: string | null
    item_weight_units?: string | null
    item_weight_value?: Decimal | DecimalJsLike | number | string | null
    shipstation_product_id?: number | null
    upc?: string | null
    warehouse_location?: string | null
  }

  export type ProductUpdateManyMutationInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfillment_sku?: NullableStringFieldUpdateOperationsInput | string | null
    item_weight_units?: NullableStringFieldUpdateOperationsInput | string | null
    item_weight_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipstation_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    warehouse_location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfillment_sku?: NullableStringFieldUpdateOperationsInput | string | null
    item_weight_units?: NullableStringFieldUpdateOperationsInput | string | null
    item_weight_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipstation_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    warehouse_location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateInput = {
    shipstation_order_id?: string | null
    shipstation_order_number?: string | null
    customer_name?: string | null
    order_status?: string
    order_key?: string | null
    order_date?: Date | string | null
    payment_date?: Date | string | null
    ship_by_date?: Date | string | null
    shipping_price?: Decimal | DecimalJsLike | number | string | null
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: Decimal | DecimalJsLike | number | string | null
    shipping_tax?: Decimal | DecimalJsLike | number | string | null
    total_price?: Decimal | DecimalJsLike | number | string
    gift?: boolean
    gift_message?: string | null
    gift_email?: string | null
    requested_shipping_service?: string | null
    carrier_code?: string | null
    service_code?: string | null
    package_code?: string | null
    confirmation?: string | null
    tracking_number?: string | null
    shipped_date?: Date | string | null
    warehouse_id?: string | null
    customer_notes?: string | null
    internal_notes?: string | null
    last_sync_date?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    marketplace?: string | null
    amount_paid?: Decimal | DecimalJsLike | number | string | null
    order_weight_units?: string | null
    order_weight_value?: Decimal | DecimalJsLike | number | string | null
    payment_method?: string | null
    shipstation_store_id?: number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: Decimal | DecimalJsLike | number | string | null
    dimensions_length?: Decimal | DecimalJsLike | number | string | null
    dimensions_units?: string | null
    dimensions_width?: Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: boolean | null
    insurance_insured_value?: Decimal | DecimalJsLike | number | string | null
    insurance_provider?: string | null
    internal_status?: $Enums.InternalOrderStatus
    is_voided?: boolean | null
    marketplace_notified?: boolean
    void_date?: Date | string | null
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    printTasks?: PrintOrderTaskCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    shipstation_order_id?: string | null
    shipstation_order_number?: string | null
    customerId?: number | null
    customer_name?: string | null
    order_status?: string
    order_key?: string | null
    order_date?: Date | string | null
    payment_date?: Date | string | null
    ship_by_date?: Date | string | null
    shipping_price?: Decimal | DecimalJsLike | number | string | null
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: Decimal | DecimalJsLike | number | string | null
    shipping_tax?: Decimal | DecimalJsLike | number | string | null
    total_price?: Decimal | DecimalJsLike | number | string
    gift?: boolean
    gift_message?: string | null
    gift_email?: string | null
    requested_shipping_service?: string | null
    carrier_code?: string | null
    service_code?: string | null
    package_code?: string | null
    confirmation?: string | null
    tracking_number?: string | null
    shipped_date?: Date | string | null
    warehouse_id?: string | null
    customer_notes?: string | null
    internal_notes?: string | null
    last_sync_date?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    marketplace?: string | null
    amount_paid?: Decimal | DecimalJsLike | number | string | null
    order_weight_units?: string | null
    order_weight_value?: Decimal | DecimalJsLike | number | string | null
    payment_method?: string | null
    shipstation_store_id?: number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: Decimal | DecimalJsLike | number | string | null
    dimensions_length?: Decimal | DecimalJsLike | number | string | null
    dimensions_units?: string | null
    dimensions_width?: Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: boolean | null
    insurance_insured_value?: Decimal | DecimalJsLike | number | string | null
    insurance_provider?: string | null
    internal_status?: $Enums.InternalOrderStatus
    is_voided?: boolean | null
    marketplace_notified?: boolean
    void_date?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    printTasks?: PrintOrderTaskUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    shipstation_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    order_status?: StringFieldUpdateOperationsInput | string
    order_key?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipping_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_tax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gift?: BoolFieldUpdateOperationsInput | boolean
    gift_message?: NullableStringFieldUpdateOperationsInput | string | null
    gift_email?: NullableStringFieldUpdateOperationsInput | string | null
    requested_shipping_service?: NullableStringFieldUpdateOperationsInput | string | null
    carrier_code?: NullableStringFieldUpdateOperationsInput | string | null
    service_code?: NullableStringFieldUpdateOperationsInput | string | null
    package_code?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipped_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warehouse_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_notes?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    order_weight_units?: NullableStringFieldUpdateOperationsInput | string | null
    order_weight_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_store_id?: NullableIntFieldUpdateOperationsInput | number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_units?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions_width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance_insured_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    internal_status?: EnumInternalOrderStatusFieldUpdateOperationsInput | $Enums.InternalOrderStatus
    is_voided?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketplace_notified?: BoolFieldUpdateOperationsInput | boolean
    void_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    printTasks?: PrintOrderTaskUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipstation_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    order_status?: StringFieldUpdateOperationsInput | string
    order_key?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipping_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_tax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gift?: BoolFieldUpdateOperationsInput | boolean
    gift_message?: NullableStringFieldUpdateOperationsInput | string | null
    gift_email?: NullableStringFieldUpdateOperationsInput | string | null
    requested_shipping_service?: NullableStringFieldUpdateOperationsInput | string | null
    carrier_code?: NullableStringFieldUpdateOperationsInput | string | null
    service_code?: NullableStringFieldUpdateOperationsInput | string | null
    package_code?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipped_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warehouse_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_notes?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    order_weight_units?: NullableStringFieldUpdateOperationsInput | string | null
    order_weight_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_store_id?: NullableIntFieldUpdateOperationsInput | number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_units?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions_width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance_insured_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    internal_status?: EnumInternalOrderStatusFieldUpdateOperationsInput | $Enums.InternalOrderStatus
    is_voided?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketplace_notified?: BoolFieldUpdateOperationsInput | boolean
    void_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    printTasks?: PrintOrderTaskUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: number
    shipstation_order_id?: string | null
    shipstation_order_number?: string | null
    customerId?: number | null
    customer_name?: string | null
    order_status?: string
    order_key?: string | null
    order_date?: Date | string | null
    payment_date?: Date | string | null
    ship_by_date?: Date | string | null
    shipping_price?: Decimal | DecimalJsLike | number | string | null
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: Decimal | DecimalJsLike | number | string | null
    shipping_tax?: Decimal | DecimalJsLike | number | string | null
    total_price?: Decimal | DecimalJsLike | number | string
    gift?: boolean
    gift_message?: string | null
    gift_email?: string | null
    requested_shipping_service?: string | null
    carrier_code?: string | null
    service_code?: string | null
    package_code?: string | null
    confirmation?: string | null
    tracking_number?: string | null
    shipped_date?: Date | string | null
    warehouse_id?: string | null
    customer_notes?: string | null
    internal_notes?: string | null
    last_sync_date?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    marketplace?: string | null
    amount_paid?: Decimal | DecimalJsLike | number | string | null
    order_weight_units?: string | null
    order_weight_value?: Decimal | DecimalJsLike | number | string | null
    payment_method?: string | null
    shipstation_store_id?: number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: Decimal | DecimalJsLike | number | string | null
    dimensions_length?: Decimal | DecimalJsLike | number | string | null
    dimensions_units?: string | null
    dimensions_width?: Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: boolean | null
    insurance_insured_value?: Decimal | DecimalJsLike | number | string | null
    insurance_provider?: string | null
    internal_status?: $Enums.InternalOrderStatus
    is_voided?: boolean | null
    marketplace_notified?: boolean
    void_date?: Date | string | null
  }

  export type OrderUpdateManyMutationInput = {
    shipstation_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    order_status?: StringFieldUpdateOperationsInput | string
    order_key?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipping_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_tax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gift?: BoolFieldUpdateOperationsInput | boolean
    gift_message?: NullableStringFieldUpdateOperationsInput | string | null
    gift_email?: NullableStringFieldUpdateOperationsInput | string | null
    requested_shipping_service?: NullableStringFieldUpdateOperationsInput | string | null
    carrier_code?: NullableStringFieldUpdateOperationsInput | string | null
    service_code?: NullableStringFieldUpdateOperationsInput | string | null
    package_code?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipped_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warehouse_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_notes?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    order_weight_units?: NullableStringFieldUpdateOperationsInput | string | null
    order_weight_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_store_id?: NullableIntFieldUpdateOperationsInput | number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_units?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions_width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance_insured_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    internal_status?: EnumInternalOrderStatusFieldUpdateOperationsInput | $Enums.InternalOrderStatus
    is_voided?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketplace_notified?: BoolFieldUpdateOperationsInput | boolean
    void_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipstation_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    order_status?: StringFieldUpdateOperationsInput | string
    order_key?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipping_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_tax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gift?: BoolFieldUpdateOperationsInput | boolean
    gift_message?: NullableStringFieldUpdateOperationsInput | string | null
    gift_email?: NullableStringFieldUpdateOperationsInput | string | null
    requested_shipping_service?: NullableStringFieldUpdateOperationsInput | string | null
    carrier_code?: NullableStringFieldUpdateOperationsInput | string | null
    service_code?: NullableStringFieldUpdateOperationsInput | string | null
    package_code?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipped_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warehouse_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_notes?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    order_weight_units?: NullableStringFieldUpdateOperationsInput | string | null
    order_weight_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_store_id?: NullableIntFieldUpdateOperationsInput | number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_units?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions_width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance_insured_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    internal_status?: EnumInternalOrderStatusFieldUpdateOperationsInput | $Enums.InternalOrderStatus
    is_voided?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketplace_notified?: BoolFieldUpdateOperationsInput | boolean
    void_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerCreateInput = {
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    shipstation_customer_id?: string | null
    company?: string | null
    street1?: string | null
    street2?: string | null
    street3?: string | null
    city?: string | null
    state?: string | null
    postal_code?: string | null
    country?: string | null
    country_code?: string | null
    customer_notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    address_verified_status?: string | null
    is_residential?: boolean | null
    orders?: OrderCreateNestedManyWithoutCustomerInput
    printTasks?: PrintOrderTaskCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    shipstation_customer_id?: string | null
    company?: string | null
    street1?: string | null
    street2?: string | null
    street3?: string | null
    city?: string | null
    state?: string | null
    postal_code?: string | null
    country?: string | null
    country_code?: string | null
    customer_notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    address_verified_status?: string | null
    is_residential?: boolean | null
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    printTasks?: PrintOrderTaskUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: NullableStringFieldUpdateOperationsInput | string | null
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    street3?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    customer_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_verified_status?: NullableStringFieldUpdateOperationsInput | string | null
    is_residential?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    printTasks?: PrintOrderTaskUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: NullableStringFieldUpdateOperationsInput | string | null
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    street3?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    customer_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_verified_status?: NullableStringFieldUpdateOperationsInput | string | null
    is_residential?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    printTasks?: PrintOrderTaskUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    shipstation_customer_id?: string | null
    company?: string | null
    street1?: string | null
    street2?: string | null
    street3?: string | null
    city?: string | null
    state?: string | null
    postal_code?: string | null
    country?: string | null
    country_code?: string | null
    customer_notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    address_verified_status?: string | null
    is_residential?: boolean | null
  }

  export type CustomerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: NullableStringFieldUpdateOperationsInput | string | null
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    street3?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    customer_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_verified_status?: NullableStringFieldUpdateOperationsInput | string | null
    is_residential?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: NullableStringFieldUpdateOperationsInput | string | null
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    street3?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    customer_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_verified_status?: NullableStringFieldUpdateOperationsInput | string | null
    is_residential?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OrderItemCreateInput = {
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    shipstationLineItemKey?: string | null
    amazonCustomizationFiles?: AmazonCustomizationFileCreateNestedOneWithoutOrderItemInput
    order: OrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
    printTasks?: PrintOrderTaskCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: number
    orderId: number
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    shipstationLineItemKey?: string | null
    productId: number
    amazonCustomizationFiles?: AmazonCustomizationFileUncheckedCreateNestedOneWithoutOrderItemInput
    printTasks?: PrintOrderTaskUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipstationLineItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    amazonCustomizationFiles?: AmazonCustomizationFileUpdateOneWithoutOrderItemNestedInput
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
    printTasks?: PrintOrderTaskUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipstationLineItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    amazonCustomizationFiles?: AmazonCustomizationFileUncheckedUpdateOneWithoutOrderItemNestedInput
    printTasks?: PrintOrderTaskUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemCreateManyInput = {
    id?: number
    orderId: number
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    shipstationLineItemKey?: string | null
    productId: number
  }

  export type OrderItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipstationLineItemKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipstationLineItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type PrintOrderTaskCreateInput = {
    marketplace_order_number?: string | null
    custom_text?: string | null
    quantity?: number
    color_1?: string | null
    color_2?: string | null
    ship_by_date?: Date | string | null
    status?: $Enums.PrintTaskStatus
    stl_render_state?: $Enums.StlRenderStatus
    stl_path?: string | null
    render_retries?: number
    needs_review?: boolean
    review_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    taskIndex: number
    shorthandProductName?: string | null
    annotation?: string | null
    customer?: CustomerCreateNestedOneWithoutPrintTasksInput
    order: OrderCreateNestedOneWithoutPrintTasksInput
    orderItem: OrderItemCreateNestedOneWithoutPrintTasksInput
    product: ProductCreateNestedOneWithoutPrintTasksInput
  }

  export type PrintOrderTaskUncheckedCreateInput = {
    id?: number
    orderId: number
    marketplace_order_number?: string | null
    customerId?: number | null
    custom_text?: string | null
    quantity?: number
    color_1?: string | null
    color_2?: string | null
    ship_by_date?: Date | string | null
    status?: $Enums.PrintTaskStatus
    stl_render_state?: $Enums.StlRenderStatus
    stl_path?: string | null
    render_retries?: number
    needs_review?: boolean
    review_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    orderItemId: number
    taskIndex: number
    productId: number
    shorthandProductName?: string | null
    annotation?: string | null
  }

  export type PrintOrderTaskUpdateInput = {
    marketplace_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    custom_text?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    color_1?: NullableStringFieldUpdateOperationsInput | string | null
    color_2?: NullableStringFieldUpdateOperationsInput | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPrintTaskStatusFieldUpdateOperationsInput | $Enums.PrintTaskStatus
    stl_render_state?: EnumStlRenderStatusFieldUpdateOperationsInput | $Enums.StlRenderStatus
    stl_path?: NullableStringFieldUpdateOperationsInput | string | null
    render_retries?: IntFieldUpdateOperationsInput | number
    needs_review?: BoolFieldUpdateOperationsInput | boolean
    review_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskIndex?: IntFieldUpdateOperationsInput | number
    shorthandProductName?: NullableStringFieldUpdateOperationsInput | string | null
    annotation?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutPrintTasksNestedInput
    order?: OrderUpdateOneRequiredWithoutPrintTasksNestedInput
    orderItem?: OrderItemUpdateOneRequiredWithoutPrintTasksNestedInput
    product?: ProductUpdateOneRequiredWithoutPrintTasksNestedInput
  }

  export type PrintOrderTaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    marketplace_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    custom_text?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    color_1?: NullableStringFieldUpdateOperationsInput | string | null
    color_2?: NullableStringFieldUpdateOperationsInput | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPrintTaskStatusFieldUpdateOperationsInput | $Enums.PrintTaskStatus
    stl_render_state?: EnumStlRenderStatusFieldUpdateOperationsInput | $Enums.StlRenderStatus
    stl_path?: NullableStringFieldUpdateOperationsInput | string | null
    render_retries?: IntFieldUpdateOperationsInput | number
    needs_review?: BoolFieldUpdateOperationsInput | boolean
    review_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderItemId?: IntFieldUpdateOperationsInput | number
    taskIndex?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    shorthandProductName?: NullableStringFieldUpdateOperationsInput | string | null
    annotation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrintOrderTaskCreateManyInput = {
    id?: number
    orderId: number
    marketplace_order_number?: string | null
    customerId?: number | null
    custom_text?: string | null
    quantity?: number
    color_1?: string | null
    color_2?: string | null
    ship_by_date?: Date | string | null
    status?: $Enums.PrintTaskStatus
    stl_render_state?: $Enums.StlRenderStatus
    stl_path?: string | null
    render_retries?: number
    needs_review?: boolean
    review_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    orderItemId: number
    taskIndex: number
    productId: number
    shorthandProductName?: string | null
    annotation?: string | null
  }

  export type PrintOrderTaskUpdateManyMutationInput = {
    marketplace_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    custom_text?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    color_1?: NullableStringFieldUpdateOperationsInput | string | null
    color_2?: NullableStringFieldUpdateOperationsInput | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPrintTaskStatusFieldUpdateOperationsInput | $Enums.PrintTaskStatus
    stl_render_state?: EnumStlRenderStatusFieldUpdateOperationsInput | $Enums.StlRenderStatus
    stl_path?: NullableStringFieldUpdateOperationsInput | string | null
    render_retries?: IntFieldUpdateOperationsInput | number
    needs_review?: BoolFieldUpdateOperationsInput | boolean
    review_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskIndex?: IntFieldUpdateOperationsInput | number
    shorthandProductName?: NullableStringFieldUpdateOperationsInput | string | null
    annotation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrintOrderTaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    marketplace_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    custom_text?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    color_1?: NullableStringFieldUpdateOperationsInput | string | null
    color_2?: NullableStringFieldUpdateOperationsInput | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPrintTaskStatusFieldUpdateOperationsInput | $Enums.PrintTaskStatus
    stl_render_state?: EnumStlRenderStatusFieldUpdateOperationsInput | $Enums.StlRenderStatus
    stl_path?: NullableStringFieldUpdateOperationsInput | string | null
    render_retries?: IntFieldUpdateOperationsInput | number
    needs_review?: BoolFieldUpdateOperationsInput | boolean
    review_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderItemId?: IntFieldUpdateOperationsInput | number
    taskIndex?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    shorthandProductName?: NullableStringFieldUpdateOperationsInput | string | null
    annotation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AmazonCustomizationFileCreateInput = {
    originalUrl: string
    localFilePath?: string | null
    downloadStatus?: string
    processingStatus?: string
    customText?: string | null
    color1?: string | null
    color2?: string | null
    rawJsonData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    lastProcessedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItem: OrderItemCreateNestedOneWithoutAmazonCustomizationFilesInput
  }

  export type AmazonCustomizationFileUncheckedCreateInput = {
    id?: number
    orderItemId: number
    originalUrl: string
    localFilePath?: string | null
    downloadStatus?: string
    processingStatus?: string
    customText?: string | null
    color1?: string | null
    color2?: string | null
    rawJsonData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    lastProcessedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmazonCustomizationFileUpdateInput = {
    originalUrl?: StringFieldUpdateOperationsInput | string
    localFilePath?: NullableStringFieldUpdateOperationsInput | string | null
    downloadStatus?: StringFieldUpdateOperationsInput | string
    processingStatus?: StringFieldUpdateOperationsInput | string
    customText?: NullableStringFieldUpdateOperationsInput | string | null
    color1?: NullableStringFieldUpdateOperationsInput | string | null
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    rawJsonData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItem?: OrderItemUpdateOneRequiredWithoutAmazonCustomizationFilesNestedInput
  }

  export type AmazonCustomizationFileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderItemId?: IntFieldUpdateOperationsInput | number
    originalUrl?: StringFieldUpdateOperationsInput | string
    localFilePath?: NullableStringFieldUpdateOperationsInput | string | null
    downloadStatus?: StringFieldUpdateOperationsInput | string
    processingStatus?: StringFieldUpdateOperationsInput | string
    customText?: NullableStringFieldUpdateOperationsInput | string | null
    color1?: NullableStringFieldUpdateOperationsInput | string | null
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    rawJsonData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmazonCustomizationFileCreateManyInput = {
    id?: number
    orderItemId: number
    originalUrl: string
    localFilePath?: string | null
    downloadStatus?: string
    processingStatus?: string
    customText?: string | null
    color1?: string | null
    color2?: string | null
    rawJsonData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    lastProcessedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmazonCustomizationFileUpdateManyMutationInput = {
    originalUrl?: StringFieldUpdateOperationsInput | string
    localFilePath?: NullableStringFieldUpdateOperationsInput | string | null
    downloadStatus?: StringFieldUpdateOperationsInput | string
    processingStatus?: StringFieldUpdateOperationsInput | string
    customText?: NullableStringFieldUpdateOperationsInput | string | null
    color1?: NullableStringFieldUpdateOperationsInput | string | null
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    rawJsonData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmazonCustomizationFileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderItemId?: IntFieldUpdateOperationsInput | number
    originalUrl?: StringFieldUpdateOperationsInput | string
    localFilePath?: NullableStringFieldUpdateOperationsInput | string | null
    downloadStatus?: StringFieldUpdateOperationsInput | string
    processingStatus?: StringFieldUpdateOperationsInput | string
    customText?: NullableStringFieldUpdateOperationsInput | string | null
    color1?: NullableStringFieldUpdateOperationsInput | string | null
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    rawJsonData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type system_logsCreateInput = {
    message?: string | null
    level?: string | null
    timestamp?: Date | string
  }

  export type system_logsUncheckedCreateInput = {
    id?: number
    message?: string | null
    level?: string | null
    timestamp?: Date | string
  }

  export type system_logsUpdateInput = {
    message?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type system_logsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type system_logsCreateManyInput = {
    id?: number
    message?: string | null
    level?: string | null
    timestamp?: Date | string
  }

  export type system_logsUpdateManyMutationInput = {
    message?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type system_logsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    shipstation_tag_id: number
    name: string
    color_hex?: string | null
    last_synced?: Date | string
  }

  export type TagUncheckedCreateInput = {
    id?: number
    shipstation_tag_id: number
    name: string
    color_hex?: string | null
    last_synced?: Date | string
  }

  export type TagUpdateInput = {
    shipstation_tag_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipstation_tag_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateManyInput = {
    id?: number
    shipstation_tag_id: number
    name: string
    color_hex?: string | null
    last_synced?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    shipstation_tag_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipstation_tag_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScriptRunLogCreateInput = {
    scriptName: string
    runStartedAt?: Date | string
    runEndedAt?: Date | string | null
    status: string
    errorMessage?: string | null
    errorStack?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ScriptRunLogUncheckedCreateInput = {
    id?: number
    scriptName: string
    runStartedAt?: Date | string
    runEndedAt?: Date | string | null
    status: string
    errorMessage?: string | null
    errorStack?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ScriptRunLogUpdateInput = {
    scriptName?: StringFieldUpdateOperationsInput | string
    runStartedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScriptRunLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    scriptName?: StringFieldUpdateOperationsInput | string
    runStartedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScriptRunLogCreateManyInput = {
    id?: number
    scriptName: string
    runStartedAt?: Date | string
    runEndedAt?: Date | string | null
    status: string
    errorMessage?: string | null
    errorStack?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ScriptRunLogUpdateManyMutationInput = {
    scriptName?: StringFieldUpdateOperationsInput | string
    runStartedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScriptRunLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    scriptName?: StringFieldUpdateOperationsInput | string
    runStartedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: number
    userId: number
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: number
    userId: number
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: number
    sessionToken: string
    userId: number
    expires: Date | string
  }

  export type SessionUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: number
    sessionToken: string
    userId: number
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncProgressCreateInput = {
    id?: string
    syncType: string
    startTime: Date | string
    endTime?: Date | string | null
    status: string
    totalOrders?: number
    processedOrders?: number
    failedOrders?: number
    lastProcessedOrderId?: string | null
    lastProcessedTimestamp?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyncProgressUncheckedCreateInput = {
    id?: string
    syncType: string
    startTime: Date | string
    endTime?: Date | string | null
    status: string
    totalOrders?: number
    processedOrders?: number
    failedOrders?: number
    lastProcessedOrderId?: string | null
    lastProcessedTimestamp?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyncProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    processedOrders?: IntFieldUpdateOperationsInput | number
    failedOrders?: IntFieldUpdateOperationsInput | number
    lastProcessedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    lastProcessedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    processedOrders?: IntFieldUpdateOperationsInput | number
    failedOrders?: IntFieldUpdateOperationsInput | number
    lastProcessedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    lastProcessedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncProgressCreateManyInput = {
    id?: string
    syncType: string
    startTime: Date | string
    endTime?: Date | string | null
    status: string
    totalOrders?: number
    processedOrders?: number
    failedOrders?: number
    lastProcessedOrderId?: string | null
    lastProcessedTimestamp?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyncProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    processedOrders?: IntFieldUpdateOperationsInput | number
    failedOrders?: IntFieldUpdateOperationsInput | number
    lastProcessedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    lastProcessedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    processedOrders?: IntFieldUpdateOperationsInput | number
    failedOrders?: IntFieldUpdateOperationsInput | number
    lastProcessedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    lastProcessedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncMetricsCreateInput = {
    id?: string
    syncId: string
    totalApiCalls?: number
    totalOrdersProcessed?: number
    totalOrdersFailed?: number
    totalItemsProcessed?: number
    totalItemsFailed?: number
    totalCustomersUpserted?: number
    totalProductsUpserted?: number
    avgProcessingTimePerOrder?: number
    maxProcessingTimePerOrder?: number
    minProcessingTimePerOrder?: number
    totalProcessingTime?: number
    startTime: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
  }

  export type SyncMetricsUncheckedCreateInput = {
    id?: string
    syncId: string
    totalApiCalls?: number
    totalOrdersProcessed?: number
    totalOrdersFailed?: number
    totalItemsProcessed?: number
    totalItemsFailed?: number
    totalCustomersUpserted?: number
    totalProductsUpserted?: number
    avgProcessingTimePerOrder?: number
    maxProcessingTimePerOrder?: number
    minProcessingTimePerOrder?: number
    totalProcessingTime?: number
    startTime: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
  }

  export type SyncMetricsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncId?: StringFieldUpdateOperationsInput | string
    totalApiCalls?: IntFieldUpdateOperationsInput | number
    totalOrdersProcessed?: IntFieldUpdateOperationsInput | number
    totalOrdersFailed?: IntFieldUpdateOperationsInput | number
    totalItemsProcessed?: IntFieldUpdateOperationsInput | number
    totalItemsFailed?: IntFieldUpdateOperationsInput | number
    totalCustomersUpserted?: IntFieldUpdateOperationsInput | number
    totalProductsUpserted?: IntFieldUpdateOperationsInput | number
    avgProcessingTimePerOrder?: IntFieldUpdateOperationsInput | number
    maxProcessingTimePerOrder?: IntFieldUpdateOperationsInput | number
    minProcessingTimePerOrder?: IntFieldUpdateOperationsInput | number
    totalProcessingTime?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncMetricsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncId?: StringFieldUpdateOperationsInput | string
    totalApiCalls?: IntFieldUpdateOperationsInput | number
    totalOrdersProcessed?: IntFieldUpdateOperationsInput | number
    totalOrdersFailed?: IntFieldUpdateOperationsInput | number
    totalItemsProcessed?: IntFieldUpdateOperationsInput | number
    totalItemsFailed?: IntFieldUpdateOperationsInput | number
    totalCustomersUpserted?: IntFieldUpdateOperationsInput | number
    totalProductsUpserted?: IntFieldUpdateOperationsInput | number
    avgProcessingTimePerOrder?: IntFieldUpdateOperationsInput | number
    maxProcessingTimePerOrder?: IntFieldUpdateOperationsInput | number
    minProcessingTimePerOrder?: IntFieldUpdateOperationsInput | number
    totalProcessingTime?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncMetricsCreateManyInput = {
    id?: string
    syncId: string
    totalApiCalls?: number
    totalOrdersProcessed?: number
    totalOrdersFailed?: number
    totalItemsProcessed?: number
    totalItemsFailed?: number
    totalCustomersUpserted?: number
    totalProductsUpserted?: number
    avgProcessingTimePerOrder?: number
    maxProcessingTimePerOrder?: number
    minProcessingTimePerOrder?: number
    totalProcessingTime?: number
    startTime: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
  }

  export type SyncMetricsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncId?: StringFieldUpdateOperationsInput | string
    totalApiCalls?: IntFieldUpdateOperationsInput | number
    totalOrdersProcessed?: IntFieldUpdateOperationsInput | number
    totalOrdersFailed?: IntFieldUpdateOperationsInput | number
    totalItemsProcessed?: IntFieldUpdateOperationsInput | number
    totalItemsFailed?: IntFieldUpdateOperationsInput | number
    totalCustomersUpserted?: IntFieldUpdateOperationsInput | number
    totalProductsUpserted?: IntFieldUpdateOperationsInput | number
    avgProcessingTimePerOrder?: IntFieldUpdateOperationsInput | number
    maxProcessingTimePerOrder?: IntFieldUpdateOperationsInput | number
    minProcessingTimePerOrder?: IntFieldUpdateOperationsInput | number
    totalProcessingTime?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncMetricsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncId?: StringFieldUpdateOperationsInput | string
    totalApiCalls?: IntFieldUpdateOperationsInput | number
    totalOrdersProcessed?: IntFieldUpdateOperationsInput | number
    totalOrdersFailed?: IntFieldUpdateOperationsInput | number
    totalItemsProcessed?: IntFieldUpdateOperationsInput | number
    totalItemsFailed?: IntFieldUpdateOperationsInput | number
    totalCustomersUpserted?: IntFieldUpdateOperationsInput | number
    totalProductsUpserted?: IntFieldUpdateOperationsInput | number
    avgProcessingTimePerOrder?: IntFieldUpdateOperationsInput | number
    maxProcessingTimePerOrder?: IntFieldUpdateOperationsInput | number
    minProcessingTimePerOrder?: IntFieldUpdateOperationsInput | number
    totalProcessingTime?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiCallLogCreateInput = {
    id?: string
    scriptName: string
    orderId: number
    orderNumber?: string | null
    marketplace?: string | null
    aiProvider: string
    modelUsed: string
    promptSent: string
    rawResponse: string
    processingTimeMs: number
    success: boolean
    errorMessage?: string | null
    tasksGenerated?: number
    needsReviewCount?: number
    createdAt?: Date | string
  }

  export type AiCallLogUncheckedCreateInput = {
    id?: string
    scriptName: string
    orderId: number
    orderNumber?: string | null
    marketplace?: string | null
    aiProvider: string
    modelUsed: string
    promptSent: string
    rawResponse: string
    processingTimeMs: number
    success: boolean
    errorMessage?: string | null
    tasksGenerated?: number
    needsReviewCount?: number
    createdAt?: Date | string
  }

  export type AiCallLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scriptName?: StringFieldUpdateOperationsInput | string
    orderId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    aiProvider?: StringFieldUpdateOperationsInput | string
    modelUsed?: StringFieldUpdateOperationsInput | string
    promptSent?: StringFieldUpdateOperationsInput | string
    rawResponse?: StringFieldUpdateOperationsInput | string
    processingTimeMs?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    tasksGenerated?: IntFieldUpdateOperationsInput | number
    needsReviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiCallLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scriptName?: StringFieldUpdateOperationsInput | string
    orderId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    aiProvider?: StringFieldUpdateOperationsInput | string
    modelUsed?: StringFieldUpdateOperationsInput | string
    promptSent?: StringFieldUpdateOperationsInput | string
    rawResponse?: StringFieldUpdateOperationsInput | string
    processingTimeMs?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    tasksGenerated?: IntFieldUpdateOperationsInput | number
    needsReviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiCallLogCreateManyInput = {
    id?: string
    scriptName: string
    orderId: number
    orderNumber?: string | null
    marketplace?: string | null
    aiProvider: string
    modelUsed: string
    promptSent: string
    rawResponse: string
    processingTimeMs: number
    success: boolean
    errorMessage?: string | null
    tasksGenerated?: number
    needsReviewCount?: number
    createdAt?: Date | string
  }

  export type AiCallLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scriptName?: StringFieldUpdateOperationsInput | string
    orderId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    aiProvider?: StringFieldUpdateOperationsInput | string
    modelUsed?: StringFieldUpdateOperationsInput | string
    promptSent?: StringFieldUpdateOperationsInput | string
    rawResponse?: StringFieldUpdateOperationsInput | string
    processingTimeMs?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    tasksGenerated?: IntFieldUpdateOperationsInput | number
    needsReviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiCallLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scriptName?: StringFieldUpdateOperationsInput | string
    orderId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    aiProvider?: StringFieldUpdateOperationsInput | string
    modelUsed?: StringFieldUpdateOperationsInput | string
    promptSent?: StringFieldUpdateOperationsInput | string
    rawResponse?: StringFieldUpdateOperationsInput | string
    processingTimeMs?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    tasksGenerated?: IntFieldUpdateOperationsInput | number
    needsReviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetricCreateInput = {
    name: string
    value: number
    tags?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type MetricUncheckedCreateInput = {
    id?: number
    name: string
    value: number
    tags?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type MetricUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetricUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetricCreateManyInput = {
    id?: number
    name: string
    value: number
    tags?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type MetricUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetricUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiReportDefinitionCreateInput = {
    id?: string
    slug: string
    name: string
    description: string
    systemPrompt: string
    createdAt?: Date | string
    updatedAt?: Date | string
    runs?: AiReportRunCreateNestedManyWithoutReportInput
  }

  export type AiReportDefinitionUncheckedCreateInput = {
    id?: string
    slug: string
    name: string
    description: string
    systemPrompt: string
    createdAt?: Date | string
    updatedAt?: Date | string
    runs?: AiReportRunUncheckedCreateNestedManyWithoutReportInput
  }

  export type AiReportDefinitionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    systemPrompt?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runs?: AiReportRunUpdateManyWithoutReportNestedInput
  }

  export type AiReportDefinitionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    systemPrompt?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runs?: AiReportRunUncheckedUpdateManyWithoutReportNestedInput
  }

  export type AiReportDefinitionCreateManyInput = {
    id?: string
    slug: string
    name: string
    description: string
    systemPrompt: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiReportDefinitionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    systemPrompt?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiReportDefinitionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    systemPrompt?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiReportRunCreateInput = {
    id?: string
    inputJson: JsonNullValueInput | InputJsonValue
    outputJson?: NullableJsonNullValueInput | InputJsonValue
    rawResponse?: string | null
    status?: string
    errorMsg?: string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    report: AiReportDefinitionCreateNestedOneWithoutRunsInput
  }

  export type AiReportRunUncheckedCreateInput = {
    id?: string
    reportId: string
    inputJson: JsonNullValueInput | InputJsonValue
    outputJson?: NullableJsonNullValueInput | InputJsonValue
    rawResponse?: string | null
    status?: string
    errorMsg?: string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
  }

  export type AiReportRunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputJson?: JsonNullValueInput | InputJsonValue
    outputJson?: NullableJsonNullValueInput | InputJsonValue
    rawResponse?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    report?: AiReportDefinitionUpdateOneRequiredWithoutRunsNestedInput
  }

  export type AiReportRunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    inputJson?: JsonNullValueInput | InputJsonValue
    outputJson?: NullableJsonNullValueInput | InputJsonValue
    rawResponse?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiReportRunCreateManyInput = {
    id?: string
    reportId: string
    inputJson: JsonNullValueInput | InputJsonValue
    outputJson?: NullableJsonNullValueInput | InputJsonValue
    rawResponse?: string | null
    status?: string
    errorMsg?: string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
  }

  export type AiReportRunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputJson?: JsonNullValueInput | InputJsonValue
    outputJson?: NullableJsonNullValueInput | InputJsonValue
    rawResponse?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiReportRunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    inputJson?: JsonNullValueInput | InputJsonValue
    outputJson?: NullableJsonNullValueInput | InputJsonValue
    rawResponse?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type PrintOrderTaskListRelationFilter = {
    every?: PrintOrderTaskWhereInput
    some?: PrintOrderTaskWhereInput
    none?: PrintOrderTaskWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrintOrderTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelevanceInput = {
    fields: ProductOrderByRelevanceFieldEnum | ProductOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    weight?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fulfillment_sku?: SortOrder
    item_weight_units?: SortOrder
    item_weight_value?: SortOrder
    shipstation_product_id?: SortOrder
    upc?: SortOrder
    warehouse_location?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    item_weight_value?: SortOrder
    shipstation_product_id?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    weight?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fulfillment_sku?: SortOrder
    item_weight_units?: SortOrder
    item_weight_value?: SortOrder
    shipstation_product_id?: SortOrder
    upc?: SortOrder
    warehouse_location?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    weight?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fulfillment_sku?: SortOrder
    item_weight_units?: SortOrder
    item_weight_value?: SortOrder
    shipstation_product_id?: SortOrder
    upc?: SortOrder
    warehouse_location?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    item_weight_value?: SortOrder
    shipstation_product_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type EnumInternalOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InternalOrderStatus | EnumInternalOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InternalOrderStatus[]
    notIn?: $Enums.InternalOrderStatus[]
    not?: NestedEnumInternalOrderStatusFilter<$PrismaModel> | $Enums.InternalOrderStatus
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type OrderOrderByRelevanceInput = {
    fields: OrderOrderByRelevanceFieldEnum | OrderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    shipstation_order_id?: SortOrder
    shipstation_order_number?: SortOrder
    customerId?: SortOrder
    customer_name?: SortOrder
    order_status?: SortOrder
    order_key?: SortOrder
    order_date?: SortOrder
    payment_date?: SortOrder
    ship_by_date?: SortOrder
    shipping_price?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    shipping_amount_paid?: SortOrder
    shipping_tax?: SortOrder
    total_price?: SortOrder
    gift?: SortOrder
    gift_message?: SortOrder
    gift_email?: SortOrder
    requested_shipping_service?: SortOrder
    carrier_code?: SortOrder
    service_code?: SortOrder
    package_code?: SortOrder
    confirmation?: SortOrder
    tracking_number?: SortOrder
    shipped_date?: SortOrder
    warehouse_id?: SortOrder
    customer_notes?: SortOrder
    internal_notes?: SortOrder
    last_sync_date?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    marketplace?: SortOrder
    amount_paid?: SortOrder
    order_weight_units?: SortOrder
    order_weight_value?: SortOrder
    payment_method?: SortOrder
    shipstation_store_id?: SortOrder
    tag_ids?: SortOrder
    dimensions_height?: SortOrder
    dimensions_length?: SortOrder
    dimensions_units?: SortOrder
    dimensions_width?: SortOrder
    insurance_insure_shipment?: SortOrder
    insurance_insured_value?: SortOrder
    insurance_provider?: SortOrder
    internal_status?: SortOrder
    is_voided?: SortOrder
    marketplace_notified?: SortOrder
    void_date?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    shipping_price?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    shipping_amount_paid?: SortOrder
    shipping_tax?: SortOrder
    total_price?: SortOrder
    amount_paid?: SortOrder
    order_weight_value?: SortOrder
    shipstation_store_id?: SortOrder
    dimensions_height?: SortOrder
    dimensions_length?: SortOrder
    dimensions_width?: SortOrder
    insurance_insured_value?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    shipstation_order_id?: SortOrder
    shipstation_order_number?: SortOrder
    customerId?: SortOrder
    customer_name?: SortOrder
    order_status?: SortOrder
    order_key?: SortOrder
    order_date?: SortOrder
    payment_date?: SortOrder
    ship_by_date?: SortOrder
    shipping_price?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    shipping_amount_paid?: SortOrder
    shipping_tax?: SortOrder
    total_price?: SortOrder
    gift?: SortOrder
    gift_message?: SortOrder
    gift_email?: SortOrder
    requested_shipping_service?: SortOrder
    carrier_code?: SortOrder
    service_code?: SortOrder
    package_code?: SortOrder
    confirmation?: SortOrder
    tracking_number?: SortOrder
    shipped_date?: SortOrder
    warehouse_id?: SortOrder
    customer_notes?: SortOrder
    internal_notes?: SortOrder
    last_sync_date?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    marketplace?: SortOrder
    amount_paid?: SortOrder
    order_weight_units?: SortOrder
    order_weight_value?: SortOrder
    payment_method?: SortOrder
    shipstation_store_id?: SortOrder
    dimensions_height?: SortOrder
    dimensions_length?: SortOrder
    dimensions_units?: SortOrder
    dimensions_width?: SortOrder
    insurance_insure_shipment?: SortOrder
    insurance_insured_value?: SortOrder
    insurance_provider?: SortOrder
    internal_status?: SortOrder
    is_voided?: SortOrder
    marketplace_notified?: SortOrder
    void_date?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    shipstation_order_id?: SortOrder
    shipstation_order_number?: SortOrder
    customerId?: SortOrder
    customer_name?: SortOrder
    order_status?: SortOrder
    order_key?: SortOrder
    order_date?: SortOrder
    payment_date?: SortOrder
    ship_by_date?: SortOrder
    shipping_price?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    shipping_amount_paid?: SortOrder
    shipping_tax?: SortOrder
    total_price?: SortOrder
    gift?: SortOrder
    gift_message?: SortOrder
    gift_email?: SortOrder
    requested_shipping_service?: SortOrder
    carrier_code?: SortOrder
    service_code?: SortOrder
    package_code?: SortOrder
    confirmation?: SortOrder
    tracking_number?: SortOrder
    shipped_date?: SortOrder
    warehouse_id?: SortOrder
    customer_notes?: SortOrder
    internal_notes?: SortOrder
    last_sync_date?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    marketplace?: SortOrder
    amount_paid?: SortOrder
    order_weight_units?: SortOrder
    order_weight_value?: SortOrder
    payment_method?: SortOrder
    shipstation_store_id?: SortOrder
    dimensions_height?: SortOrder
    dimensions_length?: SortOrder
    dimensions_units?: SortOrder
    dimensions_width?: SortOrder
    insurance_insure_shipment?: SortOrder
    insurance_insured_value?: SortOrder
    insurance_provider?: SortOrder
    internal_status?: SortOrder
    is_voided?: SortOrder
    marketplace_notified?: SortOrder
    void_date?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    shipping_price?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    shipping_amount_paid?: SortOrder
    shipping_tax?: SortOrder
    total_price?: SortOrder
    amount_paid?: SortOrder
    order_weight_value?: SortOrder
    shipstation_store_id?: SortOrder
    dimensions_height?: SortOrder
    dimensions_length?: SortOrder
    dimensions_width?: SortOrder
    insurance_insured_value?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumInternalOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InternalOrderStatus | EnumInternalOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InternalOrderStatus[]
    notIn?: $Enums.InternalOrderStatus[]
    not?: NestedEnumInternalOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.InternalOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInternalOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumInternalOrderStatusFilter<$PrismaModel>
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelevanceInput = {
    fields: CustomerOrderByRelevanceFieldEnum | CustomerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    shipstation_customer_id?: SortOrder
    company?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    street3?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postal_code?: SortOrder
    country?: SortOrder
    country_code?: SortOrder
    customer_notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    address_verified_status?: SortOrder
    is_residential?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    shipstation_customer_id?: SortOrder
    company?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    street3?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postal_code?: SortOrder
    country?: SortOrder
    country_code?: SortOrder
    customer_notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    address_verified_status?: SortOrder
    is_residential?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    shipstation_customer_id?: SortOrder
    company?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    street3?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postal_code?: SortOrder
    country?: SortOrder
    country_code?: SortOrder
    customer_notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    address_verified_status?: SortOrder
    is_residential?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AmazonCustomizationFileNullableScalarRelationFilter = {
    is?: AmazonCustomizationFileWhereInput | null
    isNot?: AmazonCustomizationFileWhereInput | null
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type OrderItemOrderByRelevanceInput = {
    fields: OrderItemOrderByRelevanceFieldEnum | OrderItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    print_settings?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    shipstationLineItemKey?: SortOrder
    productId?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    productId?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    shipstationLineItemKey?: SortOrder
    productId?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    shipstationLineItemKey?: SortOrder
    productId?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    productId?: SortOrder
  }

  export type EnumPrintTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PrintTaskStatus | EnumPrintTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PrintTaskStatus[]
    notIn?: $Enums.PrintTaskStatus[]
    not?: NestedEnumPrintTaskStatusFilter<$PrismaModel> | $Enums.PrintTaskStatus
  }

  export type EnumStlRenderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StlRenderStatus | EnumStlRenderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StlRenderStatus[]
    notIn?: $Enums.StlRenderStatus[]
    not?: NestedEnumStlRenderStatusFilter<$PrismaModel> | $Enums.StlRenderStatus
  }

  export type OrderItemScalarRelationFilter = {
    is?: OrderItemWhereInput
    isNot?: OrderItemWhereInput
  }

  export type PrintOrderTaskOrderByRelevanceInput = {
    fields: PrintOrderTaskOrderByRelevanceFieldEnum | PrintOrderTaskOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PrintOrderTaskOrderItemIdTaskIndexCompoundUniqueInput = {
    orderItemId: number
    taskIndex: number
  }

  export type PrintOrderTaskCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    marketplace_order_number?: SortOrder
    customerId?: SortOrder
    custom_text?: SortOrder
    quantity?: SortOrder
    color_1?: SortOrder
    color_2?: SortOrder
    ship_by_date?: SortOrder
    status?: SortOrder
    stl_render_state?: SortOrder
    stl_path?: SortOrder
    render_retries?: SortOrder
    needs_review?: SortOrder
    review_reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    orderItemId?: SortOrder
    taskIndex?: SortOrder
    productId?: SortOrder
    shorthandProductName?: SortOrder
    annotation?: SortOrder
  }

  export type PrintOrderTaskAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
    render_retries?: SortOrder
    orderItemId?: SortOrder
    taskIndex?: SortOrder
    productId?: SortOrder
  }

  export type PrintOrderTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    marketplace_order_number?: SortOrder
    customerId?: SortOrder
    custom_text?: SortOrder
    quantity?: SortOrder
    color_1?: SortOrder
    color_2?: SortOrder
    ship_by_date?: SortOrder
    status?: SortOrder
    stl_render_state?: SortOrder
    stl_path?: SortOrder
    render_retries?: SortOrder
    needs_review?: SortOrder
    review_reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    orderItemId?: SortOrder
    taskIndex?: SortOrder
    productId?: SortOrder
    shorthandProductName?: SortOrder
    annotation?: SortOrder
  }

  export type PrintOrderTaskMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    marketplace_order_number?: SortOrder
    customerId?: SortOrder
    custom_text?: SortOrder
    quantity?: SortOrder
    color_1?: SortOrder
    color_2?: SortOrder
    ship_by_date?: SortOrder
    status?: SortOrder
    stl_render_state?: SortOrder
    stl_path?: SortOrder
    render_retries?: SortOrder
    needs_review?: SortOrder
    review_reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    orderItemId?: SortOrder
    taskIndex?: SortOrder
    productId?: SortOrder
    shorthandProductName?: SortOrder
    annotation?: SortOrder
  }

  export type PrintOrderTaskSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
    render_retries?: SortOrder
    orderItemId?: SortOrder
    taskIndex?: SortOrder
    productId?: SortOrder
  }

  export type EnumPrintTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrintTaskStatus | EnumPrintTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PrintTaskStatus[]
    notIn?: $Enums.PrintTaskStatus[]
    not?: NestedEnumPrintTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.PrintTaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrintTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumPrintTaskStatusFilter<$PrismaModel>
  }

  export type EnumStlRenderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StlRenderStatus | EnumStlRenderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StlRenderStatus[]
    notIn?: $Enums.StlRenderStatus[]
    not?: NestedEnumStlRenderStatusWithAggregatesFilter<$PrismaModel> | $Enums.StlRenderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStlRenderStatusFilter<$PrismaModel>
    _max?: NestedEnumStlRenderStatusFilter<$PrismaModel>
  }

  export type AmazonCustomizationFileOrderByRelevanceInput = {
    fields: AmazonCustomizationFileOrderByRelevanceFieldEnum | AmazonCustomizationFileOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AmazonCustomizationFileCountOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    originalUrl?: SortOrder
    localFilePath?: SortOrder
    downloadStatus?: SortOrder
    processingStatus?: SortOrder
    customText?: SortOrder
    color1?: SortOrder
    color2?: SortOrder
    rawJsonData?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    lastProcessedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmazonCustomizationFileAvgOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    retryCount?: SortOrder
  }

  export type AmazonCustomizationFileMaxOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    originalUrl?: SortOrder
    localFilePath?: SortOrder
    downloadStatus?: SortOrder
    processingStatus?: SortOrder
    customText?: SortOrder
    color1?: SortOrder
    color2?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    lastProcessedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmazonCustomizationFileMinOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    originalUrl?: SortOrder
    localFilePath?: SortOrder
    downloadStatus?: SortOrder
    processingStatus?: SortOrder
    customText?: SortOrder
    color1?: SortOrder
    color2?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    lastProcessedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmazonCustomizationFileSumOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    retryCount?: SortOrder
  }

  export type system_logsOrderByRelevanceInput = {
    fields: system_logsOrderByRelevanceFieldEnum | system_logsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type system_logsCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    level?: SortOrder
    timestamp?: SortOrder
  }

  export type system_logsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type system_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    level?: SortOrder
    timestamp?: SortOrder
  }

  export type system_logsMinOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    level?: SortOrder
    timestamp?: SortOrder
  }

  export type system_logsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagOrderByRelevanceInput = {
    fields: TagOrderByRelevanceFieldEnum | TagOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    shipstation_tag_id?: SortOrder
    name?: SortOrder
    color_hex?: SortOrder
    last_synced?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    id?: SortOrder
    shipstation_tag_id?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    shipstation_tag_id?: SortOrder
    name?: SortOrder
    color_hex?: SortOrder
    last_synced?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    shipstation_tag_id?: SortOrder
    name?: SortOrder
    color_hex?: SortOrder
    last_synced?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    id?: SortOrder
    shipstation_tag_id?: SortOrder
  }

  export type ScriptRunLogOrderByRelevanceInput = {
    fields: ScriptRunLogOrderByRelevanceFieldEnum | ScriptRunLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ScriptRunLogCountOrderByAggregateInput = {
    id?: SortOrder
    scriptName?: SortOrder
    runStartedAt?: SortOrder
    runEndedAt?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    errorStack?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type ScriptRunLogAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ScriptRunLogMaxOrderByAggregateInput = {
    id?: SortOrder
    scriptName?: SortOrder
    runStartedAt?: SortOrder
    runEndedAt?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    errorStack?: SortOrder
    createdAt?: SortOrder
  }

  export type ScriptRunLogMinOrderByAggregateInput = {
    id?: SortOrder
    scriptName?: SortOrder
    runStartedAt?: SortOrder
    runEndedAt?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    errorStack?: SortOrder
    createdAt?: SortOrder
  }

  export type ScriptRunLogSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountOrderByRelevanceInput = {
    fields: AccountOrderByRelevanceFieldEnum | AccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expires_at?: SortOrder
  }

  export type SessionOrderByRelevanceInput = {
    fields: SessionOrderByRelevanceFieldEnum | SessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type VerificationTokenOrderByRelevanceInput = {
    fields: VerificationTokenOrderByRelevanceFieldEnum | VerificationTokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type SyncProgressOrderByRelevanceInput = {
    fields: SyncProgressOrderByRelevanceFieldEnum | SyncProgressOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SyncProgressCountOrderByAggregateInput = {
    id?: SortOrder
    syncType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    totalOrders?: SortOrder
    processedOrders?: SortOrder
    failedOrders?: SortOrder
    lastProcessedOrderId?: SortOrder
    lastProcessedTimestamp?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyncProgressAvgOrderByAggregateInput = {
    totalOrders?: SortOrder
    processedOrders?: SortOrder
    failedOrders?: SortOrder
  }

  export type SyncProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    syncType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    totalOrders?: SortOrder
    processedOrders?: SortOrder
    failedOrders?: SortOrder
    lastProcessedOrderId?: SortOrder
    lastProcessedTimestamp?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyncProgressMinOrderByAggregateInput = {
    id?: SortOrder
    syncType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    totalOrders?: SortOrder
    processedOrders?: SortOrder
    failedOrders?: SortOrder
    lastProcessedOrderId?: SortOrder
    lastProcessedTimestamp?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyncProgressSumOrderByAggregateInput = {
    totalOrders?: SortOrder
    processedOrders?: SortOrder
    failedOrders?: SortOrder
  }

  export type SyncMetricsOrderByRelevanceInput = {
    fields: SyncMetricsOrderByRelevanceFieldEnum | SyncMetricsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SyncMetricsCountOrderByAggregateInput = {
    id?: SortOrder
    syncId?: SortOrder
    totalApiCalls?: SortOrder
    totalOrdersProcessed?: SortOrder
    totalOrdersFailed?: SortOrder
    totalItemsProcessed?: SortOrder
    totalItemsFailed?: SortOrder
    totalCustomersUpserted?: SortOrder
    totalProductsUpserted?: SortOrder
    avgProcessingTimePerOrder?: SortOrder
    maxProcessingTimePerOrder?: SortOrder
    minProcessingTimePerOrder?: SortOrder
    totalProcessingTime?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
  }

  export type SyncMetricsAvgOrderByAggregateInput = {
    totalApiCalls?: SortOrder
    totalOrdersProcessed?: SortOrder
    totalOrdersFailed?: SortOrder
    totalItemsProcessed?: SortOrder
    totalItemsFailed?: SortOrder
    totalCustomersUpserted?: SortOrder
    totalProductsUpserted?: SortOrder
    avgProcessingTimePerOrder?: SortOrder
    maxProcessingTimePerOrder?: SortOrder
    minProcessingTimePerOrder?: SortOrder
    totalProcessingTime?: SortOrder
  }

  export type SyncMetricsMaxOrderByAggregateInput = {
    id?: SortOrder
    syncId?: SortOrder
    totalApiCalls?: SortOrder
    totalOrdersProcessed?: SortOrder
    totalOrdersFailed?: SortOrder
    totalItemsProcessed?: SortOrder
    totalItemsFailed?: SortOrder
    totalCustomersUpserted?: SortOrder
    totalProductsUpserted?: SortOrder
    avgProcessingTimePerOrder?: SortOrder
    maxProcessingTimePerOrder?: SortOrder
    minProcessingTimePerOrder?: SortOrder
    totalProcessingTime?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
  }

  export type SyncMetricsMinOrderByAggregateInput = {
    id?: SortOrder
    syncId?: SortOrder
    totalApiCalls?: SortOrder
    totalOrdersProcessed?: SortOrder
    totalOrdersFailed?: SortOrder
    totalItemsProcessed?: SortOrder
    totalItemsFailed?: SortOrder
    totalCustomersUpserted?: SortOrder
    totalProductsUpserted?: SortOrder
    avgProcessingTimePerOrder?: SortOrder
    maxProcessingTimePerOrder?: SortOrder
    minProcessingTimePerOrder?: SortOrder
    totalProcessingTime?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
  }

  export type SyncMetricsSumOrderByAggregateInput = {
    totalApiCalls?: SortOrder
    totalOrdersProcessed?: SortOrder
    totalOrdersFailed?: SortOrder
    totalItemsProcessed?: SortOrder
    totalItemsFailed?: SortOrder
    totalCustomersUpserted?: SortOrder
    totalProductsUpserted?: SortOrder
    avgProcessingTimePerOrder?: SortOrder
    maxProcessingTimePerOrder?: SortOrder
    minProcessingTimePerOrder?: SortOrder
    totalProcessingTime?: SortOrder
  }

  export type AiCallLogOrderByRelevanceInput = {
    fields: AiCallLogOrderByRelevanceFieldEnum | AiCallLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AiCallLogCountOrderByAggregateInput = {
    id?: SortOrder
    scriptName?: SortOrder
    orderId?: SortOrder
    orderNumber?: SortOrder
    marketplace?: SortOrder
    aiProvider?: SortOrder
    modelUsed?: SortOrder
    promptSent?: SortOrder
    rawResponse?: SortOrder
    processingTimeMs?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    tasksGenerated?: SortOrder
    needsReviewCount?: SortOrder
    createdAt?: SortOrder
  }

  export type AiCallLogAvgOrderByAggregateInput = {
    orderId?: SortOrder
    processingTimeMs?: SortOrder
    tasksGenerated?: SortOrder
    needsReviewCount?: SortOrder
  }

  export type AiCallLogMaxOrderByAggregateInput = {
    id?: SortOrder
    scriptName?: SortOrder
    orderId?: SortOrder
    orderNumber?: SortOrder
    marketplace?: SortOrder
    aiProvider?: SortOrder
    modelUsed?: SortOrder
    promptSent?: SortOrder
    rawResponse?: SortOrder
    processingTimeMs?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    tasksGenerated?: SortOrder
    needsReviewCount?: SortOrder
    createdAt?: SortOrder
  }

  export type AiCallLogMinOrderByAggregateInput = {
    id?: SortOrder
    scriptName?: SortOrder
    orderId?: SortOrder
    orderNumber?: SortOrder
    marketplace?: SortOrder
    aiProvider?: SortOrder
    modelUsed?: SortOrder
    promptSent?: SortOrder
    rawResponse?: SortOrder
    processingTimeMs?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    tasksGenerated?: SortOrder
    needsReviewCount?: SortOrder
    createdAt?: SortOrder
  }

  export type AiCallLogSumOrderByAggregateInput = {
    orderId?: SortOrder
    processingTimeMs?: SortOrder
    tasksGenerated?: SortOrder
    needsReviewCount?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MetricOrderByRelevanceInput = {
    fields: MetricOrderByRelevanceFieldEnum | MetricOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MetricCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    tags?: SortOrder
    timestamp?: SortOrder
  }

  export type MetricAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type MetricMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    timestamp?: SortOrder
  }

  export type MetricMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    timestamp?: SortOrder
  }

  export type MetricSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AiReportRunListRelationFilter = {
    every?: AiReportRunWhereInput
    some?: AiReportRunWhereInput
    none?: AiReportRunWhereInput
  }

  export type AiReportRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiReportDefinitionOrderByRelevanceInput = {
    fields: AiReportDefinitionOrderByRelevanceFieldEnum | AiReportDefinitionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AiReportDefinitionCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    systemPrompt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiReportDefinitionMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    systemPrompt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiReportDefinitionMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    systemPrompt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AiReportDefinitionScalarRelationFilter = {
    is?: AiReportDefinitionWhereInput
    isNot?: AiReportDefinitionWhereInput
  }

  export type AiReportRunOrderByRelevanceInput = {
    fields: AiReportRunOrderByRelevanceFieldEnum | AiReportRunOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AiReportRunCountOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    inputJson?: SortOrder
    outputJson?: SortOrder
    rawResponse?: SortOrder
    status?: SortOrder
    errorMsg?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrder
  }

  export type AiReportRunMaxOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    rawResponse?: SortOrder
    status?: SortOrder
    errorMsg?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrder
  }

  export type AiReportRunMinOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    rawResponse?: SortOrder
    status?: SortOrder
    errorMsg?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type PrintOrderTaskCreateNestedManyWithoutProductInput = {
    create?: XOR<PrintOrderTaskCreateWithoutProductInput, PrintOrderTaskUncheckedCreateWithoutProductInput> | PrintOrderTaskCreateWithoutProductInput[] | PrintOrderTaskUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PrintOrderTaskCreateOrConnectWithoutProductInput | PrintOrderTaskCreateOrConnectWithoutProductInput[]
    createMany?: PrintOrderTaskCreateManyProductInputEnvelope
    connect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type PrintOrderTaskUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PrintOrderTaskCreateWithoutProductInput, PrintOrderTaskUncheckedCreateWithoutProductInput> | PrintOrderTaskCreateWithoutProductInput[] | PrintOrderTaskUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PrintOrderTaskCreateOrConnectWithoutProductInput | PrintOrderTaskCreateOrConnectWithoutProductInput[]
    createMany?: PrintOrderTaskCreateManyProductInputEnvelope
    connect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type PrintOrderTaskUpdateManyWithoutProductNestedInput = {
    create?: XOR<PrintOrderTaskCreateWithoutProductInput, PrintOrderTaskUncheckedCreateWithoutProductInput> | PrintOrderTaskCreateWithoutProductInput[] | PrintOrderTaskUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PrintOrderTaskCreateOrConnectWithoutProductInput | PrintOrderTaskCreateOrConnectWithoutProductInput[]
    upsert?: PrintOrderTaskUpsertWithWhereUniqueWithoutProductInput | PrintOrderTaskUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PrintOrderTaskCreateManyProductInputEnvelope
    set?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    disconnect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    delete?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    connect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    update?: PrintOrderTaskUpdateWithWhereUniqueWithoutProductInput | PrintOrderTaskUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PrintOrderTaskUpdateManyWithWhereWithoutProductInput | PrintOrderTaskUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PrintOrderTaskScalarWhereInput | PrintOrderTaskScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type PrintOrderTaskUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PrintOrderTaskCreateWithoutProductInput, PrintOrderTaskUncheckedCreateWithoutProductInput> | PrintOrderTaskCreateWithoutProductInput[] | PrintOrderTaskUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PrintOrderTaskCreateOrConnectWithoutProductInput | PrintOrderTaskCreateOrConnectWithoutProductInput[]
    upsert?: PrintOrderTaskUpsertWithWhereUniqueWithoutProductInput | PrintOrderTaskUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PrintOrderTaskCreateManyProductInputEnvelope
    set?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    disconnect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    delete?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    connect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    update?: PrintOrderTaskUpdateWithWhereUniqueWithoutProductInput | PrintOrderTaskUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PrintOrderTaskUpdateManyWithWhereWithoutProductInput | PrintOrderTaskUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PrintOrderTaskScalarWhereInput | PrintOrderTaskScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type PrintOrderTaskCreateNestedManyWithoutOrderInput = {
    create?: XOR<PrintOrderTaskCreateWithoutOrderInput, PrintOrderTaskUncheckedCreateWithoutOrderInput> | PrintOrderTaskCreateWithoutOrderInput[] | PrintOrderTaskUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PrintOrderTaskCreateOrConnectWithoutOrderInput | PrintOrderTaskCreateOrConnectWithoutOrderInput[]
    createMany?: PrintOrderTaskCreateManyOrderInputEnvelope
    connect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type PrintOrderTaskUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PrintOrderTaskCreateWithoutOrderInput, PrintOrderTaskUncheckedCreateWithoutOrderInput> | PrintOrderTaskCreateWithoutOrderInput[] | PrintOrderTaskUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PrintOrderTaskCreateOrConnectWithoutOrderInput | PrintOrderTaskCreateOrConnectWithoutOrderInput[]
    createMany?: PrintOrderTaskCreateManyOrderInputEnvelope
    connect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type EnumInternalOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.InternalOrderStatus
  }

  export type CustomerUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    upsert?: CustomerUpsertWithoutOrdersInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrdersInput, CustomerUpdateWithoutOrdersInput>, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type PrintOrderTaskUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PrintOrderTaskCreateWithoutOrderInput, PrintOrderTaskUncheckedCreateWithoutOrderInput> | PrintOrderTaskCreateWithoutOrderInput[] | PrintOrderTaskUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PrintOrderTaskCreateOrConnectWithoutOrderInput | PrintOrderTaskCreateOrConnectWithoutOrderInput[]
    upsert?: PrintOrderTaskUpsertWithWhereUniqueWithoutOrderInput | PrintOrderTaskUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PrintOrderTaskCreateManyOrderInputEnvelope
    set?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    disconnect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    delete?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    connect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    update?: PrintOrderTaskUpdateWithWhereUniqueWithoutOrderInput | PrintOrderTaskUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PrintOrderTaskUpdateManyWithWhereWithoutOrderInput | PrintOrderTaskUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PrintOrderTaskScalarWhereInput | PrintOrderTaskScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type PrintOrderTaskUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PrintOrderTaskCreateWithoutOrderInput, PrintOrderTaskUncheckedCreateWithoutOrderInput> | PrintOrderTaskCreateWithoutOrderInput[] | PrintOrderTaskUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PrintOrderTaskCreateOrConnectWithoutOrderInput | PrintOrderTaskCreateOrConnectWithoutOrderInput[]
    upsert?: PrintOrderTaskUpsertWithWhereUniqueWithoutOrderInput | PrintOrderTaskUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PrintOrderTaskCreateManyOrderInputEnvelope
    set?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    disconnect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    delete?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    connect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    update?: PrintOrderTaskUpdateWithWhereUniqueWithoutOrderInput | PrintOrderTaskUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PrintOrderTaskUpdateManyWithWhereWithoutOrderInput | PrintOrderTaskUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PrintOrderTaskScalarWhereInput | PrintOrderTaskScalarWhereInput[]
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type PrintOrderTaskCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PrintOrderTaskCreateWithoutCustomerInput, PrintOrderTaskUncheckedCreateWithoutCustomerInput> | PrintOrderTaskCreateWithoutCustomerInput[] | PrintOrderTaskUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PrintOrderTaskCreateOrConnectWithoutCustomerInput | PrintOrderTaskCreateOrConnectWithoutCustomerInput[]
    createMany?: PrintOrderTaskCreateManyCustomerInputEnvelope
    connect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type PrintOrderTaskUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PrintOrderTaskCreateWithoutCustomerInput, PrintOrderTaskUncheckedCreateWithoutCustomerInput> | PrintOrderTaskCreateWithoutCustomerInput[] | PrintOrderTaskUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PrintOrderTaskCreateOrConnectWithoutCustomerInput | PrintOrderTaskCreateOrConnectWithoutCustomerInput[]
    createMany?: PrintOrderTaskCreateManyCustomerInputEnvelope
    connect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type PrintOrderTaskUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PrintOrderTaskCreateWithoutCustomerInput, PrintOrderTaskUncheckedCreateWithoutCustomerInput> | PrintOrderTaskCreateWithoutCustomerInput[] | PrintOrderTaskUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PrintOrderTaskCreateOrConnectWithoutCustomerInput | PrintOrderTaskCreateOrConnectWithoutCustomerInput[]
    upsert?: PrintOrderTaskUpsertWithWhereUniqueWithoutCustomerInput | PrintOrderTaskUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PrintOrderTaskCreateManyCustomerInputEnvelope
    set?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    disconnect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    delete?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    connect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    update?: PrintOrderTaskUpdateWithWhereUniqueWithoutCustomerInput | PrintOrderTaskUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PrintOrderTaskUpdateManyWithWhereWithoutCustomerInput | PrintOrderTaskUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PrintOrderTaskScalarWhereInput | PrintOrderTaskScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type PrintOrderTaskUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PrintOrderTaskCreateWithoutCustomerInput, PrintOrderTaskUncheckedCreateWithoutCustomerInput> | PrintOrderTaskCreateWithoutCustomerInput[] | PrintOrderTaskUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PrintOrderTaskCreateOrConnectWithoutCustomerInput | PrintOrderTaskCreateOrConnectWithoutCustomerInput[]
    upsert?: PrintOrderTaskUpsertWithWhereUniqueWithoutCustomerInput | PrintOrderTaskUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PrintOrderTaskCreateManyCustomerInputEnvelope
    set?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    disconnect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    delete?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    connect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    update?: PrintOrderTaskUpdateWithWhereUniqueWithoutCustomerInput | PrintOrderTaskUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PrintOrderTaskUpdateManyWithWhereWithoutCustomerInput | PrintOrderTaskUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PrintOrderTaskScalarWhereInput | PrintOrderTaskScalarWhereInput[]
  }

  export type AmazonCustomizationFileCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<AmazonCustomizationFileCreateWithoutOrderItemInput, AmazonCustomizationFileUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: AmazonCustomizationFileCreateOrConnectWithoutOrderItemInput
    connect?: AmazonCustomizationFileWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type PrintOrderTaskCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<PrintOrderTaskCreateWithoutOrderItemInput, PrintOrderTaskUncheckedCreateWithoutOrderItemInput> | PrintOrderTaskCreateWithoutOrderItemInput[] | PrintOrderTaskUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: PrintOrderTaskCreateOrConnectWithoutOrderItemInput | PrintOrderTaskCreateOrConnectWithoutOrderItemInput[]
    createMany?: PrintOrderTaskCreateManyOrderItemInputEnvelope
    connect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
  }

  export type AmazonCustomizationFileUncheckedCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<AmazonCustomizationFileCreateWithoutOrderItemInput, AmazonCustomizationFileUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: AmazonCustomizationFileCreateOrConnectWithoutOrderItemInput
    connect?: AmazonCustomizationFileWhereUniqueInput
  }

  export type PrintOrderTaskUncheckedCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<PrintOrderTaskCreateWithoutOrderItemInput, PrintOrderTaskUncheckedCreateWithoutOrderItemInput> | PrintOrderTaskCreateWithoutOrderItemInput[] | PrintOrderTaskUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: PrintOrderTaskCreateOrConnectWithoutOrderItemInput | PrintOrderTaskCreateOrConnectWithoutOrderItemInput[]
    createMany?: PrintOrderTaskCreateManyOrderItemInputEnvelope
    connect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
  }

  export type AmazonCustomizationFileUpdateOneWithoutOrderItemNestedInput = {
    create?: XOR<AmazonCustomizationFileCreateWithoutOrderItemInput, AmazonCustomizationFileUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: AmazonCustomizationFileCreateOrConnectWithoutOrderItemInput
    upsert?: AmazonCustomizationFileUpsertWithoutOrderItemInput
    disconnect?: AmazonCustomizationFileWhereInput | boolean
    delete?: AmazonCustomizationFileWhereInput | boolean
    connect?: AmazonCustomizationFileWhereUniqueInput
    update?: XOR<XOR<AmazonCustomizationFileUpdateToOneWithWhereWithoutOrderItemInput, AmazonCustomizationFileUpdateWithoutOrderItemInput>, AmazonCustomizationFileUncheckedUpdateWithoutOrderItemInput>
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type PrintOrderTaskUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<PrintOrderTaskCreateWithoutOrderItemInput, PrintOrderTaskUncheckedCreateWithoutOrderItemInput> | PrintOrderTaskCreateWithoutOrderItemInput[] | PrintOrderTaskUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: PrintOrderTaskCreateOrConnectWithoutOrderItemInput | PrintOrderTaskCreateOrConnectWithoutOrderItemInput[]
    upsert?: PrintOrderTaskUpsertWithWhereUniqueWithoutOrderItemInput | PrintOrderTaskUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: PrintOrderTaskCreateManyOrderItemInputEnvelope
    set?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    disconnect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    delete?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    connect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    update?: PrintOrderTaskUpdateWithWhereUniqueWithoutOrderItemInput | PrintOrderTaskUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: PrintOrderTaskUpdateManyWithWhereWithoutOrderItemInput | PrintOrderTaskUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: PrintOrderTaskScalarWhereInput | PrintOrderTaskScalarWhereInput[]
  }

  export type AmazonCustomizationFileUncheckedUpdateOneWithoutOrderItemNestedInput = {
    create?: XOR<AmazonCustomizationFileCreateWithoutOrderItemInput, AmazonCustomizationFileUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: AmazonCustomizationFileCreateOrConnectWithoutOrderItemInput
    upsert?: AmazonCustomizationFileUpsertWithoutOrderItemInput
    disconnect?: AmazonCustomizationFileWhereInput | boolean
    delete?: AmazonCustomizationFileWhereInput | boolean
    connect?: AmazonCustomizationFileWhereUniqueInput
    update?: XOR<XOR<AmazonCustomizationFileUpdateToOneWithWhereWithoutOrderItemInput, AmazonCustomizationFileUpdateWithoutOrderItemInput>, AmazonCustomizationFileUncheckedUpdateWithoutOrderItemInput>
  }

  export type PrintOrderTaskUncheckedUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<PrintOrderTaskCreateWithoutOrderItemInput, PrintOrderTaskUncheckedCreateWithoutOrderItemInput> | PrintOrderTaskCreateWithoutOrderItemInput[] | PrintOrderTaskUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: PrintOrderTaskCreateOrConnectWithoutOrderItemInput | PrintOrderTaskCreateOrConnectWithoutOrderItemInput[]
    upsert?: PrintOrderTaskUpsertWithWhereUniqueWithoutOrderItemInput | PrintOrderTaskUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: PrintOrderTaskCreateManyOrderItemInputEnvelope
    set?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    disconnect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    delete?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    connect?: PrintOrderTaskWhereUniqueInput | PrintOrderTaskWhereUniqueInput[]
    update?: PrintOrderTaskUpdateWithWhereUniqueWithoutOrderItemInput | PrintOrderTaskUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: PrintOrderTaskUpdateManyWithWhereWithoutOrderItemInput | PrintOrderTaskUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: PrintOrderTaskScalarWhereInput | PrintOrderTaskScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutPrintTasksInput = {
    create?: XOR<CustomerCreateWithoutPrintTasksInput, CustomerUncheckedCreateWithoutPrintTasksInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPrintTasksInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutPrintTasksInput = {
    create?: XOR<OrderCreateWithoutPrintTasksInput, OrderUncheckedCreateWithoutPrintTasksInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPrintTasksInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderItemCreateNestedOneWithoutPrintTasksInput = {
    create?: XOR<OrderItemCreateWithoutPrintTasksInput, OrderItemUncheckedCreateWithoutPrintTasksInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutPrintTasksInput
    connect?: OrderItemWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutPrintTasksInput = {
    create?: XOR<ProductCreateWithoutPrintTasksInput, ProductUncheckedCreateWithoutPrintTasksInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPrintTasksInput
    connect?: ProductWhereUniqueInput
  }

  export type EnumPrintTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.PrintTaskStatus
  }

  export type EnumStlRenderStatusFieldUpdateOperationsInput = {
    set?: $Enums.StlRenderStatus
  }

  export type CustomerUpdateOneWithoutPrintTasksNestedInput = {
    create?: XOR<CustomerCreateWithoutPrintTasksInput, CustomerUncheckedCreateWithoutPrintTasksInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPrintTasksInput
    upsert?: CustomerUpsertWithoutPrintTasksInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPrintTasksInput, CustomerUpdateWithoutPrintTasksInput>, CustomerUncheckedUpdateWithoutPrintTasksInput>
  }

  export type OrderUpdateOneRequiredWithoutPrintTasksNestedInput = {
    create?: XOR<OrderCreateWithoutPrintTasksInput, OrderUncheckedCreateWithoutPrintTasksInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPrintTasksInput
    upsert?: OrderUpsertWithoutPrintTasksInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPrintTasksInput, OrderUpdateWithoutPrintTasksInput>, OrderUncheckedUpdateWithoutPrintTasksInput>
  }

  export type OrderItemUpdateOneRequiredWithoutPrintTasksNestedInput = {
    create?: XOR<OrderItemCreateWithoutPrintTasksInput, OrderItemUncheckedCreateWithoutPrintTasksInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutPrintTasksInput
    upsert?: OrderItemUpsertWithoutPrintTasksInput
    connect?: OrderItemWhereUniqueInput
    update?: XOR<XOR<OrderItemUpdateToOneWithWhereWithoutPrintTasksInput, OrderItemUpdateWithoutPrintTasksInput>, OrderItemUncheckedUpdateWithoutPrintTasksInput>
  }

  export type ProductUpdateOneRequiredWithoutPrintTasksNestedInput = {
    create?: XOR<ProductCreateWithoutPrintTasksInput, ProductUncheckedCreateWithoutPrintTasksInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPrintTasksInput
    upsert?: ProductUpsertWithoutPrintTasksInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPrintTasksInput, ProductUpdateWithoutPrintTasksInput>, ProductUncheckedUpdateWithoutPrintTasksInput>
  }

  export type OrderItemCreateNestedOneWithoutAmazonCustomizationFilesInput = {
    create?: XOR<OrderItemCreateWithoutAmazonCustomizationFilesInput, OrderItemUncheckedCreateWithoutAmazonCustomizationFilesInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutAmazonCustomizationFilesInput
    connect?: OrderItemWhereUniqueInput
  }

  export type OrderItemUpdateOneRequiredWithoutAmazonCustomizationFilesNestedInput = {
    create?: XOR<OrderItemCreateWithoutAmazonCustomizationFilesInput, OrderItemUncheckedCreateWithoutAmazonCustomizationFilesInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutAmazonCustomizationFilesInput
    upsert?: OrderItemUpsertWithoutAmazonCustomizationFilesInput
    connect?: OrderItemWhereUniqueInput
    update?: XOR<XOR<OrderItemUpdateToOneWithWhereWithoutAmazonCustomizationFilesInput, OrderItemUpdateWithoutAmazonCustomizationFilesInput>, OrderItemUncheckedUpdateWithoutAmazonCustomizationFilesInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AiReportRunCreateNestedManyWithoutReportInput = {
    create?: XOR<AiReportRunCreateWithoutReportInput, AiReportRunUncheckedCreateWithoutReportInput> | AiReportRunCreateWithoutReportInput[] | AiReportRunUncheckedCreateWithoutReportInput[]
    connectOrCreate?: AiReportRunCreateOrConnectWithoutReportInput | AiReportRunCreateOrConnectWithoutReportInput[]
    createMany?: AiReportRunCreateManyReportInputEnvelope
    connect?: AiReportRunWhereUniqueInput | AiReportRunWhereUniqueInput[]
  }

  export type AiReportRunUncheckedCreateNestedManyWithoutReportInput = {
    create?: XOR<AiReportRunCreateWithoutReportInput, AiReportRunUncheckedCreateWithoutReportInput> | AiReportRunCreateWithoutReportInput[] | AiReportRunUncheckedCreateWithoutReportInput[]
    connectOrCreate?: AiReportRunCreateOrConnectWithoutReportInput | AiReportRunCreateOrConnectWithoutReportInput[]
    createMany?: AiReportRunCreateManyReportInputEnvelope
    connect?: AiReportRunWhereUniqueInput | AiReportRunWhereUniqueInput[]
  }

  export type AiReportRunUpdateManyWithoutReportNestedInput = {
    create?: XOR<AiReportRunCreateWithoutReportInput, AiReportRunUncheckedCreateWithoutReportInput> | AiReportRunCreateWithoutReportInput[] | AiReportRunUncheckedCreateWithoutReportInput[]
    connectOrCreate?: AiReportRunCreateOrConnectWithoutReportInput | AiReportRunCreateOrConnectWithoutReportInput[]
    upsert?: AiReportRunUpsertWithWhereUniqueWithoutReportInput | AiReportRunUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: AiReportRunCreateManyReportInputEnvelope
    set?: AiReportRunWhereUniqueInput | AiReportRunWhereUniqueInput[]
    disconnect?: AiReportRunWhereUniqueInput | AiReportRunWhereUniqueInput[]
    delete?: AiReportRunWhereUniqueInput | AiReportRunWhereUniqueInput[]
    connect?: AiReportRunWhereUniqueInput | AiReportRunWhereUniqueInput[]
    update?: AiReportRunUpdateWithWhereUniqueWithoutReportInput | AiReportRunUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: AiReportRunUpdateManyWithWhereWithoutReportInput | AiReportRunUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: AiReportRunScalarWhereInput | AiReportRunScalarWhereInput[]
  }

  export type AiReportRunUncheckedUpdateManyWithoutReportNestedInput = {
    create?: XOR<AiReportRunCreateWithoutReportInput, AiReportRunUncheckedCreateWithoutReportInput> | AiReportRunCreateWithoutReportInput[] | AiReportRunUncheckedCreateWithoutReportInput[]
    connectOrCreate?: AiReportRunCreateOrConnectWithoutReportInput | AiReportRunCreateOrConnectWithoutReportInput[]
    upsert?: AiReportRunUpsertWithWhereUniqueWithoutReportInput | AiReportRunUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: AiReportRunCreateManyReportInputEnvelope
    set?: AiReportRunWhereUniqueInput | AiReportRunWhereUniqueInput[]
    disconnect?: AiReportRunWhereUniqueInput | AiReportRunWhereUniqueInput[]
    delete?: AiReportRunWhereUniqueInput | AiReportRunWhereUniqueInput[]
    connect?: AiReportRunWhereUniqueInput | AiReportRunWhereUniqueInput[]
    update?: AiReportRunUpdateWithWhereUniqueWithoutReportInput | AiReportRunUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: AiReportRunUpdateManyWithWhereWithoutReportInput | AiReportRunUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: AiReportRunScalarWhereInput | AiReportRunScalarWhereInput[]
  }

  export type AiReportDefinitionCreateNestedOneWithoutRunsInput = {
    create?: XOR<AiReportDefinitionCreateWithoutRunsInput, AiReportDefinitionUncheckedCreateWithoutRunsInput>
    connectOrCreate?: AiReportDefinitionCreateOrConnectWithoutRunsInput
    connect?: AiReportDefinitionWhereUniqueInput
  }

  export type AiReportDefinitionUpdateOneRequiredWithoutRunsNestedInput = {
    create?: XOR<AiReportDefinitionCreateWithoutRunsInput, AiReportDefinitionUncheckedCreateWithoutRunsInput>
    connectOrCreate?: AiReportDefinitionCreateOrConnectWithoutRunsInput
    upsert?: AiReportDefinitionUpsertWithoutRunsInput
    connect?: AiReportDefinitionWhereUniqueInput
    update?: XOR<XOR<AiReportDefinitionUpdateToOneWithWhereWithoutRunsInput, AiReportDefinitionUpdateWithoutRunsInput>, AiReportDefinitionUncheckedUpdateWithoutRunsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumInternalOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InternalOrderStatus | EnumInternalOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InternalOrderStatus[]
    notIn?: $Enums.InternalOrderStatus[]
    not?: NestedEnumInternalOrderStatusFilter<$PrismaModel> | $Enums.InternalOrderStatus
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumInternalOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InternalOrderStatus | EnumInternalOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InternalOrderStatus[]
    notIn?: $Enums.InternalOrderStatus[]
    not?: NestedEnumInternalOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.InternalOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInternalOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumInternalOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumPrintTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PrintTaskStatus | EnumPrintTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PrintTaskStatus[]
    notIn?: $Enums.PrintTaskStatus[]
    not?: NestedEnumPrintTaskStatusFilter<$PrismaModel> | $Enums.PrintTaskStatus
  }

  export type NestedEnumStlRenderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StlRenderStatus | EnumStlRenderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StlRenderStatus[]
    notIn?: $Enums.StlRenderStatus[]
    not?: NestedEnumStlRenderStatusFilter<$PrismaModel> | $Enums.StlRenderStatus
  }

  export type NestedEnumPrintTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrintTaskStatus | EnumPrintTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PrintTaskStatus[]
    notIn?: $Enums.PrintTaskStatus[]
    not?: NestedEnumPrintTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.PrintTaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrintTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumPrintTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumStlRenderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StlRenderStatus | EnumStlRenderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StlRenderStatus[]
    notIn?: $Enums.StlRenderStatus[]
    not?: NestedEnumStlRenderStatusWithAggregatesFilter<$PrismaModel> | $Enums.StlRenderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStlRenderStatusFilter<$PrismaModel>
    _max?: NestedEnumStlRenderStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type OrderItemCreateWithoutProductInput = {
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    shipstationLineItemKey?: string | null
    amazonCustomizationFiles?: AmazonCustomizationFileCreateNestedOneWithoutOrderItemInput
    order: OrderCreateNestedOneWithoutItemsInput
    printTasks?: PrintOrderTaskCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: number
    orderId: number
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    shipstationLineItemKey?: string | null
    amazonCustomizationFiles?: AmazonCustomizationFileUncheckedCreateNestedOneWithoutOrderItemInput
    printTasks?: PrintOrderTaskUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type PrintOrderTaskCreateWithoutProductInput = {
    marketplace_order_number?: string | null
    custom_text?: string | null
    quantity?: number
    color_1?: string | null
    color_2?: string | null
    ship_by_date?: Date | string | null
    status?: $Enums.PrintTaskStatus
    stl_render_state?: $Enums.StlRenderStatus
    stl_path?: string | null
    render_retries?: number
    needs_review?: boolean
    review_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    taskIndex: number
    shorthandProductName?: string | null
    annotation?: string | null
    customer?: CustomerCreateNestedOneWithoutPrintTasksInput
    order: OrderCreateNestedOneWithoutPrintTasksInput
    orderItem: OrderItemCreateNestedOneWithoutPrintTasksInput
  }

  export type PrintOrderTaskUncheckedCreateWithoutProductInput = {
    id?: number
    orderId: number
    marketplace_order_number?: string | null
    customerId?: number | null
    custom_text?: string | null
    quantity?: number
    color_1?: string | null
    color_2?: string | null
    ship_by_date?: Date | string | null
    status?: $Enums.PrintTaskStatus
    stl_render_state?: $Enums.StlRenderStatus
    stl_path?: string | null
    render_retries?: number
    needs_review?: boolean
    review_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    orderItemId: number
    taskIndex: number
    shorthandProductName?: string | null
    annotation?: string | null
  }

  export type PrintOrderTaskCreateOrConnectWithoutProductInput = {
    where: PrintOrderTaskWhereUniqueInput
    create: XOR<PrintOrderTaskCreateWithoutProductInput, PrintOrderTaskUncheckedCreateWithoutProductInput>
  }

  export type PrintOrderTaskCreateManyProductInputEnvelope = {
    data: PrintOrderTaskCreateManyProductInput | PrintOrderTaskCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    unit_price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    print_settings?: JsonNullableFilter<"OrderItem">
    created_at?: DateTimeFilter<"OrderItem"> | Date | string
    updated_at?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    shipstationLineItemKey?: StringNullableFilter<"OrderItem"> | string | null
    productId?: IntFilter<"OrderItem"> | number
  }

  export type PrintOrderTaskUpsertWithWhereUniqueWithoutProductInput = {
    where: PrintOrderTaskWhereUniqueInput
    update: XOR<PrintOrderTaskUpdateWithoutProductInput, PrintOrderTaskUncheckedUpdateWithoutProductInput>
    create: XOR<PrintOrderTaskCreateWithoutProductInput, PrintOrderTaskUncheckedCreateWithoutProductInput>
  }

  export type PrintOrderTaskUpdateWithWhereUniqueWithoutProductInput = {
    where: PrintOrderTaskWhereUniqueInput
    data: XOR<PrintOrderTaskUpdateWithoutProductInput, PrintOrderTaskUncheckedUpdateWithoutProductInput>
  }

  export type PrintOrderTaskUpdateManyWithWhereWithoutProductInput = {
    where: PrintOrderTaskScalarWhereInput
    data: XOR<PrintOrderTaskUpdateManyMutationInput, PrintOrderTaskUncheckedUpdateManyWithoutProductInput>
  }

  export type PrintOrderTaskScalarWhereInput = {
    AND?: PrintOrderTaskScalarWhereInput | PrintOrderTaskScalarWhereInput[]
    OR?: PrintOrderTaskScalarWhereInput[]
    NOT?: PrintOrderTaskScalarWhereInput | PrintOrderTaskScalarWhereInput[]
    id?: IntFilter<"PrintOrderTask"> | number
    orderId?: IntFilter<"PrintOrderTask"> | number
    marketplace_order_number?: StringNullableFilter<"PrintOrderTask"> | string | null
    customerId?: IntNullableFilter<"PrintOrderTask"> | number | null
    custom_text?: StringNullableFilter<"PrintOrderTask"> | string | null
    quantity?: IntFilter<"PrintOrderTask"> | number
    color_1?: StringNullableFilter<"PrintOrderTask"> | string | null
    color_2?: StringNullableFilter<"PrintOrderTask"> | string | null
    ship_by_date?: DateTimeNullableFilter<"PrintOrderTask"> | Date | string | null
    status?: EnumPrintTaskStatusFilter<"PrintOrderTask"> | $Enums.PrintTaskStatus
    stl_render_state?: EnumStlRenderStatusFilter<"PrintOrderTask"> | $Enums.StlRenderStatus
    stl_path?: StringNullableFilter<"PrintOrderTask"> | string | null
    render_retries?: IntFilter<"PrintOrderTask"> | number
    needs_review?: BoolFilter<"PrintOrderTask"> | boolean
    review_reason?: StringNullableFilter<"PrintOrderTask"> | string | null
    created_at?: DateTimeFilter<"PrintOrderTask"> | Date | string
    updated_at?: DateTimeNullableFilter<"PrintOrderTask"> | Date | string | null
    orderItemId?: IntFilter<"PrintOrderTask"> | number
    taskIndex?: IntFilter<"PrintOrderTask"> | number
    productId?: IntFilter<"PrintOrderTask"> | number
    shorthandProductName?: StringNullableFilter<"PrintOrderTask"> | string | null
    annotation?: StringNullableFilter<"PrintOrderTask"> | string | null
  }

  export type CustomerCreateWithoutOrdersInput = {
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    shipstation_customer_id?: string | null
    company?: string | null
    street1?: string | null
    street2?: string | null
    street3?: string | null
    city?: string | null
    state?: string | null
    postal_code?: string | null
    country?: string | null
    country_code?: string | null
    customer_notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    address_verified_status?: string | null
    is_residential?: boolean | null
    printTasks?: PrintOrderTaskCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    shipstation_customer_id?: string | null
    company?: string | null
    street1?: string | null
    street2?: string | null
    street3?: string | null
    city?: string | null
    state?: string | null
    postal_code?: string | null
    country?: string | null
    country_code?: string | null
    customer_notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    address_verified_status?: string | null
    is_residential?: boolean | null
    printTasks?: PrintOrderTaskUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    shipstationLineItemKey?: string | null
    amazonCustomizationFiles?: AmazonCustomizationFileCreateNestedOneWithoutOrderItemInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
    printTasks?: PrintOrderTaskCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    shipstationLineItemKey?: string | null
    productId: number
    amazonCustomizationFiles?: AmazonCustomizationFileUncheckedCreateNestedOneWithoutOrderItemInput
    printTasks?: PrintOrderTaskUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PrintOrderTaskCreateWithoutOrderInput = {
    marketplace_order_number?: string | null
    custom_text?: string | null
    quantity?: number
    color_1?: string | null
    color_2?: string | null
    ship_by_date?: Date | string | null
    status?: $Enums.PrintTaskStatus
    stl_render_state?: $Enums.StlRenderStatus
    stl_path?: string | null
    render_retries?: number
    needs_review?: boolean
    review_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    taskIndex: number
    shorthandProductName?: string | null
    annotation?: string | null
    customer?: CustomerCreateNestedOneWithoutPrintTasksInput
    orderItem: OrderItemCreateNestedOneWithoutPrintTasksInput
    product: ProductCreateNestedOneWithoutPrintTasksInput
  }

  export type PrintOrderTaskUncheckedCreateWithoutOrderInput = {
    id?: number
    marketplace_order_number?: string | null
    customerId?: number | null
    custom_text?: string | null
    quantity?: number
    color_1?: string | null
    color_2?: string | null
    ship_by_date?: Date | string | null
    status?: $Enums.PrintTaskStatus
    stl_render_state?: $Enums.StlRenderStatus
    stl_path?: string | null
    render_retries?: number
    needs_review?: boolean
    review_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    orderItemId: number
    taskIndex: number
    productId: number
    shorthandProductName?: string | null
    annotation?: string | null
  }

  export type PrintOrderTaskCreateOrConnectWithoutOrderInput = {
    where: PrintOrderTaskWhereUniqueInput
    create: XOR<PrintOrderTaskCreateWithoutOrderInput, PrintOrderTaskUncheckedCreateWithoutOrderInput>
  }

  export type PrintOrderTaskCreateManyOrderInputEnvelope = {
    data: PrintOrderTaskCreateManyOrderInput | PrintOrderTaskCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateWithoutOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: NullableStringFieldUpdateOperationsInput | string | null
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    street3?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    customer_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_verified_status?: NullableStringFieldUpdateOperationsInput | string | null
    is_residential?: NullableBoolFieldUpdateOperationsInput | boolean | null
    printTasks?: PrintOrderTaskUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: NullableStringFieldUpdateOperationsInput | string | null
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    street3?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    customer_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_verified_status?: NullableStringFieldUpdateOperationsInput | string | null
    is_residential?: NullableBoolFieldUpdateOperationsInput | boolean | null
    printTasks?: PrintOrderTaskUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type PrintOrderTaskUpsertWithWhereUniqueWithoutOrderInput = {
    where: PrintOrderTaskWhereUniqueInput
    update: XOR<PrintOrderTaskUpdateWithoutOrderInput, PrintOrderTaskUncheckedUpdateWithoutOrderInput>
    create: XOR<PrintOrderTaskCreateWithoutOrderInput, PrintOrderTaskUncheckedCreateWithoutOrderInput>
  }

  export type PrintOrderTaskUpdateWithWhereUniqueWithoutOrderInput = {
    where: PrintOrderTaskWhereUniqueInput
    data: XOR<PrintOrderTaskUpdateWithoutOrderInput, PrintOrderTaskUncheckedUpdateWithoutOrderInput>
  }

  export type PrintOrderTaskUpdateManyWithWhereWithoutOrderInput = {
    where: PrintOrderTaskScalarWhereInput
    data: XOR<PrintOrderTaskUpdateManyMutationInput, PrintOrderTaskUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderCreateWithoutCustomerInput = {
    shipstation_order_id?: string | null
    shipstation_order_number?: string | null
    customer_name?: string | null
    order_status?: string
    order_key?: string | null
    order_date?: Date | string | null
    payment_date?: Date | string | null
    ship_by_date?: Date | string | null
    shipping_price?: Decimal | DecimalJsLike | number | string | null
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: Decimal | DecimalJsLike | number | string | null
    shipping_tax?: Decimal | DecimalJsLike | number | string | null
    total_price?: Decimal | DecimalJsLike | number | string
    gift?: boolean
    gift_message?: string | null
    gift_email?: string | null
    requested_shipping_service?: string | null
    carrier_code?: string | null
    service_code?: string | null
    package_code?: string | null
    confirmation?: string | null
    tracking_number?: string | null
    shipped_date?: Date | string | null
    warehouse_id?: string | null
    customer_notes?: string | null
    internal_notes?: string | null
    last_sync_date?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    marketplace?: string | null
    amount_paid?: Decimal | DecimalJsLike | number | string | null
    order_weight_units?: string | null
    order_weight_value?: Decimal | DecimalJsLike | number | string | null
    payment_method?: string | null
    shipstation_store_id?: number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: Decimal | DecimalJsLike | number | string | null
    dimensions_length?: Decimal | DecimalJsLike | number | string | null
    dimensions_units?: string | null
    dimensions_width?: Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: boolean | null
    insurance_insured_value?: Decimal | DecimalJsLike | number | string | null
    insurance_provider?: string | null
    internal_status?: $Enums.InternalOrderStatus
    is_voided?: boolean | null
    marketplace_notified?: boolean
    void_date?: Date | string | null
    items?: OrderItemCreateNestedManyWithoutOrderInput
    printTasks?: PrintOrderTaskCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: number
    shipstation_order_id?: string | null
    shipstation_order_number?: string | null
    customer_name?: string | null
    order_status?: string
    order_key?: string | null
    order_date?: Date | string | null
    payment_date?: Date | string | null
    ship_by_date?: Date | string | null
    shipping_price?: Decimal | DecimalJsLike | number | string | null
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: Decimal | DecimalJsLike | number | string | null
    shipping_tax?: Decimal | DecimalJsLike | number | string | null
    total_price?: Decimal | DecimalJsLike | number | string
    gift?: boolean
    gift_message?: string | null
    gift_email?: string | null
    requested_shipping_service?: string | null
    carrier_code?: string | null
    service_code?: string | null
    package_code?: string | null
    confirmation?: string | null
    tracking_number?: string | null
    shipped_date?: Date | string | null
    warehouse_id?: string | null
    customer_notes?: string | null
    internal_notes?: string | null
    last_sync_date?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    marketplace?: string | null
    amount_paid?: Decimal | DecimalJsLike | number | string | null
    order_weight_units?: string | null
    order_weight_value?: Decimal | DecimalJsLike | number | string | null
    payment_method?: string | null
    shipstation_store_id?: number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: Decimal | DecimalJsLike | number | string | null
    dimensions_length?: Decimal | DecimalJsLike | number | string | null
    dimensions_units?: string | null
    dimensions_width?: Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: boolean | null
    insurance_insured_value?: Decimal | DecimalJsLike | number | string | null
    insurance_provider?: string | null
    internal_status?: $Enums.InternalOrderStatus
    is_voided?: boolean | null
    marketplace_notified?: boolean
    void_date?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    printTasks?: PrintOrderTaskUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type PrintOrderTaskCreateWithoutCustomerInput = {
    marketplace_order_number?: string | null
    custom_text?: string | null
    quantity?: number
    color_1?: string | null
    color_2?: string | null
    ship_by_date?: Date | string | null
    status?: $Enums.PrintTaskStatus
    stl_render_state?: $Enums.StlRenderStatus
    stl_path?: string | null
    render_retries?: number
    needs_review?: boolean
    review_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    taskIndex: number
    shorthandProductName?: string | null
    annotation?: string | null
    order: OrderCreateNestedOneWithoutPrintTasksInput
    orderItem: OrderItemCreateNestedOneWithoutPrintTasksInput
    product: ProductCreateNestedOneWithoutPrintTasksInput
  }

  export type PrintOrderTaskUncheckedCreateWithoutCustomerInput = {
    id?: number
    orderId: number
    marketplace_order_number?: string | null
    custom_text?: string | null
    quantity?: number
    color_1?: string | null
    color_2?: string | null
    ship_by_date?: Date | string | null
    status?: $Enums.PrintTaskStatus
    stl_render_state?: $Enums.StlRenderStatus
    stl_path?: string | null
    render_retries?: number
    needs_review?: boolean
    review_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    orderItemId: number
    taskIndex: number
    productId: number
    shorthandProductName?: string | null
    annotation?: string | null
  }

  export type PrintOrderTaskCreateOrConnectWithoutCustomerInput = {
    where: PrintOrderTaskWhereUniqueInput
    create: XOR<PrintOrderTaskCreateWithoutCustomerInput, PrintOrderTaskUncheckedCreateWithoutCustomerInput>
  }

  export type PrintOrderTaskCreateManyCustomerInputEnvelope = {
    data: PrintOrderTaskCreateManyCustomerInput | PrintOrderTaskCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: IntFilter<"Order"> | number
    shipstation_order_id?: StringNullableFilter<"Order"> | string | null
    shipstation_order_number?: StringNullableFilter<"Order"> | string | null
    customerId?: IntNullableFilter<"Order"> | number | null
    customer_name?: StringNullableFilter<"Order"> | string | null
    order_status?: StringFilter<"Order"> | string
    order_key?: StringNullableFilter<"Order"> | string | null
    order_date?: DateTimeNullableFilter<"Order"> | Date | string | null
    payment_date?: DateTimeNullableFilter<"Order"> | Date | string | null
    ship_by_date?: DateTimeNullableFilter<"Order"> | Date | string | null
    shipping_price?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    tax_amount?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    discount_amount?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    shipping_tax?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    total_price?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    gift?: BoolFilter<"Order"> | boolean
    gift_message?: StringNullableFilter<"Order"> | string | null
    gift_email?: StringNullableFilter<"Order"> | string | null
    requested_shipping_service?: StringNullableFilter<"Order"> | string | null
    carrier_code?: StringNullableFilter<"Order"> | string | null
    service_code?: StringNullableFilter<"Order"> | string | null
    package_code?: StringNullableFilter<"Order"> | string | null
    confirmation?: StringNullableFilter<"Order"> | string | null
    tracking_number?: StringNullableFilter<"Order"> | string | null
    shipped_date?: DateTimeNullableFilter<"Order"> | Date | string | null
    warehouse_id?: StringNullableFilter<"Order"> | string | null
    customer_notes?: StringNullableFilter<"Order"> | string | null
    internal_notes?: StringNullableFilter<"Order"> | string | null
    last_sync_date?: DateTimeNullableFilter<"Order"> | Date | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    created_at?: DateTimeFilter<"Order"> | Date | string
    updated_at?: DateTimeNullableFilter<"Order"> | Date | string | null
    marketplace?: StringNullableFilter<"Order"> | string | null
    amount_paid?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    order_weight_units?: StringNullableFilter<"Order"> | string | null
    order_weight_value?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    payment_method?: StringNullableFilter<"Order"> | string | null
    shipstation_store_id?: IntNullableFilter<"Order"> | number | null
    tag_ids?: JsonNullableFilter<"Order">
    dimensions_height?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    dimensions_length?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    dimensions_units?: StringNullableFilter<"Order"> | string | null
    dimensions_width?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: BoolNullableFilter<"Order"> | boolean | null
    insurance_insured_value?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    insurance_provider?: StringNullableFilter<"Order"> | string | null
    internal_status?: EnumInternalOrderStatusFilter<"Order"> | $Enums.InternalOrderStatus
    is_voided?: BoolNullableFilter<"Order"> | boolean | null
    marketplace_notified?: BoolFilter<"Order"> | boolean
    void_date?: DateTimeNullableFilter<"Order"> | Date | string | null
  }

  export type PrintOrderTaskUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PrintOrderTaskWhereUniqueInput
    update: XOR<PrintOrderTaskUpdateWithoutCustomerInput, PrintOrderTaskUncheckedUpdateWithoutCustomerInput>
    create: XOR<PrintOrderTaskCreateWithoutCustomerInput, PrintOrderTaskUncheckedCreateWithoutCustomerInput>
  }

  export type PrintOrderTaskUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PrintOrderTaskWhereUniqueInput
    data: XOR<PrintOrderTaskUpdateWithoutCustomerInput, PrintOrderTaskUncheckedUpdateWithoutCustomerInput>
  }

  export type PrintOrderTaskUpdateManyWithWhereWithoutCustomerInput = {
    where: PrintOrderTaskScalarWhereInput
    data: XOR<PrintOrderTaskUpdateManyMutationInput, PrintOrderTaskUncheckedUpdateManyWithoutCustomerInput>
  }

  export type AmazonCustomizationFileCreateWithoutOrderItemInput = {
    originalUrl: string
    localFilePath?: string | null
    downloadStatus?: string
    processingStatus?: string
    customText?: string | null
    color1?: string | null
    color2?: string | null
    rawJsonData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    lastProcessedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmazonCustomizationFileUncheckedCreateWithoutOrderItemInput = {
    id?: number
    originalUrl: string
    localFilePath?: string | null
    downloadStatus?: string
    processingStatus?: string
    customText?: string | null
    color1?: string | null
    color2?: string | null
    rawJsonData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    lastProcessedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmazonCustomizationFileCreateOrConnectWithoutOrderItemInput = {
    where: AmazonCustomizationFileWhereUniqueInput
    create: XOR<AmazonCustomizationFileCreateWithoutOrderItemInput, AmazonCustomizationFileUncheckedCreateWithoutOrderItemInput>
  }

  export type OrderCreateWithoutItemsInput = {
    shipstation_order_id?: string | null
    shipstation_order_number?: string | null
    customer_name?: string | null
    order_status?: string
    order_key?: string | null
    order_date?: Date | string | null
    payment_date?: Date | string | null
    ship_by_date?: Date | string | null
    shipping_price?: Decimal | DecimalJsLike | number | string | null
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: Decimal | DecimalJsLike | number | string | null
    shipping_tax?: Decimal | DecimalJsLike | number | string | null
    total_price?: Decimal | DecimalJsLike | number | string
    gift?: boolean
    gift_message?: string | null
    gift_email?: string | null
    requested_shipping_service?: string | null
    carrier_code?: string | null
    service_code?: string | null
    package_code?: string | null
    confirmation?: string | null
    tracking_number?: string | null
    shipped_date?: Date | string | null
    warehouse_id?: string | null
    customer_notes?: string | null
    internal_notes?: string | null
    last_sync_date?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    marketplace?: string | null
    amount_paid?: Decimal | DecimalJsLike | number | string | null
    order_weight_units?: string | null
    order_weight_value?: Decimal | DecimalJsLike | number | string | null
    payment_method?: string | null
    shipstation_store_id?: number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: Decimal | DecimalJsLike | number | string | null
    dimensions_length?: Decimal | DecimalJsLike | number | string | null
    dimensions_units?: string | null
    dimensions_width?: Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: boolean | null
    insurance_insured_value?: Decimal | DecimalJsLike | number | string | null
    insurance_provider?: string | null
    internal_status?: $Enums.InternalOrderStatus
    is_voided?: boolean | null
    marketplace_notified?: boolean
    void_date?: Date | string | null
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    printTasks?: PrintOrderTaskCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: number
    shipstation_order_id?: string | null
    shipstation_order_number?: string | null
    customerId?: number | null
    customer_name?: string | null
    order_status?: string
    order_key?: string | null
    order_date?: Date | string | null
    payment_date?: Date | string | null
    ship_by_date?: Date | string | null
    shipping_price?: Decimal | DecimalJsLike | number | string | null
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: Decimal | DecimalJsLike | number | string | null
    shipping_tax?: Decimal | DecimalJsLike | number | string | null
    total_price?: Decimal | DecimalJsLike | number | string
    gift?: boolean
    gift_message?: string | null
    gift_email?: string | null
    requested_shipping_service?: string | null
    carrier_code?: string | null
    service_code?: string | null
    package_code?: string | null
    confirmation?: string | null
    tracking_number?: string | null
    shipped_date?: Date | string | null
    warehouse_id?: string | null
    customer_notes?: string | null
    internal_notes?: string | null
    last_sync_date?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    marketplace?: string | null
    amount_paid?: Decimal | DecimalJsLike | number | string | null
    order_weight_units?: string | null
    order_weight_value?: Decimal | DecimalJsLike | number | string | null
    payment_method?: string | null
    shipstation_store_id?: number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: Decimal | DecimalJsLike | number | string | null
    dimensions_length?: Decimal | DecimalJsLike | number | string | null
    dimensions_units?: string | null
    dimensions_width?: Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: boolean | null
    insurance_insured_value?: Decimal | DecimalJsLike | number | string | null
    insurance_provider?: string | null
    internal_status?: $Enums.InternalOrderStatus
    is_voided?: boolean | null
    marketplace_notified?: boolean
    void_date?: Date | string | null
    printTasks?: PrintOrderTaskUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    sku?: string | null
    name: string
    imageUrl?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fulfillment_sku?: string | null
    item_weight_units?: string | null
    item_weight_value?: Decimal | DecimalJsLike | number | string | null
    shipstation_product_id?: number | null
    upc?: string | null
    warehouse_location?: string | null
    printTasks?: PrintOrderTaskCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    sku?: string | null
    name: string
    imageUrl?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fulfillment_sku?: string | null
    item_weight_units?: string | null
    item_weight_value?: Decimal | DecimalJsLike | number | string | null
    shipstation_product_id?: number | null
    upc?: string | null
    warehouse_location?: string | null
    printTasks?: PrintOrderTaskUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type PrintOrderTaskCreateWithoutOrderItemInput = {
    marketplace_order_number?: string | null
    custom_text?: string | null
    quantity?: number
    color_1?: string | null
    color_2?: string | null
    ship_by_date?: Date | string | null
    status?: $Enums.PrintTaskStatus
    stl_render_state?: $Enums.StlRenderStatus
    stl_path?: string | null
    render_retries?: number
    needs_review?: boolean
    review_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    taskIndex: number
    shorthandProductName?: string | null
    annotation?: string | null
    customer?: CustomerCreateNestedOneWithoutPrintTasksInput
    order: OrderCreateNestedOneWithoutPrintTasksInput
    product: ProductCreateNestedOneWithoutPrintTasksInput
  }

  export type PrintOrderTaskUncheckedCreateWithoutOrderItemInput = {
    id?: number
    orderId: number
    marketplace_order_number?: string | null
    customerId?: number | null
    custom_text?: string | null
    quantity?: number
    color_1?: string | null
    color_2?: string | null
    ship_by_date?: Date | string | null
    status?: $Enums.PrintTaskStatus
    stl_render_state?: $Enums.StlRenderStatus
    stl_path?: string | null
    render_retries?: number
    needs_review?: boolean
    review_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    taskIndex: number
    productId: number
    shorthandProductName?: string | null
    annotation?: string | null
  }

  export type PrintOrderTaskCreateOrConnectWithoutOrderItemInput = {
    where: PrintOrderTaskWhereUniqueInput
    create: XOR<PrintOrderTaskCreateWithoutOrderItemInput, PrintOrderTaskUncheckedCreateWithoutOrderItemInput>
  }

  export type PrintOrderTaskCreateManyOrderItemInputEnvelope = {
    data: PrintOrderTaskCreateManyOrderItemInput | PrintOrderTaskCreateManyOrderItemInput[]
    skipDuplicates?: boolean
  }

  export type AmazonCustomizationFileUpsertWithoutOrderItemInput = {
    update: XOR<AmazonCustomizationFileUpdateWithoutOrderItemInput, AmazonCustomizationFileUncheckedUpdateWithoutOrderItemInput>
    create: XOR<AmazonCustomizationFileCreateWithoutOrderItemInput, AmazonCustomizationFileUncheckedCreateWithoutOrderItemInput>
    where?: AmazonCustomizationFileWhereInput
  }

  export type AmazonCustomizationFileUpdateToOneWithWhereWithoutOrderItemInput = {
    where?: AmazonCustomizationFileWhereInput
    data: XOR<AmazonCustomizationFileUpdateWithoutOrderItemInput, AmazonCustomizationFileUncheckedUpdateWithoutOrderItemInput>
  }

  export type AmazonCustomizationFileUpdateWithoutOrderItemInput = {
    originalUrl?: StringFieldUpdateOperationsInput | string
    localFilePath?: NullableStringFieldUpdateOperationsInput | string | null
    downloadStatus?: StringFieldUpdateOperationsInput | string
    processingStatus?: StringFieldUpdateOperationsInput | string
    customText?: NullableStringFieldUpdateOperationsInput | string | null
    color1?: NullableStringFieldUpdateOperationsInput | string | null
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    rawJsonData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmazonCustomizationFileUncheckedUpdateWithoutOrderItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalUrl?: StringFieldUpdateOperationsInput | string
    localFilePath?: NullableStringFieldUpdateOperationsInput | string | null
    downloadStatus?: StringFieldUpdateOperationsInput | string
    processingStatus?: StringFieldUpdateOperationsInput | string
    customText?: NullableStringFieldUpdateOperationsInput | string | null
    color1?: NullableStringFieldUpdateOperationsInput | string | null
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    rawJsonData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    shipstation_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    order_status?: StringFieldUpdateOperationsInput | string
    order_key?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipping_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_tax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gift?: BoolFieldUpdateOperationsInput | boolean
    gift_message?: NullableStringFieldUpdateOperationsInput | string | null
    gift_email?: NullableStringFieldUpdateOperationsInput | string | null
    requested_shipping_service?: NullableStringFieldUpdateOperationsInput | string | null
    carrier_code?: NullableStringFieldUpdateOperationsInput | string | null
    service_code?: NullableStringFieldUpdateOperationsInput | string | null
    package_code?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipped_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warehouse_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_notes?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    order_weight_units?: NullableStringFieldUpdateOperationsInput | string | null
    order_weight_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_store_id?: NullableIntFieldUpdateOperationsInput | number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_units?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions_width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance_insured_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    internal_status?: EnumInternalOrderStatusFieldUpdateOperationsInput | $Enums.InternalOrderStatus
    is_voided?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketplace_notified?: BoolFieldUpdateOperationsInput | boolean
    void_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    printTasks?: PrintOrderTaskUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipstation_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    order_status?: StringFieldUpdateOperationsInput | string
    order_key?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipping_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_tax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gift?: BoolFieldUpdateOperationsInput | boolean
    gift_message?: NullableStringFieldUpdateOperationsInput | string | null
    gift_email?: NullableStringFieldUpdateOperationsInput | string | null
    requested_shipping_service?: NullableStringFieldUpdateOperationsInput | string | null
    carrier_code?: NullableStringFieldUpdateOperationsInput | string | null
    service_code?: NullableStringFieldUpdateOperationsInput | string | null
    package_code?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipped_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warehouse_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_notes?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    order_weight_units?: NullableStringFieldUpdateOperationsInput | string | null
    order_weight_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_store_id?: NullableIntFieldUpdateOperationsInput | number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_units?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions_width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance_insured_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    internal_status?: EnumInternalOrderStatusFieldUpdateOperationsInput | $Enums.InternalOrderStatus
    is_voided?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketplace_notified?: BoolFieldUpdateOperationsInput | boolean
    void_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printTasks?: PrintOrderTaskUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfillment_sku?: NullableStringFieldUpdateOperationsInput | string | null
    item_weight_units?: NullableStringFieldUpdateOperationsInput | string | null
    item_weight_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipstation_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    warehouse_location?: NullableStringFieldUpdateOperationsInput | string | null
    printTasks?: PrintOrderTaskUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfillment_sku?: NullableStringFieldUpdateOperationsInput | string | null
    item_weight_units?: NullableStringFieldUpdateOperationsInput | string | null
    item_weight_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipstation_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    warehouse_location?: NullableStringFieldUpdateOperationsInput | string | null
    printTasks?: PrintOrderTaskUncheckedUpdateManyWithoutProductNestedInput
  }

  export type PrintOrderTaskUpsertWithWhereUniqueWithoutOrderItemInput = {
    where: PrintOrderTaskWhereUniqueInput
    update: XOR<PrintOrderTaskUpdateWithoutOrderItemInput, PrintOrderTaskUncheckedUpdateWithoutOrderItemInput>
    create: XOR<PrintOrderTaskCreateWithoutOrderItemInput, PrintOrderTaskUncheckedCreateWithoutOrderItemInput>
  }

  export type PrintOrderTaskUpdateWithWhereUniqueWithoutOrderItemInput = {
    where: PrintOrderTaskWhereUniqueInput
    data: XOR<PrintOrderTaskUpdateWithoutOrderItemInput, PrintOrderTaskUncheckedUpdateWithoutOrderItemInput>
  }

  export type PrintOrderTaskUpdateManyWithWhereWithoutOrderItemInput = {
    where: PrintOrderTaskScalarWhereInput
    data: XOR<PrintOrderTaskUpdateManyMutationInput, PrintOrderTaskUncheckedUpdateManyWithoutOrderItemInput>
  }

  export type CustomerCreateWithoutPrintTasksInput = {
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    shipstation_customer_id?: string | null
    company?: string | null
    street1?: string | null
    street2?: string | null
    street3?: string | null
    city?: string | null
    state?: string | null
    postal_code?: string | null
    country?: string | null
    country_code?: string | null
    customer_notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    address_verified_status?: string | null
    is_residential?: boolean | null
    orders?: OrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPrintTasksInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    shipstation_customer_id?: string | null
    company?: string | null
    street1?: string | null
    street2?: string | null
    street3?: string | null
    city?: string | null
    state?: string | null
    postal_code?: string | null
    country?: string | null
    country_code?: string | null
    customer_notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    address_verified_status?: string | null
    is_residential?: boolean | null
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPrintTasksInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPrintTasksInput, CustomerUncheckedCreateWithoutPrintTasksInput>
  }

  export type OrderCreateWithoutPrintTasksInput = {
    shipstation_order_id?: string | null
    shipstation_order_number?: string | null
    customer_name?: string | null
    order_status?: string
    order_key?: string | null
    order_date?: Date | string | null
    payment_date?: Date | string | null
    ship_by_date?: Date | string | null
    shipping_price?: Decimal | DecimalJsLike | number | string | null
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: Decimal | DecimalJsLike | number | string | null
    shipping_tax?: Decimal | DecimalJsLike | number | string | null
    total_price?: Decimal | DecimalJsLike | number | string
    gift?: boolean
    gift_message?: string | null
    gift_email?: string | null
    requested_shipping_service?: string | null
    carrier_code?: string | null
    service_code?: string | null
    package_code?: string | null
    confirmation?: string | null
    tracking_number?: string | null
    shipped_date?: Date | string | null
    warehouse_id?: string | null
    customer_notes?: string | null
    internal_notes?: string | null
    last_sync_date?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    marketplace?: string | null
    amount_paid?: Decimal | DecimalJsLike | number | string | null
    order_weight_units?: string | null
    order_weight_value?: Decimal | DecimalJsLike | number | string | null
    payment_method?: string | null
    shipstation_store_id?: number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: Decimal | DecimalJsLike | number | string | null
    dimensions_length?: Decimal | DecimalJsLike | number | string | null
    dimensions_units?: string | null
    dimensions_width?: Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: boolean | null
    insurance_insured_value?: Decimal | DecimalJsLike | number | string | null
    insurance_provider?: string | null
    internal_status?: $Enums.InternalOrderStatus
    is_voided?: boolean | null
    marketplace_notified?: boolean
    void_date?: Date | string | null
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPrintTasksInput = {
    id?: number
    shipstation_order_id?: string | null
    shipstation_order_number?: string | null
    customerId?: number | null
    customer_name?: string | null
    order_status?: string
    order_key?: string | null
    order_date?: Date | string | null
    payment_date?: Date | string | null
    ship_by_date?: Date | string | null
    shipping_price?: Decimal | DecimalJsLike | number | string | null
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: Decimal | DecimalJsLike | number | string | null
    shipping_tax?: Decimal | DecimalJsLike | number | string | null
    total_price?: Decimal | DecimalJsLike | number | string
    gift?: boolean
    gift_message?: string | null
    gift_email?: string | null
    requested_shipping_service?: string | null
    carrier_code?: string | null
    service_code?: string | null
    package_code?: string | null
    confirmation?: string | null
    tracking_number?: string | null
    shipped_date?: Date | string | null
    warehouse_id?: string | null
    customer_notes?: string | null
    internal_notes?: string | null
    last_sync_date?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    marketplace?: string | null
    amount_paid?: Decimal | DecimalJsLike | number | string | null
    order_weight_units?: string | null
    order_weight_value?: Decimal | DecimalJsLike | number | string | null
    payment_method?: string | null
    shipstation_store_id?: number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: Decimal | DecimalJsLike | number | string | null
    dimensions_length?: Decimal | DecimalJsLike | number | string | null
    dimensions_units?: string | null
    dimensions_width?: Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: boolean | null
    insurance_insured_value?: Decimal | DecimalJsLike | number | string | null
    insurance_provider?: string | null
    internal_status?: $Enums.InternalOrderStatus
    is_voided?: boolean | null
    marketplace_notified?: boolean
    void_date?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPrintTasksInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPrintTasksInput, OrderUncheckedCreateWithoutPrintTasksInput>
  }

  export type OrderItemCreateWithoutPrintTasksInput = {
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    shipstationLineItemKey?: string | null
    amazonCustomizationFiles?: AmazonCustomizationFileCreateNestedOneWithoutOrderItemInput
    order: OrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutPrintTasksInput = {
    id?: number
    orderId: number
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    shipstationLineItemKey?: string | null
    productId: number
    amazonCustomizationFiles?: AmazonCustomizationFileUncheckedCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutPrintTasksInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutPrintTasksInput, OrderItemUncheckedCreateWithoutPrintTasksInput>
  }

  export type ProductCreateWithoutPrintTasksInput = {
    sku?: string | null
    name: string
    imageUrl?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fulfillment_sku?: string | null
    item_weight_units?: string | null
    item_weight_value?: Decimal | DecimalJsLike | number | string | null
    shipstation_product_id?: number | null
    upc?: string | null
    warehouse_location?: string | null
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPrintTasksInput = {
    id?: number
    sku?: string | null
    name: string
    imageUrl?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fulfillment_sku?: string | null
    item_weight_units?: string | null
    item_weight_value?: Decimal | DecimalJsLike | number | string | null
    shipstation_product_id?: number | null
    upc?: string | null
    warehouse_location?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPrintTasksInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPrintTasksInput, ProductUncheckedCreateWithoutPrintTasksInput>
  }

  export type CustomerUpsertWithoutPrintTasksInput = {
    update: XOR<CustomerUpdateWithoutPrintTasksInput, CustomerUncheckedUpdateWithoutPrintTasksInput>
    create: XOR<CustomerCreateWithoutPrintTasksInput, CustomerUncheckedCreateWithoutPrintTasksInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPrintTasksInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPrintTasksInput, CustomerUncheckedUpdateWithoutPrintTasksInput>
  }

  export type CustomerUpdateWithoutPrintTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: NullableStringFieldUpdateOperationsInput | string | null
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    street3?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    customer_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_verified_status?: NullableStringFieldUpdateOperationsInput | string | null
    is_residential?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orders?: OrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPrintTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: NullableStringFieldUpdateOperationsInput | string | null
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    street3?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    customer_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_verified_status?: NullableStringFieldUpdateOperationsInput | string | null
    is_residential?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrderUpsertWithoutPrintTasksInput = {
    update: XOR<OrderUpdateWithoutPrintTasksInput, OrderUncheckedUpdateWithoutPrintTasksInput>
    create: XOR<OrderCreateWithoutPrintTasksInput, OrderUncheckedCreateWithoutPrintTasksInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPrintTasksInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPrintTasksInput, OrderUncheckedUpdateWithoutPrintTasksInput>
  }

  export type OrderUpdateWithoutPrintTasksInput = {
    shipstation_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    order_status?: StringFieldUpdateOperationsInput | string
    order_key?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipping_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_tax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gift?: BoolFieldUpdateOperationsInput | boolean
    gift_message?: NullableStringFieldUpdateOperationsInput | string | null
    gift_email?: NullableStringFieldUpdateOperationsInput | string | null
    requested_shipping_service?: NullableStringFieldUpdateOperationsInput | string | null
    carrier_code?: NullableStringFieldUpdateOperationsInput | string | null
    service_code?: NullableStringFieldUpdateOperationsInput | string | null
    package_code?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipped_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warehouse_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_notes?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    order_weight_units?: NullableStringFieldUpdateOperationsInput | string | null
    order_weight_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_store_id?: NullableIntFieldUpdateOperationsInput | number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_units?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions_width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance_insured_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    internal_status?: EnumInternalOrderStatusFieldUpdateOperationsInput | $Enums.InternalOrderStatus
    is_voided?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketplace_notified?: BoolFieldUpdateOperationsInput | boolean
    void_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPrintTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipstation_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    order_status?: StringFieldUpdateOperationsInput | string
    order_key?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipping_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_tax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gift?: BoolFieldUpdateOperationsInput | boolean
    gift_message?: NullableStringFieldUpdateOperationsInput | string | null
    gift_email?: NullableStringFieldUpdateOperationsInput | string | null
    requested_shipping_service?: NullableStringFieldUpdateOperationsInput | string | null
    carrier_code?: NullableStringFieldUpdateOperationsInput | string | null
    service_code?: NullableStringFieldUpdateOperationsInput | string | null
    package_code?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipped_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warehouse_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_notes?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    order_weight_units?: NullableStringFieldUpdateOperationsInput | string | null
    order_weight_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_store_id?: NullableIntFieldUpdateOperationsInput | number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_units?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions_width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance_insured_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    internal_status?: EnumInternalOrderStatusFieldUpdateOperationsInput | $Enums.InternalOrderStatus
    is_voided?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketplace_notified?: BoolFieldUpdateOperationsInput | boolean
    void_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderItemUpsertWithoutPrintTasksInput = {
    update: XOR<OrderItemUpdateWithoutPrintTasksInput, OrderItemUncheckedUpdateWithoutPrintTasksInput>
    create: XOR<OrderItemCreateWithoutPrintTasksInput, OrderItemUncheckedCreateWithoutPrintTasksInput>
    where?: OrderItemWhereInput
  }

  export type OrderItemUpdateToOneWithWhereWithoutPrintTasksInput = {
    where?: OrderItemWhereInput
    data: XOR<OrderItemUpdateWithoutPrintTasksInput, OrderItemUncheckedUpdateWithoutPrintTasksInput>
  }

  export type OrderItemUpdateWithoutPrintTasksInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipstationLineItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    amazonCustomizationFiles?: AmazonCustomizationFileUpdateOneWithoutOrderItemNestedInput
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutPrintTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipstationLineItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    amazonCustomizationFiles?: AmazonCustomizationFileUncheckedUpdateOneWithoutOrderItemNestedInput
  }

  export type ProductUpsertWithoutPrintTasksInput = {
    update: XOR<ProductUpdateWithoutPrintTasksInput, ProductUncheckedUpdateWithoutPrintTasksInput>
    create: XOR<ProductCreateWithoutPrintTasksInput, ProductUncheckedCreateWithoutPrintTasksInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPrintTasksInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPrintTasksInput, ProductUncheckedUpdateWithoutPrintTasksInput>
  }

  export type ProductUpdateWithoutPrintTasksInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfillment_sku?: NullableStringFieldUpdateOperationsInput | string | null
    item_weight_units?: NullableStringFieldUpdateOperationsInput | string | null
    item_weight_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipstation_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    warehouse_location?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPrintTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfillment_sku?: NullableStringFieldUpdateOperationsInput | string | null
    item_weight_units?: NullableStringFieldUpdateOperationsInput | string | null
    item_weight_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipstation_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    warehouse_location?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderItemCreateWithoutAmazonCustomizationFilesInput = {
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    shipstationLineItemKey?: string | null
    order: OrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
    printTasks?: PrintOrderTaskCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutAmazonCustomizationFilesInput = {
    id?: number
    orderId: number
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    shipstationLineItemKey?: string | null
    productId: number
    printTasks?: PrintOrderTaskUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutAmazonCustomizationFilesInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutAmazonCustomizationFilesInput, OrderItemUncheckedCreateWithoutAmazonCustomizationFilesInput>
  }

  export type OrderItemUpsertWithoutAmazonCustomizationFilesInput = {
    update: XOR<OrderItemUpdateWithoutAmazonCustomizationFilesInput, OrderItemUncheckedUpdateWithoutAmazonCustomizationFilesInput>
    create: XOR<OrderItemCreateWithoutAmazonCustomizationFilesInput, OrderItemUncheckedCreateWithoutAmazonCustomizationFilesInput>
    where?: OrderItemWhereInput
  }

  export type OrderItemUpdateToOneWithWhereWithoutAmazonCustomizationFilesInput = {
    where?: OrderItemWhereInput
    data: XOR<OrderItemUpdateWithoutAmazonCustomizationFilesInput, OrderItemUncheckedUpdateWithoutAmazonCustomizationFilesInput>
  }

  export type OrderItemUpdateWithoutAmazonCustomizationFilesInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipstationLineItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
    printTasks?: PrintOrderTaskUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutAmazonCustomizationFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipstationLineItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    printTasks?: PrintOrderTaskUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: number
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: number
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: IntFilter<"Account"> | number
    userId?: IntFilter<"Account"> | number
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: IntFilter<"Session"> | number
    sessionToken?: StringFilter<"Session"> | string
    userId?: IntFilter<"Session"> | number
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    email: string
    password: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    email: string
    password: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AiReportRunCreateWithoutReportInput = {
    id?: string
    inputJson: JsonNullValueInput | InputJsonValue
    outputJson?: NullableJsonNullValueInput | InputJsonValue
    rawResponse?: string | null
    status?: string
    errorMsg?: string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
  }

  export type AiReportRunUncheckedCreateWithoutReportInput = {
    id?: string
    inputJson: JsonNullValueInput | InputJsonValue
    outputJson?: NullableJsonNullValueInput | InputJsonValue
    rawResponse?: string | null
    status?: string
    errorMsg?: string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
  }

  export type AiReportRunCreateOrConnectWithoutReportInput = {
    where: AiReportRunWhereUniqueInput
    create: XOR<AiReportRunCreateWithoutReportInput, AiReportRunUncheckedCreateWithoutReportInput>
  }

  export type AiReportRunCreateManyReportInputEnvelope = {
    data: AiReportRunCreateManyReportInput | AiReportRunCreateManyReportInput[]
    skipDuplicates?: boolean
  }

  export type AiReportRunUpsertWithWhereUniqueWithoutReportInput = {
    where: AiReportRunWhereUniqueInput
    update: XOR<AiReportRunUpdateWithoutReportInput, AiReportRunUncheckedUpdateWithoutReportInput>
    create: XOR<AiReportRunCreateWithoutReportInput, AiReportRunUncheckedCreateWithoutReportInput>
  }

  export type AiReportRunUpdateWithWhereUniqueWithoutReportInput = {
    where: AiReportRunWhereUniqueInput
    data: XOR<AiReportRunUpdateWithoutReportInput, AiReportRunUncheckedUpdateWithoutReportInput>
  }

  export type AiReportRunUpdateManyWithWhereWithoutReportInput = {
    where: AiReportRunScalarWhereInput
    data: XOR<AiReportRunUpdateManyMutationInput, AiReportRunUncheckedUpdateManyWithoutReportInput>
  }

  export type AiReportRunScalarWhereInput = {
    AND?: AiReportRunScalarWhereInput | AiReportRunScalarWhereInput[]
    OR?: AiReportRunScalarWhereInput[]
    NOT?: AiReportRunScalarWhereInput | AiReportRunScalarWhereInput[]
    id?: StringFilter<"AiReportRun"> | string
    reportId?: StringFilter<"AiReportRun"> | string
    inputJson?: JsonFilter<"AiReportRun">
    outputJson?: JsonNullableFilter<"AiReportRun">
    rawResponse?: StringNullableFilter<"AiReportRun"> | string | null
    status?: StringFilter<"AiReportRun"> | string
    errorMsg?: StringNullableFilter<"AiReportRun"> | string | null
    createdAt?: DateTimeFilter<"AiReportRun"> | Date | string
    finishedAt?: DateTimeNullableFilter<"AiReportRun"> | Date | string | null
  }

  export type AiReportDefinitionCreateWithoutRunsInput = {
    id?: string
    slug: string
    name: string
    description: string
    systemPrompt: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiReportDefinitionUncheckedCreateWithoutRunsInput = {
    id?: string
    slug: string
    name: string
    description: string
    systemPrompt: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiReportDefinitionCreateOrConnectWithoutRunsInput = {
    where: AiReportDefinitionWhereUniqueInput
    create: XOR<AiReportDefinitionCreateWithoutRunsInput, AiReportDefinitionUncheckedCreateWithoutRunsInput>
  }

  export type AiReportDefinitionUpsertWithoutRunsInput = {
    update: XOR<AiReportDefinitionUpdateWithoutRunsInput, AiReportDefinitionUncheckedUpdateWithoutRunsInput>
    create: XOR<AiReportDefinitionCreateWithoutRunsInput, AiReportDefinitionUncheckedCreateWithoutRunsInput>
    where?: AiReportDefinitionWhereInput
  }

  export type AiReportDefinitionUpdateToOneWithWhereWithoutRunsInput = {
    where?: AiReportDefinitionWhereInput
    data: XOR<AiReportDefinitionUpdateWithoutRunsInput, AiReportDefinitionUncheckedUpdateWithoutRunsInput>
  }

  export type AiReportDefinitionUpdateWithoutRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    systemPrompt?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiReportDefinitionUncheckedUpdateWithoutRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    systemPrompt?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyProductInput = {
    id?: number
    orderId: number
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    shipstationLineItemKey?: string | null
  }

  export type PrintOrderTaskCreateManyProductInput = {
    id?: number
    orderId: number
    marketplace_order_number?: string | null
    customerId?: number | null
    custom_text?: string | null
    quantity?: number
    color_1?: string | null
    color_2?: string | null
    ship_by_date?: Date | string | null
    status?: $Enums.PrintTaskStatus
    stl_render_state?: $Enums.StlRenderStatus
    stl_path?: string | null
    render_retries?: number
    needs_review?: boolean
    review_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    orderItemId: number
    taskIndex: number
    shorthandProductName?: string | null
    annotation?: string | null
  }

  export type OrderItemUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipstationLineItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    amazonCustomizationFiles?: AmazonCustomizationFileUpdateOneWithoutOrderItemNestedInput
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    printTasks?: PrintOrderTaskUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipstationLineItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    amazonCustomizationFiles?: AmazonCustomizationFileUncheckedUpdateOneWithoutOrderItemNestedInput
    printTasks?: PrintOrderTaskUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipstationLineItemKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrintOrderTaskUpdateWithoutProductInput = {
    marketplace_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    custom_text?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    color_1?: NullableStringFieldUpdateOperationsInput | string | null
    color_2?: NullableStringFieldUpdateOperationsInput | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPrintTaskStatusFieldUpdateOperationsInput | $Enums.PrintTaskStatus
    stl_render_state?: EnumStlRenderStatusFieldUpdateOperationsInput | $Enums.StlRenderStatus
    stl_path?: NullableStringFieldUpdateOperationsInput | string | null
    render_retries?: IntFieldUpdateOperationsInput | number
    needs_review?: BoolFieldUpdateOperationsInput | boolean
    review_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskIndex?: IntFieldUpdateOperationsInput | number
    shorthandProductName?: NullableStringFieldUpdateOperationsInput | string | null
    annotation?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutPrintTasksNestedInput
    order?: OrderUpdateOneRequiredWithoutPrintTasksNestedInput
    orderItem?: OrderItemUpdateOneRequiredWithoutPrintTasksNestedInput
  }

  export type PrintOrderTaskUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    marketplace_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    custom_text?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    color_1?: NullableStringFieldUpdateOperationsInput | string | null
    color_2?: NullableStringFieldUpdateOperationsInput | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPrintTaskStatusFieldUpdateOperationsInput | $Enums.PrintTaskStatus
    stl_render_state?: EnumStlRenderStatusFieldUpdateOperationsInput | $Enums.StlRenderStatus
    stl_path?: NullableStringFieldUpdateOperationsInput | string | null
    render_retries?: IntFieldUpdateOperationsInput | number
    needs_review?: BoolFieldUpdateOperationsInput | boolean
    review_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderItemId?: IntFieldUpdateOperationsInput | number
    taskIndex?: IntFieldUpdateOperationsInput | number
    shorthandProductName?: NullableStringFieldUpdateOperationsInput | string | null
    annotation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrintOrderTaskUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    marketplace_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    custom_text?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    color_1?: NullableStringFieldUpdateOperationsInput | string | null
    color_2?: NullableStringFieldUpdateOperationsInput | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPrintTaskStatusFieldUpdateOperationsInput | $Enums.PrintTaskStatus
    stl_render_state?: EnumStlRenderStatusFieldUpdateOperationsInput | $Enums.StlRenderStatus
    stl_path?: NullableStringFieldUpdateOperationsInput | string | null
    render_retries?: IntFieldUpdateOperationsInput | number
    needs_review?: BoolFieldUpdateOperationsInput | boolean
    review_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderItemId?: IntFieldUpdateOperationsInput | number
    taskIndex?: IntFieldUpdateOperationsInput | number
    shorthandProductName?: NullableStringFieldUpdateOperationsInput | string | null
    annotation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyOrderInput = {
    id?: number
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    shipstationLineItemKey?: string | null
    productId: number
  }

  export type PrintOrderTaskCreateManyOrderInput = {
    id?: number
    marketplace_order_number?: string | null
    customerId?: number | null
    custom_text?: string | null
    quantity?: number
    color_1?: string | null
    color_2?: string | null
    ship_by_date?: Date | string | null
    status?: $Enums.PrintTaskStatus
    stl_render_state?: $Enums.StlRenderStatus
    stl_path?: string | null
    render_retries?: number
    needs_review?: boolean
    review_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    orderItemId: number
    taskIndex: number
    productId: number
    shorthandProductName?: string | null
    annotation?: string | null
  }

  export type OrderItemUpdateWithoutOrderInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipstationLineItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    amazonCustomizationFiles?: AmazonCustomizationFileUpdateOneWithoutOrderItemNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
    printTasks?: PrintOrderTaskUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipstationLineItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    amazonCustomizationFiles?: AmazonCustomizationFileUncheckedUpdateOneWithoutOrderItemNestedInput
    printTasks?: PrintOrderTaskUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    print_settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipstationLineItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type PrintOrderTaskUpdateWithoutOrderInput = {
    marketplace_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    custom_text?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    color_1?: NullableStringFieldUpdateOperationsInput | string | null
    color_2?: NullableStringFieldUpdateOperationsInput | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPrintTaskStatusFieldUpdateOperationsInput | $Enums.PrintTaskStatus
    stl_render_state?: EnumStlRenderStatusFieldUpdateOperationsInput | $Enums.StlRenderStatus
    stl_path?: NullableStringFieldUpdateOperationsInput | string | null
    render_retries?: IntFieldUpdateOperationsInput | number
    needs_review?: BoolFieldUpdateOperationsInput | boolean
    review_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskIndex?: IntFieldUpdateOperationsInput | number
    shorthandProductName?: NullableStringFieldUpdateOperationsInput | string | null
    annotation?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutPrintTasksNestedInput
    orderItem?: OrderItemUpdateOneRequiredWithoutPrintTasksNestedInput
    product?: ProductUpdateOneRequiredWithoutPrintTasksNestedInput
  }

  export type PrintOrderTaskUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketplace_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    custom_text?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    color_1?: NullableStringFieldUpdateOperationsInput | string | null
    color_2?: NullableStringFieldUpdateOperationsInput | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPrintTaskStatusFieldUpdateOperationsInput | $Enums.PrintTaskStatus
    stl_render_state?: EnumStlRenderStatusFieldUpdateOperationsInput | $Enums.StlRenderStatus
    stl_path?: NullableStringFieldUpdateOperationsInput | string | null
    render_retries?: IntFieldUpdateOperationsInput | number
    needs_review?: BoolFieldUpdateOperationsInput | boolean
    review_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderItemId?: IntFieldUpdateOperationsInput | number
    taskIndex?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    shorthandProductName?: NullableStringFieldUpdateOperationsInput | string | null
    annotation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrintOrderTaskUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketplace_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    custom_text?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    color_1?: NullableStringFieldUpdateOperationsInput | string | null
    color_2?: NullableStringFieldUpdateOperationsInput | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPrintTaskStatusFieldUpdateOperationsInput | $Enums.PrintTaskStatus
    stl_render_state?: EnumStlRenderStatusFieldUpdateOperationsInput | $Enums.StlRenderStatus
    stl_path?: NullableStringFieldUpdateOperationsInput | string | null
    render_retries?: IntFieldUpdateOperationsInput | number
    needs_review?: BoolFieldUpdateOperationsInput | boolean
    review_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderItemId?: IntFieldUpdateOperationsInput | number
    taskIndex?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    shorthandProductName?: NullableStringFieldUpdateOperationsInput | string | null
    annotation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateManyCustomerInput = {
    id?: number
    shipstation_order_id?: string | null
    shipstation_order_number?: string | null
    customer_name?: string | null
    order_status?: string
    order_key?: string | null
    order_date?: Date | string | null
    payment_date?: Date | string | null
    ship_by_date?: Date | string | null
    shipping_price?: Decimal | DecimalJsLike | number | string | null
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: Decimal | DecimalJsLike | number | string | null
    shipping_tax?: Decimal | DecimalJsLike | number | string | null
    total_price?: Decimal | DecimalJsLike | number | string
    gift?: boolean
    gift_message?: string | null
    gift_email?: string | null
    requested_shipping_service?: string | null
    carrier_code?: string | null
    service_code?: string | null
    package_code?: string | null
    confirmation?: string | null
    tracking_number?: string | null
    shipped_date?: Date | string | null
    warehouse_id?: string | null
    customer_notes?: string | null
    internal_notes?: string | null
    last_sync_date?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    marketplace?: string | null
    amount_paid?: Decimal | DecimalJsLike | number | string | null
    order_weight_units?: string | null
    order_weight_value?: Decimal | DecimalJsLike | number | string | null
    payment_method?: string | null
    shipstation_store_id?: number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: Decimal | DecimalJsLike | number | string | null
    dimensions_length?: Decimal | DecimalJsLike | number | string | null
    dimensions_units?: string | null
    dimensions_width?: Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: boolean | null
    insurance_insured_value?: Decimal | DecimalJsLike | number | string | null
    insurance_provider?: string | null
    internal_status?: $Enums.InternalOrderStatus
    is_voided?: boolean | null
    marketplace_notified?: boolean
    void_date?: Date | string | null
  }

  export type PrintOrderTaskCreateManyCustomerInput = {
    id?: number
    orderId: number
    marketplace_order_number?: string | null
    custom_text?: string | null
    quantity?: number
    color_1?: string | null
    color_2?: string | null
    ship_by_date?: Date | string | null
    status?: $Enums.PrintTaskStatus
    stl_render_state?: $Enums.StlRenderStatus
    stl_path?: string | null
    render_retries?: number
    needs_review?: boolean
    review_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    orderItemId: number
    taskIndex: number
    productId: number
    shorthandProductName?: string | null
    annotation?: string | null
  }

  export type OrderUpdateWithoutCustomerInput = {
    shipstation_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    order_status?: StringFieldUpdateOperationsInput | string
    order_key?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipping_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_tax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gift?: BoolFieldUpdateOperationsInput | boolean
    gift_message?: NullableStringFieldUpdateOperationsInput | string | null
    gift_email?: NullableStringFieldUpdateOperationsInput | string | null
    requested_shipping_service?: NullableStringFieldUpdateOperationsInput | string | null
    carrier_code?: NullableStringFieldUpdateOperationsInput | string | null
    service_code?: NullableStringFieldUpdateOperationsInput | string | null
    package_code?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipped_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warehouse_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_notes?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    order_weight_units?: NullableStringFieldUpdateOperationsInput | string | null
    order_weight_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_store_id?: NullableIntFieldUpdateOperationsInput | number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_units?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions_width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance_insured_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    internal_status?: EnumInternalOrderStatusFieldUpdateOperationsInput | $Enums.InternalOrderStatus
    is_voided?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketplace_notified?: BoolFieldUpdateOperationsInput | boolean
    void_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    printTasks?: PrintOrderTaskUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipstation_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    order_status?: StringFieldUpdateOperationsInput | string
    order_key?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipping_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_tax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gift?: BoolFieldUpdateOperationsInput | boolean
    gift_message?: NullableStringFieldUpdateOperationsInput | string | null
    gift_email?: NullableStringFieldUpdateOperationsInput | string | null
    requested_shipping_service?: NullableStringFieldUpdateOperationsInput | string | null
    carrier_code?: NullableStringFieldUpdateOperationsInput | string | null
    service_code?: NullableStringFieldUpdateOperationsInput | string | null
    package_code?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipped_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warehouse_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_notes?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    order_weight_units?: NullableStringFieldUpdateOperationsInput | string | null
    order_weight_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_store_id?: NullableIntFieldUpdateOperationsInput | number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_units?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions_width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance_insured_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    internal_status?: EnumInternalOrderStatusFieldUpdateOperationsInput | $Enums.InternalOrderStatus
    is_voided?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketplace_notified?: BoolFieldUpdateOperationsInput | boolean
    void_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    printTasks?: PrintOrderTaskUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipstation_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    order_status?: StringFieldUpdateOperationsInput | string
    order_key?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipping_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shipping_tax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gift?: BoolFieldUpdateOperationsInput | boolean
    gift_message?: NullableStringFieldUpdateOperationsInput | string | null
    gift_email?: NullableStringFieldUpdateOperationsInput | string | null
    requested_shipping_service?: NullableStringFieldUpdateOperationsInput | string | null
    carrier_code?: NullableStringFieldUpdateOperationsInput | string | null
    service_code?: NullableStringFieldUpdateOperationsInput | string | null
    package_code?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipped_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warehouse_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_notes?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    amount_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    order_weight_units?: NullableStringFieldUpdateOperationsInput | string | null
    order_weight_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    shipstation_store_id?: NullableIntFieldUpdateOperationsInput | number | null
    tag_ids?: NullableJsonNullValueInput | InputJsonValue
    dimensions_height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions_units?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions_width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_insure_shipment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance_insured_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    internal_status?: EnumInternalOrderStatusFieldUpdateOperationsInput | $Enums.InternalOrderStatus
    is_voided?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketplace_notified?: BoolFieldUpdateOperationsInput | boolean
    void_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PrintOrderTaskUpdateWithoutCustomerInput = {
    marketplace_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    custom_text?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    color_1?: NullableStringFieldUpdateOperationsInput | string | null
    color_2?: NullableStringFieldUpdateOperationsInput | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPrintTaskStatusFieldUpdateOperationsInput | $Enums.PrintTaskStatus
    stl_render_state?: EnumStlRenderStatusFieldUpdateOperationsInput | $Enums.StlRenderStatus
    stl_path?: NullableStringFieldUpdateOperationsInput | string | null
    render_retries?: IntFieldUpdateOperationsInput | number
    needs_review?: BoolFieldUpdateOperationsInput | boolean
    review_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskIndex?: IntFieldUpdateOperationsInput | number
    shorthandProductName?: NullableStringFieldUpdateOperationsInput | string | null
    annotation?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutPrintTasksNestedInput
    orderItem?: OrderItemUpdateOneRequiredWithoutPrintTasksNestedInput
    product?: ProductUpdateOneRequiredWithoutPrintTasksNestedInput
  }

  export type PrintOrderTaskUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    marketplace_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    custom_text?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    color_1?: NullableStringFieldUpdateOperationsInput | string | null
    color_2?: NullableStringFieldUpdateOperationsInput | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPrintTaskStatusFieldUpdateOperationsInput | $Enums.PrintTaskStatus
    stl_render_state?: EnumStlRenderStatusFieldUpdateOperationsInput | $Enums.StlRenderStatus
    stl_path?: NullableStringFieldUpdateOperationsInput | string | null
    render_retries?: IntFieldUpdateOperationsInput | number
    needs_review?: BoolFieldUpdateOperationsInput | boolean
    review_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderItemId?: IntFieldUpdateOperationsInput | number
    taskIndex?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    shorthandProductName?: NullableStringFieldUpdateOperationsInput | string | null
    annotation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrintOrderTaskUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    marketplace_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    custom_text?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    color_1?: NullableStringFieldUpdateOperationsInput | string | null
    color_2?: NullableStringFieldUpdateOperationsInput | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPrintTaskStatusFieldUpdateOperationsInput | $Enums.PrintTaskStatus
    stl_render_state?: EnumStlRenderStatusFieldUpdateOperationsInput | $Enums.StlRenderStatus
    stl_path?: NullableStringFieldUpdateOperationsInput | string | null
    render_retries?: IntFieldUpdateOperationsInput | number
    needs_review?: BoolFieldUpdateOperationsInput | boolean
    review_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderItemId?: IntFieldUpdateOperationsInput | number
    taskIndex?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    shorthandProductName?: NullableStringFieldUpdateOperationsInput | string | null
    annotation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrintOrderTaskCreateManyOrderItemInput = {
    id?: number
    orderId: number
    marketplace_order_number?: string | null
    customerId?: number | null
    custom_text?: string | null
    quantity?: number
    color_1?: string | null
    color_2?: string | null
    ship_by_date?: Date | string | null
    status?: $Enums.PrintTaskStatus
    stl_render_state?: $Enums.StlRenderStatus
    stl_path?: string | null
    render_retries?: number
    needs_review?: boolean
    review_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    taskIndex: number
    productId: number
    shorthandProductName?: string | null
    annotation?: string | null
  }

  export type PrintOrderTaskUpdateWithoutOrderItemInput = {
    marketplace_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    custom_text?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    color_1?: NullableStringFieldUpdateOperationsInput | string | null
    color_2?: NullableStringFieldUpdateOperationsInput | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPrintTaskStatusFieldUpdateOperationsInput | $Enums.PrintTaskStatus
    stl_render_state?: EnumStlRenderStatusFieldUpdateOperationsInput | $Enums.StlRenderStatus
    stl_path?: NullableStringFieldUpdateOperationsInput | string | null
    render_retries?: IntFieldUpdateOperationsInput | number
    needs_review?: BoolFieldUpdateOperationsInput | boolean
    review_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskIndex?: IntFieldUpdateOperationsInput | number
    shorthandProductName?: NullableStringFieldUpdateOperationsInput | string | null
    annotation?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutPrintTasksNestedInput
    order?: OrderUpdateOneRequiredWithoutPrintTasksNestedInput
    product?: ProductUpdateOneRequiredWithoutPrintTasksNestedInput
  }

  export type PrintOrderTaskUncheckedUpdateWithoutOrderItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    marketplace_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    custom_text?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    color_1?: NullableStringFieldUpdateOperationsInput | string | null
    color_2?: NullableStringFieldUpdateOperationsInput | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPrintTaskStatusFieldUpdateOperationsInput | $Enums.PrintTaskStatus
    stl_render_state?: EnumStlRenderStatusFieldUpdateOperationsInput | $Enums.StlRenderStatus
    stl_path?: NullableStringFieldUpdateOperationsInput | string | null
    render_retries?: IntFieldUpdateOperationsInput | number
    needs_review?: BoolFieldUpdateOperationsInput | boolean
    review_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskIndex?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    shorthandProductName?: NullableStringFieldUpdateOperationsInput | string | null
    annotation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrintOrderTaskUncheckedUpdateManyWithoutOrderItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    marketplace_order_number?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    custom_text?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    color_1?: NullableStringFieldUpdateOperationsInput | string | null
    color_2?: NullableStringFieldUpdateOperationsInput | string | null
    ship_by_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPrintTaskStatusFieldUpdateOperationsInput | $Enums.PrintTaskStatus
    stl_render_state?: EnumStlRenderStatusFieldUpdateOperationsInput | $Enums.StlRenderStatus
    stl_path?: NullableStringFieldUpdateOperationsInput | string | null
    render_retries?: IntFieldUpdateOperationsInput | number
    needs_review?: BoolFieldUpdateOperationsInput | boolean
    review_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskIndex?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    shorthandProductName?: NullableStringFieldUpdateOperationsInput | string | null
    annotation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyUserInput = {
    id?: number
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: number
    sessionToken: string
    expires: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiReportRunCreateManyReportInput = {
    id?: string
    inputJson: JsonNullValueInput | InputJsonValue
    outputJson?: NullableJsonNullValueInput | InputJsonValue
    rawResponse?: string | null
    status?: string
    errorMsg?: string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
  }

  export type AiReportRunUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputJson?: JsonNullValueInput | InputJsonValue
    outputJson?: NullableJsonNullValueInput | InputJsonValue
    rawResponse?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiReportRunUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputJson?: JsonNullValueInput | InputJsonValue
    outputJson?: NullableJsonNullValueInput | InputJsonValue
    rawResponse?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiReportRunUncheckedUpdateManyWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputJson?: JsonNullValueInput | InputJsonValue
    outputJson?: NullableJsonNullValueInput | InputJsonValue
    rawResponse?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}