import { execFile as execFileCb } from 'child_process'
import { randomBytes } from 'crypto'
import { promises as fs } from 'fs'
import path from 'path'
import { promisify } from 'util'

const execFile = promisify(execFileCb)

export interface OpenSCADRenderOptions {
    /** Variables to pass to OpenSCAD using -D name=value */
    variables?: Record<string, string | number>
    /** Directory to write the STL into (absolute or relative). Defaults to ./public/stl */
    outputDir?: string
    /** Custom file name (without path). If omitted, one is autogenerated */
    fileName?: string
}

/**
 * Renders a .scad file to an STL using the system‑installed `openscad` CLI.
 *
 * Example:
 * ```ts
 * const stl = await renderScadToStl('openscad/DualColour.scad', {
 *   variables: { line1: 'Hello', line2: 'World', line3: '' }
 * })
 * console.log('Created STL at', stl)
 * ```
 */
export async function renderScadToStl(
    scadPath: string,
    { variables = {}, outputDir = path.join(process.cwd(), 'public', 'stl'), fileName }: OpenSCADRenderOptions = {}
): Promise<string> {
    // Ensure source file exists
    await fs.access(scadPath)

    await fs.mkdir(outputDir, { recursive: true })

    const basename = path.basename(scadPath, path.extname(scadPath))
    const random = randomBytes(6).toString('hex')

    const finalName = fileName ?? `${basename}-${random}.stl`
    const outFile = path.join(outputDir, finalName)

    // Build argument list
    const args: string[] = []

    // Output path
    args.push('-o', outFile)

    // Variables via -D name=value
    Object.entries(variables).forEach(([key, value]) => {
        let formatted: string;
        if (Array.isArray(value)) {
            // Serialize arrays as OpenSCAD-compatible lists (e.g., ["A", "B"])
            const arr = value.map(v =>
                typeof v === 'string'
                    ? `\"${String(v).replace(/\\/g, '\\\\').replace(/\"/g, '\\\"')}\"`
                    : String(v)
            );
            formatted = `[${arr.join(', ')}]`;
        } else if (typeof value === 'string') {
            // Escape embedded double quotes and backslashes
            const safe = value.replace(/\\/g, '\\\\').replace(/\"/g, '\\\"');
            formatted = `\"${safe}\"`;
        } else {
            formatted = String(value);
        }
        args.push('-D', `${key}=${formatted}`);
    });

    // Finally, the source .scad
    args.push(scadPath)

    try {
        // Use custom fonts directory if it exists
        const customFontsDir = path.join(process.cwd(), 'fonts');
        const fontPathExists = await fs.access(customFontsDir).then(() => true).catch(() => false);

        const env = { ...process.env };
        if (fontPathExists) {
            console.log(`Using custom fonts from ${customFontsDir}`);
            env.FONTPATH = customFontsDir;
        }

        await execFile('openscad', args, {
            maxBuffer: 1024 * 1024 * 10,
            env
        })
    } catch (err) {
        const message = err instanceof Error ? err.message : String(err)
        throw new Error(`OpenSCAD failed to render STL: ${message}`)
    }

    return outFile
}

/**
 * Convenience wrapper around `renderScadToStl` for the provided DualColour.scad
 * file that ships with this repository.
 */
export async function renderDualColourTag(
    line1: string,
    line2 = '',
    line3 = '',
    options: Partial<Omit<OpenSCADRenderOptions, 'variables' | 'fileName'>> & {
        fileName?: string,
        fontNarrowWiden?: number,
        characterSpacing?: number
    } = {}
) {
    const projectRoot = process.cwd()
    const scad = path.join(projectRoot, 'openscad', 'DualColour.scad')
    return renderScadToStl(scad, {
        ...options,
        variables: {
            line1,
            line2,
            line3,
            // Add fixed width compensation values for Linux rendering
            font_narrow_widen: options.fontNarrowWiden ?? -5, // Default to -5 to make text slightly narrower
            character_spacing: options.characterSpacing ?? 0.95  // Default to 0.95 to bring characters closer together
        },
        fileName: options.fileName,
    })
}

/**
 * Renders a .scad file using configuration from a JSON file and task data.
 */
export async function renderDualColourFromConfig(
    configPath: string,
    parameterSetKey: string,
    customText: string,
    options: Partial<Omit<OpenSCADRenderOptions, 'variables' | 'fileName'>> & {
        fileName?: string,
    } = {}
): Promise<string> {
    const projectRoot = process.cwd();
    const fullConfigPath = path.join(projectRoot, configPath);
    const scadPath = path.join(projectRoot, 'openscad', 'DualColour.scad'); // Use DualColour.scad

    // Read and parse the JSON config file
    const configFileContent = await fs.readFile(fullConfigPath, 'utf-8');
    const config = JSON.parse(configFileContent);

    // Get the specific parameter set
    const parameterSet = config.parameterSets[parameterSetKey];
    if (!parameterSet) {
        throw new Error(`Parameter set "${parameterSetKey}" not found in ${configPath}`);
    }

    // Combine config parameters with dynamic task data
    const variablesFromConfig: Record<string, string | number> = {
        ...parameterSet,
        line1: customText.split(/\r?\n|\\|\//).map(t => t.trim()).filter(Boolean)[0] ?? '',
        line2: customText.split(/\r?\n|\\|\//).map(t => t.trim()).filter(Boolean)[1] ?? '',
        line3: customText.split(/\r?\n|\\|\//).map(t => t.trim()).filter(Boolean)[2] ?? '',
        // Note: Colors are ignored for these new styles as per clarification
    };

    // Ensure numeric values are treated as numbers and filter out internal variables
    const finalVariables: Record<string, string | number> = {};
    const internalVarsToExclude = ['offset_delta_workaround_fonts']; // Add other internal vars if needed

    for (const key in variablesFromConfig) {
        if (internalVarsToExclude.includes(key)) {
            continue; // Skip internal variables
        }
        if (typeof variablesFromConfig[key] === 'string' && !isNaN(Number(variablesFromConfig[key]))) {
            finalVariables[key] = Number(variablesFromConfig[key]);
        } else {
            finalVariables[key] = variablesFromConfig[key];
        }
    }

    return renderScadToStl(scadPath, { // Use scadPath here
        ...options,
        variables: finalVariables, // Pass the filtered variables
        fileName: options.fileName,
    });
}

/**
 * Renders RegKey.scad to STL.
 */
export async function renderRegKey(
    text: string,
    options: Partial<Omit<OpenSCADRenderOptions, 'variables' | 'fileName'>> & {
        fileName?: string,
    } = {}
): Promise<string> {
    const projectRoot = process.cwd()
    const scad = path.join(projectRoot, 'openscad', 'RegKey.scad')
    return renderScadToStl(scad, {
        ...options,
        variables: {
            Text: text,
        },
        fileName: options.fileName,
    })
}

/**
 * Renders iPhoneCable.scad to STL.
 */
export async function renderCableClip(
    line1: string,
    cabledia: number,
    options: Partial<Omit<OpenSCADRenderOptions, 'variables' | 'fileName'>> & {
        fileName?: string,
    } = {}
): Promise<string> {
    const projectRoot = process.cwd()
    const scad = path.join(projectRoot, 'openscad', 'iPhoneCable.scad')
    return renderScadToStl(scad, {
        ...options,
        variables: {
            line1: line1,
            cabledia: cabledia,
            // Set other params to defaults or make them configurable if needed
            line2: "",
            line3: "",
            line4: "",
            line5: "",
            character_spacing: 1.0,
            line_spacing: 1.8,
            bar_style: "bar_only",
            lug_style: "plate",
            writing_direction: "ltr",
            font_name: "Impact", // Or another default/configurable font
            font_size: 16,
            font_narrow_widen: 0,
            font_weight: 3,
            font_outline_width: 0.0,
            lug_text_distance: -1.0,
            lug_length: 0,
            lug_width: 0,
            hole_extra_margin: 0.0,
            bar_shift: 5,
            bar_width: 13,
            bar_length_trim: 0,
            glyph_coalesce: 20,
            glyph_coalesce_strategy: "bar and glyphs",
            border_width: 0,
            inner_margin_width: 0,
            outer_margin_width: 0,
            bar_thickness: 7,
            outline_thickness: 6,
            text_thickness: 10,
            border_thickness: 0,
        },
        fileName: options.fileName,
    })
}

// helper slug
export function slug(input: string) {
    // Keep original capitalization but remove unsafe filesystem characters.
    return input
        .replace(/\s+/g, '_')           // spaces → underscore
        .replace(/[^A-Za-z0-9_]/g, '')   // only alphanum & _
        .replace(/_+/g, '_')             // collapse repeats
        .slice(0, 60) || 'tag'
}
