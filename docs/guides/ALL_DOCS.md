---
title: ALL_DOCS
last-reviewed: 2025-04-18
maintainer: TBD
---



<<< FILE: ./.aider.chat.history.md >>>


# aider chat started at 2025-04-18 12:41:19

> You can skip this check with --no-gitignore  
> Add .aider* to .gitignore (recommended)? (Y)es/(N)o [Yes]: y  
> Added .aider* to .gitignore  
> /home/jayson/.local/bin/aider --list-models gemini/  
> Models which match "gemini/":  
> - gemini/gemini-1.5-flash  
> - gemini/gemini-1.5-flash-001  
> - gemini/gemini-1.5-flash-002  
> - gemini/gemini-1.5-flash-8b  
> - gemini/gemini-1.5-flash-8b-exp-0827  
> - gemini/gemini-1.5-flash-8b-exp-0924  
> - gemini/gemini-1.5-flash-exp-0827  
> - gemini/gemini-1.5-flash-latest  
> - gemini/gemini-1.5-pro  
> - gemini/gemini-1.5-pro-001  
> - gemini/gemini-1.5-pro-002  
> - gemini/gemini-1.5-pro-exp-0801  
> - gemini/gemini-1.5-pro-exp-0827  
> - gemini/gemini-1.5-pro-latest  
> - gemini/gemini-2.0-flash  
> - gemini/gemini-2.0-flash-001  
> - gemini/gemini-2.0-flash-exp  
> - gemini/gemini-2.0-flash-lite  
> - gemini/gemini-2.0-flash-lite-preview-02-05  
> - gemini/gemini-2.0-flash-thinking-exp  
> - gemini/gemini-2.0-flash-thinking-exp-01-21  
> - gemini/gemini-2.0-pro-exp-02-05  
> - gemini/gemini-2.5-pro-exp-03-25  
> - gemini/gemini-2.5-pro-preview-03-25  
> - gemini/gemini-exp-1114  
> - gemini/gemini-exp-1206  
> - gemini/gemini-gemma-2-27b-it  
> - gemini/gemini-gemma-2-9b-it  
> - gemini/gemini-pro  
> - gemini/gemini-pro-vision  
> - gemini/gemma-3-27b-it  
> - gemini/learnlm-1.5-pro-experimental  

# aider chat started at 2025-04-18 12:41:49

> /home/jayson/.local/bin/aider --model gemini-2.5-pro  
> Warning: gemini/gemini-2.5-pro-exp-03-25 expects these environment variables  
> - GEMINI_API_KEY: Not set  
> Warning: gemini/gemini-2.0-flash expects these environment variables  
> - GEMINI_API_KEY: Not set  
> You can skip this check with --no-show-model-warnings  
> https://aider.chat/docs/llms/warnings.html  
> Open documentation url for more info? (Y)es/(N)o/(D)on't ask again [Yes]: y  
> Aider v0.82.1  
> Main model: gemini/gemini-2.5-pro-exp-03-25 with diff-fenced edit format  
> Weak model: gemini/gemini-2.0-flash  
> Git repo: .git with 305 files  
> Repo-map: using 4096 tokens, auto refresh  
>  
>  
> ^C again to exit  
>  
>  
> ^C KeyboardInterrupt  

# aider chat started at 2025-04-18 12:45:13

> /home/jayson/.local/bin/aider --model gemini-2.5-pro  
> Warning: gemini/gemini-2.5-pro-exp-03-25 expects these environment variables  
> - GEMINI_API_KEY: Not set  
> Warning: gemini/gemini-2.0-flash expects these environment variables  
> - GEMINI_API_KEY: Not set  
> You can skip this check with --no-show-model-warnings  
> https://aider.chat/docs/llms/warnings.html  
> Open documentation url for more info? (Y)es/(N)o/(D)on't ask again [Yes]: n  
> Aider v0.82.1  
> Main model: gemini/gemini-2.5-pro-exp-03-25 with diff-fenced edit format  
> Weak model: gemini/gemini-2.0-flash  
> Git repo: .git with 305 files  
> Repo-map: using 4096 tokens, auto refresh  
>  
>  
> ^C again to exit  
>  
>  
> ^C KeyboardInterrupt  

# aider chat started at 2025-04-18 12:56:31

> /home/jayson/.local/bin/aider --model gemini-2.5-pro  
> Warning: gemini/gemini-2.5-pro-exp-03-25 expects these environment variables  
> - GEMINI_API_KEY: Not set  
> Warning: gemini/gemini-2.0-flash expects these environment variables  
> - GEMINI_API_KEY: Not set  
> You can skip this check with --no-show-model-warnings  
> https://aider.chat/docs/llms/warnings.html  

# aider chat started at 2025-04-18 12:57:52

> /home/jayson/.local/bin/aider --list-models gemini/  
> Models which match "gemini/":  
> - gemini/gemini-1.5-flash  
> - gemini/gemini-1.5-flash-001  
> - gemini/gemini-1.5-flash-002  
> - gemini/gemini-1.5-flash-8b  
> - gemini/gemini-1.5-flash-8b-exp-0827  
> - gemini/gemini-1.5-flash-8b-exp-0924  
> - gemini/gemini-1.5-flash-exp-0827  
> - gemini/gemini-1.5-flash-latest  
> - gemini/gemini-1.5-pro  
> - gemini/gemini-1.5-pro-001  
> - gemini/gemini-1.5-pro-002  
> - gemini/gemini-1.5-pro-exp-0801  
> - gemini/gemini-1.5-pro-exp-0827  
> - gemini/gemini-1.5-pro-latest  
> - gemini/gemini-2.0-flash  
> - gemini/gemini-2.0-flash-001  
> - gemini/gemini-2.0-flash-exp  
> - gemini/gemini-2.0-flash-lite  
> - gemini/gemini-2.0-flash-lite-preview-02-05  
> - gemini/gemini-2.0-flash-thinking-exp  
> - gemini/gemini-2.0-flash-thinking-exp-01-21  
> - gemini/gemini-2.0-pro-exp-02-05  
> - gemini/gemini-2.5-pro-exp-03-25  
> - gemini/gemini-2.5-pro-preview-03-25  
> - gemini/gemini-exp-1114  
> - gemini/gemini-exp-1206  
> - gemini/gemini-gemma-2-27b-it  
> - gemini/gemini-gemma-2-9b-it  
> - gemini/gemini-pro  
> - gemini/gemini-pro-vision  
> - gemini/gemma-3-27b-it  
> - gemini/learnlm-1.5-pro-experimental  

# aider chat started at 2025-04-18 12:57:54

> /home/jayson/.local/bin/aider --model gemini-2.5-pro  
> Aider v0.82.1  
> Main model: gemini/gemini-2.5-pro-exp-03-25 with diff-fenced edit format  
> Weak model: gemini/gemini-2.0-flash  
> Git repo: .git with 305 files  
> Repo-map: using 4096 tokens, auto refresh  
>  
>  
> ^C again to exit  
>  
>  
> ^C KeyboardInterrupt  

# aider chat started at 2025-04-18 12:57:59

> /home/jayson/.local/bin/aider --model gemini-2.5-pro  
> Aider v0.82.1  
> Main model: gemini/gemini-2.5-pro-exp-03-25 with diff-fenced edit format  
> Weak model: gemini/gemini-2.0-flash  
> Git repo: .git with 305 files  
> Repo-map: using 4096 tokens, auto refresh  

#### /help  
> /add              Add files to the chat so aider can edit them or review them in detail  
> /architect        Enter architect/editor mode using 2 different models. If no prompt provided, switches to architect/editor mode.  
> /ask              Ask questions about the code base without editing any files. If no prompt provided, switches to ask mode.  
> /chat-mode        Switch to a new chat mode  
> /clear            Clear the chat history  
> /code             Ask for changes to your code. If no prompt provided, switches to code mode.  
> /commit           Commit edits to the repo made outside the chat (commit message optional)  
> /context          Enter context mode to see surrounding code context. If no prompt provided, switches to context mode.  
> /copy             Copy the last assistant message to the clipboard  
> /copy-context     Copy the current chat context as markdown, suitable to paste into a web UI  
> /diff             Display the diff of changes since the last message  
> /drop             Remove files from the chat session to free up context space  
> /edit             Alias for /editor: Open an editor to write a prompt  
> /editor           Open an editor to write a prompt  
> /editor-model     Switch the Editor Model to a new LLM  
> /exit             Exit the application  
> /git              Run a git command (output excluded from chat)  
> /help             Ask questions about aider  
> /lint             Lint and fix in-chat files or all dirty files if none in chat  
> /load             Load and execute commands from a file  
> /ls               List all known files and indicate which are included in the chat session  
> /map              Print out the current repository map  
> /map-refresh      Force a refresh of the repository map  
> /model            Switch the Main Model to a new LLM  
> /models           Search the list of available models  
> /multiline-mode   Toggle multiline mode (swaps behavior of Enter and Meta+Enter)  
> /paste            Paste image/text from the clipboard into the chat.        Optionally provide a name for the image.  
> /quit             Exit the application  
> /read-only        Add files to the chat that are for reference only, or turn added files to read-only  
> /reasoning-effort Set the reasoning effort level (values: number or low/medium/high depending on model)  
> /report           Report a problem by opening a GitHub Issue  
> /reset            Drop all files and clear the chat history  
> /run              Run a shell command and optionally add the output to the chat (alias: !)  
> /save             Save commands to a file that can reconstruct the current chat session's files  
> /settings         Print out the current settings  
> /test             Run a shell command and add the output to the chat on non-zero exit code  
> /think-tokens     Set the thinking token budget (supports formats like 8096, 8k, 10.5k, 0.5M)  
> /tokens           Report on the number of tokens used by the current chat context  
> /undo             Undo the last git commit if it was done by aider  
> /voice            Record and transcribe voice input  
> /weak-model       Switch the Weak Model to a new LLM  
> /web              Scrape a webpage, convert to markdown and send in a message  
> Use `/help <question>` to ask questions about how to use aider.  
>  
>  
> ^C again to exit  

# aider chat started at 2025-04-18 13:07:30

> /home/jayson/.local/bin/aider --model gemini-2.5-pro[200~──────────────────────────────────────────────────────────────────╮  

# aider chat started at 2025-04-18 13:14:36

> /home/jayson/.local/bin/aider --model o3 --architect  
> Warning: Streaming is not supported by o3. Disabling streaming.  
> Aider v0.82.1  
> Main model: o3 with architect edit format  
> Editor model: gpt-4.1 with editor-diff edit format  
> Weak model: gpt-4.1-mini  
> Git repo: .git with 305 files  
> Repo-map: using 4096 tokens, auto refresh  
>  
>  
> ^C again to exit  
>  
>  
> ^C KeyboardInterrupt  

# aider chat started at 2025-04-18 13:15:12

> /home/jayson/.local/bin/aider --model o3 --architect gpt-4.1  
> Warning: Streaming is not supported by o3. Disabling streaming.  
> Creating empty file /home/jayson/y3dhub/gpt-4.1  
> Aider v0.82.1  
> Main model: o3 with architect edit format  
> Editor model: gpt-4.1 with editor-diff edit format  
> Weak model: gpt-4.1-mini  
> Git repo: .git with 305 files  
> Repo-map: using 4096 tokens, auto refresh  
> Added gpt-4.1 to the chat.  
>  
>  
> ^C again to exit  
>  
>  
> ^C KeyboardInterrupt  
> Open documentation url for more info? (Y)es/(N)o/(D)on't ask again [Yes]: n  
> Aider v0.82.1  
> Main model: gemini/gemini-2.5-pro-exp-03-25 with diff-fenced edit format  
> Weak model: gemini/gemini-2.0-flash  
> Git repo: .git with 305 files  
> Repo-map: using 4096 tokens, auto refresh  

# aider chat started at 2025-04-18 13:21:05

> /home/jayson/.local/bin/aider  
> Using openrouter/anthropic/claude-3.7-sonnet model with API key from environment.  
> Aider v0.82.1  
> Main model: openrouter/anthropic/claude-3.7-sonnet with diff edit format, infinite output  
> Weak model: openrouter/anthropic/claude-3-5-haiku  
> Git repo: .git with 305 files  
> Repo-map: using 4096 tokens, auto refresh  
>  
>  
> ^C again to exit  
>  
>  
> ^C KeyboardInterrupt  

# aider chat started at 2025-04-18 13:24:08

> /home/jayson/.local/bin/aider --model o4-mini  
> Aider v0.82.1  
> Main model: o4-mini with diff edit format  
> Weak model: gpt-4.1-mini  
> Git repo: .git with 305 files  
> Repo-map: using 4096 tokens, auto refresh  
>  
>  
> ^C again to exit  
>  
>  
> ^C KeyboardInterrupt  

# aider chat started at 2025-04-18 13:27:12

> You need to install the aider browser feature  
> /home/jayson/.local/share/uv/tools/aider-chat/bin/python -m pip install --upgrade --upgrade-strategy only-if-needed 'aider-chat[browser]'  

# aider chat started at 2025-04-18 13:27:35

> You need to install the aider browser feature  
> /home/jayson/.local/share/uv/tools/aider-chat/bin/python -m pip install --upgrade --upgrade-strategy only-if-needed 'aider-chat[browser]'  
> Run pip install? (Y)es/(N)o [Yes]: y  

# aider chat started at 2025-04-18 13:28:16

> /home/jayson/.local/share/uv/tools/aider-chat/lib/python3.12/site-packages/aider/gui.py --browser  
> Using openrouter/anthropic/claude-3.7-sonnet model with API key from environment.  
> Aider v0.82.1  
> Main model: openrouter/anthropic/claude-3.7-sonnet with diff edit format, infinite output  
> Weak model: openrouter/anthropic/claude-3-5-haiku  
> Git repo: .git with 305 files  
> Repo-map: using 4096 tokens, auto refresh  

#### /help  
> Initial repo scan can be slow in larger repos, but only happens once.  
> Repo-map can't include /home/jayson/y3dhub/src/lib/auth/middleware.ts  
> Has it been deleted from the file system but not from git?  
> Repo-map can't include /home/jayson/y3dhub/src/lib/auth/session.ts  
> Has it been deleted from the file system but not from git?  

#### /help  

I understan


I understanI understand. I'll follow the *SEARCH/REPLACE block* rules exactly when you ask me to make changes to your code. I'll wait for you to add specific files to the chat before proposing any edits.

> Tokens: 11k sent, 47 received. Cost: $0.03 message, $0.03 session.  

#### \elp  

#### \help  

I understand the *SEARCH/REPLACE block* rules. I'll follow them precisely when you ask me to make changes to your code. I'll wait for you to add specific files to the chat before proposing any edits.

> Tokens: 11k sent, 45 received. Cost: $0.03 message, $0.07 session.  

I understand the *SEARCH/REPLACE block* rules. I'll follow them precisely when you ask me to make changes to your code. I'll wait for you to add specific files to the chat before proposing any edits.I understan

> Warning: it's best to only add files that need changes to the chat.  
> https://aider.chat/docs/troubleshooting/edit-errors.html  

#### ok can you provide me a breakdown of all my .md files (or txt files which are like md files) in my project, I've already located most included I need to work on a plan to refactor all my md files into a much better way (and not have any overlappings bits unless needed)  

I'll provide a breakdown of your Markdown and text files to help you plan a refactoring strategy. Based on the files you've shared, here's an analysis of your documentation:

## Documentation Structure Analysis

### Core Documentation Files
1. **README.md** - Main project documentation with comprehensive overview
2. **docs/DEVELOPMENT.md** - Development guidelines and workflow
3. **docs/DATABASE.md** - Database schema and standards
4. **docs/API_REFERENCE.md** - API endpoint documentation
5. **docs/CODE_STRUCTURE.md** - Detailed codebase organization
6. **docs/COMMAND_REFERENCE.md** - CLI commands reference
7. **docs/TESTING.md** - Testing strategy (appears to be a placeholder)
8. **docs/TROUBLESHOOTING.md** - Common issues and solutions
9. **docs/SHIPSTATION_SYNC.md** - ShipStation integration details

### Specialized Documentation
10. **docs/AMAZON-COLOR-PROCESSING.md** - Amazon order color processing
11. **docs/IDE_GUIDELINES.md** - IDE setup and coding standards
12. **docs/NEW_CODE_REVIEW.md** - Code review focused on specific modules
13. **docs/linting-guide.md** - Linting standards and practices

### Planning & Future Work
14. **docs/FUTURE_IMPROVEMENTS.md** - Planned improvements
15. **docs/TODO.md** - Post-refactoring tasks
16. **docs/recommendations.md** - Modernization recommendations

### Script Documentation
17. **docs/scripts/cleanup.md** - Cleanup utilities documentation
18. **docs/scripts/crontab.md** - Cron job configuration details
19. **docs/configs/crontab-config.txt** - Actual crontab configuration

### Other Files
20. **docs/EBAY.md** - Appears to be eBay product data (not formatted as documentation)

## Overlapping Content Areas

1. **Deployment & Configuration**
   - README.md (deployment section)
   - docs/configs/crontab-config.txt
   - docs/scripts/crontab.md

2. **Development Guidelines**
   - docs/DEVELOPMENT.md
   - docs/IDE_GUIDELINES.md
   - docs/linting-guide.md

3. **Command Line Tools**
   - docs/COMMAND_REFERENCE.md
   - README.md (scripts section)
   - docs/scripts/cleanup.md

4. **Integration Documentation**
   - docs/SHIPSTATION_SYNC.md
   - docs/AMAZON-COLOR-PROCESSING.md
   - docs/EBAY.md

5. **Future Planning**
   - docs/FUTURE_IMPROVEMENTS.md
   - docs/TODO.md
   - docs/recommendations.md

## Recommendations for Refactoring

1. **Create a clear hierarchy**:
   - `/docs/README.md` - Documentation index
   - `/docs/guides/` - User and developer guides
   - `/docs/reference/` - API, commands, database reference
   - `/docs/integrations/` - External system integrations
   - `/docs/operations/` - Deployment, monitoring, maintenance
   - `/docs/planning/` - Future work and roadmaps

2. **Consolidate overlapping content**:
   - Merge development guidelines (DEVELOPMENT.md, IDE_GUIDELINES.md, linting-guide.md)
   - Combine future planning documents (FUTURE_IMPROVEMENTS.md, TODO.md, recommendations.md)
   - Unify command references (COMMAND_REFERENCE.md with script-specific docs)

3. **Standardize format**:
   - Use consistent headers and structure
   - Add table of contents to longer documents
   - Use standard sections (Overview, Usage, Examples, Troubleshooting)

4. **Improve navigation**:
   - Add cross-references between related documents
   - Create a central index with descriptions
   - Use consistent naming conventions

Would you like me to create a specific plan for this refactoring with detailed file organization and content consolidation recommendations?

> Tokens: 42k sent, 844 received. Cost: $0.14 message, $0.21 session.  

#### is there any other files in my project can you search?  

I'll search for additional documentation files in your project. Based on the files you've already shared, I can see you have a comprehensive set of Markdown and text files, but there might be more that weren't initially included in your summary.

From what I can see in the files you've shared, here are some additional documentation-related files that might exist in your project:

1. Potential additional documentation in `/docs/development/` (referenced in README.md)
2. Potential documentation about timezone handling (referenced as `docs/timezone-handling.md`)
3. Possibly a `docs/index.md` (mentioned in README.md)
4. Potentially a `docs/NEWFEATURES.md` (referenced in FUTURE_IMPROVEMENTS.md)
5. Possibly a `docs/AMAZON_CUSTOMIZATION_UNIFIED_SCRIPT.md` (referenced in TROUBLESHOOTING.md)

However, I can only confirm files that have been explicitly added to the chat. To find all Markdown files in your project, you could run this command:

```bash
find . -name "*.md" | sort
```

And for text files that might contain documentation:

```bash
find . -name "*.txt" | grep -v "node_modules" | sort
```

Would you like me to create a comprehensive plan for refactoring your documentation based on the files I've already analyzed? Or would you prefer to run those commands first to get a complete list of documentation files?

> Tokens: 43k sent, 301 received. Cost: $0.13 message, $0.34 session.  
> find . -name "*.md" | sort  
> Run shell command? (Y)es/(N)o/(S)kip all/(D)on't ask again [Yes]: n  
> find . -name "*.txt" | grep -v "node_modules" | sort  
> Run shell command? (Y)es/(N)o/(S)kip all/(D)on't ask again [Yes]: n  


<<< FILE: ./.github/copilot-instructions.md >>>

- Always fix the problem before asking the users input.
- always fix an error message before asking the user input.
- always fix a warning message before asking the user input.
- always fix a bug message before asking the user input.
- always fix a anything the user has asked without further input.

- YOU MUST ALWAYS GATHER MORE CONTEXT FROM SEARCHING THE CODEBASE FOR A SOLUTION TO YOUR PROBLEM, AND THEN BEGIN TO SOLVE THAT PROBLEM TO SOLVE WITHOUT THE USERS INPUT

- THEN YOU MUST ALWAYS TEST THE SOLUTION WITHOUT THE USERS INPUT E.G npm run test / build / deploy etc...

- if fails continue until it passes all tests / builds / deploys etc..

- THEN YOU MUST ALWAYS TEST THE SOLUTION WITHOUT ANY USERS INPUT E.G npm run test  / build  / deploy etc...

- if fails continue until it passes all tests  / builds  / deploys etc..

  - THEN YOU MUST ALWAYS TEST THE SOLUTION WITHOUT ANY USERS INPUT E.G npm run test  / build  / deploy etc...

  - if fails continue until it passes all tests / builds / deploys etc..

  - THEN YOU MUST ALWAYS TEST THE SOLUTION WITHOUT ANY USERS INPUT E.G npm run test   / build   / deploy etc...
    _/
    /_
  - Always fix the problem before asking the users input.
  - always fix an error message before asking the user input.
  - always fix a warning message before asking the user input.
  - always fix a bug message before asking the user input.
  - always fix a anything the user has asked without further input.

  - YOU MUST ALWAYS GATHER MORE CONTEXT FROM SEARCHING THE CODEBASE FOR A SOLUTION TO YOUR PROBLEM, AND THEN BEGIN TO SOLVE THAT PROBLEM TO SOLVE WITHOUT THE USERS INPUT

to fix the problem and then repeat this process until you have a solution that works without any users input, and also does not produce any errors or warnings messages in the console when running your code.


<<< FILE: ./.netlify/edge-functions/___netlify-edge-handler-src-middleware/edge-runtime/README.md >>>

# Edge runtime

This directory contains the logic required to create Netlify Edge Functions to support a Next.js
site.

It stands out from the rest of the project because it contains files that run in Deno, not Node.js.
Therefore any files within `edge-runtime/` should not be imported from anywhere outside this
directory.

There are a few sub-directories you should know about.

## `lib/`

Files that are imported by the generated edge functions.

## `shim/`

Files that are inlined in the generated edge functions. This means that _you must not import these
files_ from anywhere in the application, because they contain just fragments of a valid program.

## `vendor/`

Third-party dependencies used in the generated edge functions and pulled in ahead of time to avoid a
build time dependency on any package registry.

This directory is automatically managed by the build script and can be re-generated by running
`npm run build`.

You should not commit this directory to version control.


<<< FILE: ./.vscode/README.md >>>

# VS Code Configuration

This folder contains shared VS Code settings for the Y3DHub project.

## Included Files

- **settings.json**: Project-specific editor settings
- **extensions.json**: Recommended extensions for Y3DHub development
- **launch.json**: Debugging configurations for Next.js

## Purpose

These settings ensure a consistent development experience across the team, with standardized:

- Code formatting (Prettier)
- Linting rules (ESLint)
- Import ordering
- AI tool configurations
- TypeScript settings
- Debugging profiles

## For New Team Members

When opening this project for the first time in VS Code:

1. Install the recommended extensions (a prompt should appear)
2. Ensure ESLint and Prettier are properly configured
3. Use the debugging configurations for efficient Next.js debugging

These shared settings help maintain code quality and consistency across the Y3DHub order management system.


<<< FILE: ./ALL_DOCS.md >>>



<<< FILE: ./README.md >>>

# Y3DHub - Order Management & Print Queue System

## Project Overview

Y3DHub is a modern Next.js web application designed to streamline the order
management and 3D print production workflow for a business selling personalized
3D printed items (like keyrings, signs, etc.) across multiple marketplaces
(e.g., eBay, Amazon, Etsy).

The primary goals are:

1.  **Centralized Order Viewing:** Aggregate orders from various sources
    (initially via ShipStation integration) into a single interface.
2.  **Automated Personalization Parsing:** Use AI (OpenAI GPT models) to
    interpret customer personalization notes and product options to determine
    the specific details required for each print job. Handles Amazon `CustomizedURL` fetching directly when available.
3.  **Print Queue Generation:** Automatically create individual print tasks
    based on the parsed personalization, handling scenarios where one order
    item might result in multiple distinct print jobs.
4.  **Print Queue Management:** Provide a web interface at `/print-queue` to
    view, manage, and track the status of print tasks.

## Key Features

- Order management with ShipStation integration
- Print task workflow with status tracking
- Integrated Amazon `CustomizedURL` processing during task creation
- AI-powered personalization text extraction (using OpenAI GPT-4o-mini) as fallback
- Automated print queue generation from orders
- Web interface for viewing orders and print queue (`/orders`, `/print-queue`)
- Handles multiple marketplaces (Amazon, Etsy, eBay) with specific parsing logic
- Detailed order history and tracking (via database)
- Product name mapping and simplification (planned/implicit)
- Task Details Modal for viewing/editing tasks
- Paginated tables with sorting and limit controls
- Dark mode UI theme
- Database logging system for operations tracking and debugging
- Analysis scripts for monitoring and maintaining data consistency
- Automatic cleanup of pending tasks for shipped orders

## Architecture & Technology Stack

- **Framework:** Next.js (v14.2.5 - App Router)
- **Language:** TypeScript
- **Database:** MySQL
- **ORM:** Prisma (v6.5.0 or similar recent version)
- **Styling:** Tailwind CSS
- **UI Library:** shadcn/ui (Radix UI + Tailwind CSS)
- **State Management:** Primarily React Server Components (RSC) state and props
  passing. Client Components (`'use client'`) use React hooks (`useState`,
  `useMemo`, `useRouter`, `usePathname`, `useSearchParams`, `useTransition`)
  where needed (e.g., `PrintQueueTable`, `OrdersPagination`, `SyncButton`).
- **API Layer:** Next.js Route Handlers (`src/app/api/...`) for backend
  endpoints. Direct data fetching within RSCs using Prisma Client.
- **AI Integration:** OpenAI API (GPT-4o-mini model) via the `openai` Node.js
  library. Used within a standalone script (`populate-print-queue.ts`).
- **External API Client:** Axios (for ShipStation) in
  `src/lib/shipstation/index.ts`.
- **Scripting:** `tsx` for running TypeScript scripts directly. `yargs` / `commander` for CLI
  argument parsing in scripts.
- **Tables:** TanStack Table v8
- **Date Handling:** `date-fns`, `date-fns-tz`
- **Notifications:** Sonner (for toasts)
- **Code Quality:** ESLint (v8), Prettier, lint-staged, Husky (configured via
  `package.json` and `eslint.config.mjs`).
- **IDE Integration:** Includes `.vscode/settings.json` and
  `.vscode/extensions.json` for recommended VS Code setup (format on save,
  ESLint/Prettier integration, Prisma tools, Tailwind IntelliSense).

## Project Structure

```text
./
├── prisma/                 # Prisma schema, migrations, client
├── scripts/                # Analysis and utility scripts (May be deprecated/refactored)
│   └── analysis/           # Analysis, logging, and cleanup scripts
│       ├── cleanup.ts      # Scripts for cleaning up inconsistent data states
│       ├── logging.ts      # Database logging utilities
│       ├── orders.ts       # Order analysis utilities
│       ├── README.md       # Documentation for analysis scripts
│       └── sync-orders-wrapper.ts # Wrapper for sync-orders.ts with logging
│   ├── migrations/
│   └── schema.prisma
├── public/                 # Static assets
├── src/
│   ├── app/                # Next.js App Router directory
│   │   ├── api/            # API Route Handlers (e.g., /api/sync/shipstation)
│   │   ├── orders/         # Orders list page ([id] for details)
│   │   ├── print-queue/    # Print queue page
│   │   ├── favicon.ico
│   │   ├── globals.css
│   │   ├── layout.tsx      # Root layout
│   │   └── page.tsx        # Home page
│   ├── components/         # React components
│   │   ├── layout/         # Layout components (e.g., Navbar)
│   │   ├── ui/             # shadcn/ui components
│   │   ├── sync-button.tsx
│   │   ├── limit-selector.tsx
│   │   ├── orders-pagination.tsx
│   │   ├── print-queue-table.tsx
│   │   └── print-task-detail-modal.tsx
│   ├── lib/                # Core libraries, utilities, external API clients
│   │   ├── prisma.ts       # Prisma client instance
│   │   ├── shipstation/    # ShipStation API client logic & DB sync
│   │   ├── orders/         # Order processing logic (sync, mappers, amazon)
│   │   ├── print-tasks/    # Print task related logic (e.g., creation)
│   │   ├── shared/         # Shared utilities (logging, metrics, etc.)
│   │   ├── errors.ts       # Error handling utilities
│   │   └── utils.ts        # Utility functions (e.g., cn for classnames)
│   ├── scripts/            # Standalone scripts (Entry points)
│   │   ├── sync-orders.ts  # Script to sync orders from ShipStation
│   │   ├── populate-print-queue.ts # Script to generate print tasks
│   │   └── prompt-template.txt     # AI prompt template for the script
│   └── middleware.ts       # Next.js middleware (if any)
├── docs/                   # Additional documentation (Plans, Summaries, etc.)
├── .env                    # Environment variables (not committed)
├── .env.example            # Example environment file
├── .gitignore
├── components.json         # shadcn/ui configuration
├── eslint.config.mjs       # ESLint configuration
├── next.config.js          # Next.js configuration
├── package.json
├── postcss.config.mjs      # PostCSS configuration (for Tailwind)
├── README.md               # This file
└── tsconfig.json           # TypeScript configuration
```

## Database (`prisma/schema.prisma`)

The database schema defines the core entities:

- **`Order`**: Represents an imported order.
  - **Key Fields:** `id` (PK), `shipstation_order_id` (Unique),
    `shipstation_order_number`, `customerId` (FK), `order_status`,
    `internal_status` (Enum `InternalOrderStatus`), timestamps, notes, `total_price`.
  - **Relations:** `customer` (Optional), `items` (One-to-Many with
    `OrderItem`), `printTasks` (One-to-Many with `PrintOrderTask`).
- **`Customer`**: Represents a customer.
  - **Key Fields:** `id` (PK), `name`, `email` (Unique), `phone`, address
    fields, `shipstation_customer_id` (Unique).
  - **Relations:** Has many `Order`, has many `PrintOrderTask`.
- **`OrderItem`**: Represents a line item within an order.
  - **Key Fields:** `id` (PK), `orderId` (FK to `Order`), `productId` (FK to `Product`),
    `quantity`, `unit_price`, `print_settings` (Json?).
  - **Relations:** Belongs to `Order`, belongs to `Product`, has many `PrintOrderTask`, has one `AmazonCustomizationFile`.
- **`PrintOrderTask`**: Represents an individual print job derived from an
  `OrderItem`.
  - **Key Fields:** `id` (PK), `orderId` (FK to `Order`), `orderItemId` (FK to `OrderItem`), `productId` (FK to `Product`), `customerId` (FK to
    `Customer`), `custom_text`, `quantity`, `color_1`,
    `color_2`, `ship_by_date`, `status` (Enum `PrintTaskStatus`),
    `needs_review` (Boolean), `review_reason`, `annotation` (String?).
  - **Relations:** Belongs to `Order`, `OrderItem`, `Product`, `Customer` (optional).
  - **Unique Constraint:** `@@unique([orderItemId, taskIndex])`.
- **`Product`**: Represents a product definition.
  - **Key Fields:** `id` (PK), `sku` (Unique), `name`, `shipstation_product_id` (Unique).
  - **Relations:** Has many `OrderItem`, has many `PrintOrderTask`.
- **`AmazonCustomizationFile`**: Stores details about fetched Amazon customization data.
  - **Key Fields:** `id` (PK), `orderItemId` (Unique FK to `OrderItem`), `originalUrl`, `localFilePath`, `downloadStatus`, `processingStatus`.
  - **Relations:** Belongs to `OrderItem`.
- **Enums:** `InternalOrderStatus`, `PrintTaskStatus`.
- **`SystemLog`**: Represents a system log entry.
- **`Tag`**: Represents ShipStation tags.
- **`ScriptRunLog`**: Logs script executions.
- **`User`**: Represents application users.
- **`SyncProgress`**: Tracks the progress of sync operations.
- **`SyncMetrics`**: Stores metrics related to sync operations.
- **`AiCallLog`**: Logs calls made to AI services.
- **`Metric`**: Stores generic application metrics.

**Note:** After modifying `prisma/schema.prisma`, always run
`npx prisma migrate dev --name <migration_name>` to update the database schema
and `npx prisma generate` to update the Prisma Client types.

## Core Functionality & Detailed Data Flow

### 1. Order Ingestion (`src/lib/orders/sync.ts`, `src/scripts/order-sync.ts`)

1.  **Trigger:** Run `npx tsx src/scripts/order-sync.ts sync [options]`.
2.  **Sync Logic (`syncRecentOrders` / `syncAllPaginatedOrders` / `syncSingleOrder`):**
    - Determines start date/time based on mode (`recent`, `all`, `single`) and options (`--days-back`, `--hours`, `--order-date-start`, `--force-start-date`). Handles timezone conversion for `modifyDateStart` parameter sent to ShipStation.
    - Fetches orders page by page from ShipStation API (`getShipstationOrders` with retry logic).
    - For each order (`ssOrder`):
      - Calls `upsertOrderWithItems`.
    - **`upsertOrderWithItems`:**
      - Upserts the `Customer` using `upsertCustomerFromOrder` (based on email).
      - Upserts the `Product` for each item using `upsertProductFromItem` (based on SKU or ShipStation Product ID).
      - Upserts the `Order` using `mapOrderToPrisma` (based on `shipstation_order_id`).
      - Upserts `OrderItem`s using `mapSsItemToOrderItemData` (based on `shipstationLineItemKey`).
    - _(Optional)_ Syncs ShipStation tags (`syncShipStationTags`).
    - Updates `SyncProgress` table.
    - Returns counts/status.

### 2. Print Task Generation (`src/scripts/populate-print-queue.ts`)

1.  **Trigger:** Run `npx tsx src/scripts/populate-print-queue.ts [options]`.
2.  **Options:** Accepts flags like `--order-id`, `--limit`, `--force-recreate`, `--clear-all`, `--dry-run`.
3.  **Clear All (Optional):** If `--clear-all` is used, prompts for confirmation (unless `-y` is present) and deletes all existing `PrintOrderTask` records.
4.  **Order Fetching (`getOrdersToProcess`):**
    - If `--order-id` is provided, fetches that specific order.
    - Otherwise, fetches orders with status `awaiting_shipment`.
    - If `--force-recreate` is **not** used, it only fetches orders that have at least one item without any existing print tasks.
    - If `--force-recreate` **is** used, it fetches all `awaiting_shipment` orders (up to the limit), regardless of existing tasks.
5.  **AI Processing (`extractOrderPersonalization`):**
    - For each fetched order, constructs JSON input and calls the configured OpenAI API (`gpt-4o-mini` by default) to get structured personalization data (`{ "itemPersonalizations": {...} }`).
6.  **Task Upsert (`createOrUpdateTasksInTransaction`):**
    - For each item in an order:
      - **Amazon Check:** If it's an Amazon order with a `CustomizedURL`, attempts to fetch and process the URL using `fetchAndProcessAmazonCustomization`. If successful, uses this data for the task.
      - **eBay Check:** If not processed via Amazon URL and it's an eBay order with specific notes format, attempts to parse notes. If successful, uses this data.
      - **AI Fallback:** If neither Amazon nor eBay logic applies/succeeds, uses the data extracted by the AI (`aiData`).
      - **Placeholder:** If no data source succeeds, creates a placeholder task marked for review.
      - **DB Operation:** Uses Prisma transactions (`tx.printOrderTask.upsert`) to create or update tasks based on the determined data source. If `--force-recreate` was used, existing tasks for the item were deleted before this step.
7.  **Completion:** Logs processing summary.

### 3. Frontend Display

- **`/` (`src/app/page.tsx`):** Server Component rendering `SyncButton`
  (Client Component).
- **`/orders` (`src/app/orders/page.tsx`):** Server Component
  (`force-dynamic`). Fetches paginated orders (`getOrders`), renders
  `OrdersPagination` and a table (`shadcn/ui`) with links to `/orders/[id]`.
- **`/print-queue` (`src/app/print-queue/page.tsx`):** Server Component.
  Fetches print tasks (`getPrintTasks`), renders `PrintQueueHeader` and `PrintQueueTable`.
- **`PrintQueueHeader` (`src/components/print-queue-header.tsx`):** Client Component.
  Displays the page title, last updated time, and action buttons including:
  - **Tools Button:** Opens the `PrintQueueToolsModal` for running maintenance tasks
  - **Cleanup Button:** Runs the `cleanShippedOrderTasks` action to mark tasks as completed
  - **Refresh Button:** Reloads the page to show the latest data
- **`PrintQueueToolsModal` (`src/components/print-queue-tools-modal.tsx`):** Client Component.
  Provides a dialog for entering an order ID or marketplace order number to run the
  `populate-print-queue.ts` script with the `--force-recreate` flag. Supports both internal
  database IDs and marketplace order numbers (e.g., "202-3558314-1389920").
- **`PrintQueueTable` (`src/components/print-queue-table.tsx`):** Client
  Component (`'use client'`). Uses `@tanstack/react-table`. Defines columns
  with sorting, selection, status/review badges, links, row actions. Manages
  client-side table state (sorting, selection).
- **`OrdersPagination` (`src/components/orders-pagination.tsx`):** Client
  Component. Uses router hooks to generate pagination links, preserving `limit`.
- **`LimitSelector` (`src/components/limit-selector.tsx`):** Client Component.
  Allows selecting items per page via `shadcn/ui` Select.
- **Layout & Styling (`src/app/layout.tsx`, `globals.css`, `navbar.tsx`):**
  Defines root layout, dark mode theme via `globals.css`, main navbar. Uses
  `Inter` font. Layout allows full-width content cards.

## Getting Started

### Prerequisites

- Node.js (v18 or later recommended)
- npm (or yarn/pnpm)
- Access to a MySQL database instance
- ShipStation API Credentials (Key and Secret)
- OpenAI API Key

### Installation & Setup

1.  **Clone the repository:**

```bash
git clone <your-repository-url>
cd y3dhub
```

2.  **Install dependencies:**

```bash
npm install
```

3.  **Environment Variables:**
    - Create `.env` from `.env.example`. Fill in:

```dotenv
DATABASE_URL="mysql://USER:PASSWORD@HOST:PORT/DATABASE_NAME"
OPENAI_API_KEY="your_openai_api_key"
SHIPSTATION_API_KEY="your_shipstation_key"
SHIPSTATION_API_SECRET="your_shipstation_secret"
SHIPSTATION_BASE_URL="https://ssapi.shipstation.com" # Default
# NEXT_PUBLIC_APP_URL="http://localhost:3000" # Optional
```

4.  **Database Setup:**
    - Ensure MySQL DB exists.
    - Apply migrations: `npx prisma migrate dev --name init` (or subsequent migration name)
    - Generate client: `npx prisma generate`

## Running the Application

- **Development:** `npm run dev` (Access at
  [`http://localhost:3000`](http://localhost:3000))
- **Build:** `npm run build`
- **Production Start:** `npm run start`

## Available Scripts (via `npm run` or `npx tsx`)

- `dev`, `build`, `start`: Standard Next.js scripts.
- `lint`: Run ESLint checks.
- `populate-queue [--flags]`: Alias for `npx tsx src/scripts/populate-print-queue.ts`. Generates print tasks. Key flags: `--limit <num>`, `--order-id <db_id>`, `--force-recreate`, `--clear-all`, `--dry-run`.
- `sync-orders [--flags]`: Alias for `npx tsx src/scripts/order-sync.ts sync`. Syncs orders from ShipStation. Key flags: `--mode <recent|all|single>`, `--days-back <num>`, `--order-date-start <date>`, `--order-date-end <date>`, `--order-id <ss_id>`, `--skip-tags`, `--dry-run`.

See [Scripts Documentation](./docs/COMMAND_REFERENCE.md) for detailed documentation on all scripts, their options, and usage examples.

**Important Notes for Scripts:**

- Require `.env` file with API keys and `DATABASE_URL`.
- Scripts use `tsx` for execution.
- `populate-print-queue` processes orders in batches (controlled by `--limit`). It now handles Amazon URL fetching directly.
- Print tasks are automatically marked as completed when an order status changes to 'shipped' or 'cancelled' in ShipStation (This logic might need verification/implementation).

## API Routes

Located under `src/app/api/`. Handle:

- ShipStation Sync Trigger: `POST /api/sync/shipstation`
- Task Updates: `PATCH /api/print-tasks/[taskId]`,
  `PATCH /api/print-tasks/[taskId]/status` (Implemented & Authenticated)
- Bulk Task Updates: `PATCH /api/print-tasks/bulk-status`,
  `PATCH /api/tasks/bulk-update-name` (Note: Updates `PrintOrderTask` fields
  only).

## Current Status & Recent Work (as of April 16, 2025)

- **Core Setup:** Next.js v14.2.5, Prisma/MySQL, Shadcn UI.
- **`populate-print-queue` Script:**
  - Integrates Amazon `CustomizedURL` fetching.
  - Falls back to AI extraction (OpenAI GPT-4o-mini) if URL is missing/fails.
  - Includes `--force-recreate` flag to reprocess orders regardless of existing tasks.
  - Includes `--clear-all` flag to delete all tasks before processing.
  - Includes `--order-id` flag for specific order processing.
  - Uses `commander` for argument parsing.
  - Includes enhanced logging.
- **Frontend:** `/orders`, `/print-queue` pages with pagination
  (`OrdersPagination`) and limit controls (`LimitSelector`). `PrintQueueTable`
  uses TanStack Table v8 with sorting, selection, client-side status toggle.
  Dark mode implemented. Full-width layout. Hydration/serialization issues
  resolved.
- **ShipStation Sync:**
  - `order-sync.ts` script handles fetching orders/tags.
  - Correctly handles timezone conversion for `modifyDateStart` filter.
  - `amazon` subcommands in `order-sync.ts` are currently placeholders.
- **Database:** Added `annotation` field to `PrintOrderTask`.

## Known Issues & Limitations

**Based on Code Reviews (April 16, 2025):**

- **CRITICAL: `PrintOrderTask` Unique Constraint:** The temporary
  `@@unique([orderId, sku, product_name])` was fixed and replaced with `@@unique([orderItemId, taskIndex])`. **RESOLVED**
- **CRITICAL: Lack of API Security:** API routes (especially
  `POST /api/sync/shipstation`) lack authentication/authorization, creating a
  significant security vulnerability. Unauthorized access could trigger syncs,
  expose data, or incur costs.
- **HIGH: Lack of Automated Testing:** The absence of unit and integration
  tests makes refactoring risky, increases the chance of regressions, and makes
  verifying complex logic (sync, AI parsing) difficult.
- **MEDIUM: Inefficient ShipStation Sync Logic:** The current
  `upsertOrderWithItems` might still be inefficient for large updates if not using `shipstationLineItemKey` consistently. Needs review.
- **MEDIUM: `populate-print-queue` Script Issues:**
  - **Idempotency:** While `--force-recreate` helps, true idempotency based on content might be better long-term.
  - **AI Response Validation:** Relies on Zod schema, but complex edge cases might still cause issues.
  - **Error Handling:** Improved, but complex failures might need more specific handling.
- **MEDIUM: Filter State Persistence:** Filter/search parameters on the
  `/orders` page are lost during pagination or limit changes, harming UX.
- **MEDIUM: Print Queue Actions & State:** Status updates (`PrintQueueTable`)
  are UI-only and not persisted to the backend.
- **MEDIUM: Input Validation:** Need for input validation (e.g., using `zod`)
  on API routes to prevent errors or security issues from malformed requests.
- **LOW: Order Detail Page Missing:** `/orders/[id]` page is not yet
  implemented.
- **LOW: Redundant Order Status Field:** `Order` model has `order_status`
  (String) and `internal_status` (Enum `InternalOrderStatus`). Needs clarification/consolidation.
- **LOW: Potential Filter Fetching Inefficiency:** Repeatedly fetching distinct
  filter options (`getFilterOptions`) might be inefficient; consider caching.

## Future Work & TODOs (Elaborated & Prioritized)

**Based on Code Reviews (April 16, 2025):**

1.  **HIGH: Secure API Routes:** Implement robust authentication/authorization
    (middleware or route handlers) for all API routes, especially mutation
    endpoints like `/api/sync/shipstation`.
2.  **HIGH: Add Automated Tests:** Implement a testing strategy. Start with:
    - Unit tests (Vitest/Jest) for utilities, mappers, core logic.
    - Integration tests for critical flows: `syncRecentOrders`,
      `populate-print-queue` (mocking externals), API routes.
    - Activate and write Playwright E2E tests using the existing config.
3.  **MEDIUM: Enhance ShipStation Sync:** Review `upsertOrderWithItems` for efficiency, especially regarding item updates and handling of missing `shipstationLineItemKey`. Improve error propagation.
4.  **MEDIUM: Enhance `populate-print-queue` Script:**
    - Implement robust AI response validation (e.g., using `zod`).
    - Improve error handling (log details, create specific review tasks).
    - Consider true idempotency based on content hash if needed.
5.  **MEDIUM: Fix Filter Persistence on Pagination:** Update `OrdersPagination`
    and `LimitSelector` to preserve existing filter `searchParams` when
    generating links.
6.  **MEDIUM: Implement Print Queue Actions:** Create backend API route(s)
    (e.g., `PATCH /api/print-tasks/[id]/status`) to persist status changes.
    Update `PrintQueueTable` to call these APIs (using `fetch`, `react-query`,
    or `swr`) and remove temporary client-state logic.
7.  **MEDIUM: Implement API Input Validation:** Use `zod` or similar to validate
    request bodies/params on API routes.
8.  **LOW/MEDIUM: Build Order Detail Page (`/orders/[id]`):** Fetch and display
    full order details, items, and linked tasks.
9.  **LOW/MEDIUM: Add UI Filtering/Searching:** Implement UI controls and
    backend logic for robust filtering/searching on `/orders` and
    `/print-queue`.
10. **LOW: Clarify/Consolidate `Order.status` vs `Order.order_status`:** Decide
    if both are needed, update schema/logic.
11. **LOW: Optimize Filter Option Fetching (If Needed):** Consider caching
    strategies if `getFilterOptions` becomes slow.
12. **Fix `order-sync.ts amazon` commands:** Connect the script's subcommands to the library functions in `src/lib/orders/amazon/`.

## Deployment

Standard Next.js deployment:

1.  Ensure Node.js (v18+) support.
2.  Set environment variables on the server.
3.  Run `npm run build`.
4.  Run production migrations: `npx prisma migrate deploy`.
5.  Start: `npm run start`.
6.  Use a process manager (PM2) or platform service (Vercel, Netlify, etc.).

## Project Rules & Conventions

- **Code Style:** Follow ESLint/Prettier rules (`npm run lint`). Format on save.
- **Commits:** Use conventional commit messages. Lint pre-commit (Husky).
- **Branching:** Feature branches (`feature/...`), Pull Requests.
- **TypeScript:** Use strictly. Avoid `any`. Leverage Prisma types.
- **Environment Variables:** Keep `.env` local. Use provider's env management
  for deployment.
- **Prisma Migrations:** Use `npx prisma migrate dev`. Commit migrations.
- **Components:** Prefer Server Components. Use `'use client'` only when
  necessary.
- **API Routes:** Use Route Handlers (`src/app/api/.../route.ts`).
- **Scripts:** Place in `src/scripts`. Use `tsx`. Document in
  `docs/COMMAND_REFERENCE.md`.
- **Error Handling:** Use try/catch, provide feedback. Use `lib/errors.ts`.
- **Secrets:** Store securely (local `.env`, deployment env variables).

## Environment Variables Summary

Ensure these are in `.env`:

- `DATABASE_URL`
- `OPENAI_API_KEY` (if using `--ai-provider openai`)
- `OPEN_ROUTER_API_KEY` (if using `--ai-provider openrouter`)
- `SHIPSTATION_API_KEY`
- `SHIPSTATION_API_SECRET`
- `SHIPSTATION_BASE_URL` (Default: `https://ssapi.shipstation.com`)
- `OLLAMA_URL` (optional, if using `--ai-provider ollama` and not default
  localhost)
- `LMSTUDIO_URL` (optional, if using `--ai-provider lmstudio` and not default
  localhost)
- `LMSTUDIO_MODEL` (optional, if using `--ai-provider lmstudio` and not default
  `local-model`)
- `SESSION_PASSWORD` (for user authentication)
- `SYNC_API_KEY` (for `/api/sync/shipstation` endpoint security)

## Notes on Recent Changes

- Added a comprehensive database logging system:

  - Created a `system_logs` table in the database to store logs
  - Implemented a logging utility with different log levels (DEBUG, INFO, WARNING, ERROR, CRITICAL)
  - Added categorization for logs (ORDER_SYNC, PRINT_TASK, SYSTEM, etc.)
  - Created scripts for viewing and analyzing logs

- Added analysis and cleanup scripts:

  - Created a script to check for and fix pending print tasks for shipped orders
  - Added a script to find inconsistencies in the database
  - Created a wrapper for the sync-orders script with database logging
  - Organized scripts in a dedicated `scripts/analysis` directory with documentation

- Enhanced the Tools button functionality in the Print Queue to support marketplace order numbers (e.g., "202-3558314-1389920"):
  - Added `findOrderIdByMarketplaceNumber` function to look up internal database IDs from marketplace order numbers
  - Modified `runPopulateQueueForOrder` to detect and handle hyphenated marketplace order numbers
  - Improved error messages and user feedback for order number lookups
  - Updated the UI to clarify that both internal IDs and marketplace order numbers are accepted
- Downgraded Next.js to 14.2.5 (stable) from canary.
- Downgraded React/React-DOM to v18 from v19 canary/RC.
- Downgraded ESLint to v8 from v9 to satisfy `eslint-config-next` peer
  dependency.
- Resolved various dependency conflicts arising from version mismatches by
  cleaning `node_modules` and `package-lock.json` and performing a clean
  install.
- Renamed `next.config.ts` to `next.config.js`.
- Adjusted dependencies for compatibility.
- Changed font from `Geist` to `Inter`.
- Removed code referencing non-existent fields on `PrintOrderTask`.
- Refactored `src/lib/shipstation/db-sync.ts` to fix type errors.
- Fixed `Decimal` serialization warnings for Client Components.
- Minor ESLint suppression remains in `db-sync.ts`.
- Added date range flags (`--order-date-start`, `--order-date-end`) to
  `sync-orders` script for historical data fetching.
- Refactored `sync-orders` script execution to preload environment variables.
- Refactored `upsertCustomerFromOrder` to prioritize email lookups.
- Fixed `React.forwardRef` warning in UI Button component.
- Refactored `populate-print-queue` to use new schema and handle AI quantity
  splitting/mismatches.
- Fixed `PrintOrderTask` unique key constraint.
- Added simple API Key auth to `/api/sync/shipstation` endpoint.
- Added multiple AI provider options (`openai`, `openrouter`, `ollama`,
  `lmstudio`) to `populate-print-queue` script.
- Refined system prompt for AI personalization extraction for better accuracy
  and structure.
- Added file logging and debug logging capabilities to `populate-print-queue`.
- Added test script (`test.ts`) for isolated AI prompt testing.
- Added script (`create-user.ts`, `reset-user-password.ts`) for user management.
- Set project to use ES Modules (`"type": "module"` in `package.json`).
- Renamed `next.config.js` to `next.config.cjs` for module compatibility.
- Added print task status update API (`PATCH /api/print-tasks/[taskId]/status`)
  with authentication.
- Updated PrintQueueTable UI to display `needs_review` status with tooltip for
  reason, and personalization details (`custom_text`, `color_1`, `color_2`).
- Added logging for AI `annotation` field during task creation.
- Added Shipped Date and Tracking Number (with copy button) columns to the main
  Orders table.
- Clarified and consolidated internal vs external order status fields in the
  database schema (`Order.internal_status` and `InternalOrderStatus` enum).
- Created Order Detail page (`/orders/[id]`) showing order, customer, shipment,
  items, and print task details.
- Enhanced DatePicker component with preset buttons (Today, Tomorrow, etc.).
- Added warning log during product sync if an existing SKU has a different
  ShipStation Product ID.
- **Added `annotation` field to `PrintOrderTask` model and migrated DB.**
- **Modified `populate-print-queue.ts` to integrate Amazon URL fetching, add `--clear-all` flag, enhance logging, and fix `--force-recreate` behavior.**
- **Fixed timezone calculation in `order-sync.ts` for recent order fetching.**

## Documentation

All documentation is now centralized in the [docs](./docs) directory. Key documentation includes:

- [Scripts Documentation](./docs/COMMAND_REFERENCE.md) - Detailed documentation for all scripts
- [Improvements](./docs/development/IMPROVEMENTS.md) - Completed and planned improvements
- [Development Guidelines](./docs/development/DEVELOPMENT.md) - Development guidelines and best practices
- [Timezone Handling](./docs/development/timezone-handling.md) - Timezone handling documentation

See the [Documentation Index](./docs/index.md) for a complete list of available documentation.

## Running in Production with PM2

This project uses [PM2](https://pm2.keymetrics.io/) to manage the Next.js application process in the background, ensuring it stays running and facilitating easy log management.

### Prerequisites

- Node.js and npm installed.
- PM2 installed globally:
  ```bash
  npm install -g pm2
  ```

### Setup

1.  **Build the application:**

    ```bash
    npm run build
    ```

2.  **Start the application using PM2:**
    Navigate to the project root directory (`/home/jayson/y3dhub/`) in your terminal and run:
    ```bash
    pm2 start ecosystem.config.js
    ```
    This will start the Next.js application on port 8081 as defined in `ecosystem.config.js`.

### Common PM2 Commands

- **List running processes:**

  ```bash
  pm2 list
  # or
  pm2 status
  ```

- **View logs (real-time):**

  ```bash
  pm2 logs y3dhub-nextjs
  # or just 'pm2 logs' for all apps
  ```

- **View older logs:**

  ```bash
  pm2 logs y3dhub-nextjs --lines 1000 # Show last 1000 lines
  ```

  Logs are typically stored in `~/.pm2/logs/`.

- **Stop the application:**

  ```bash
  pm2 stop y3dhub-nextjs
  ```

- **Restart the application:**

  ```bash
  pm2 restart y3dhub-nextjs
  ```

- **Delete the application from PM2:**

  ```bash
  pm2 delete y3dhub-nextjs
  ```

## Full Workflow CLI

Run the entire end-to-end system (ShipStation sync → print queue → Amazon customization) with:

```bash
npm run full-workflow -- [options]
```


Options:
- `--mode <all|recent|single>`  Which orders to sync (default: recent)
- `--order-id <ID>`             Only sync a single order (requires `--mode single`)
- `--days-back <N>`             Days to look back when mode is `recent` (default: 2)
- `--hours <N>`                 Hours to look back when mode is `recent` (overrides `--days-back`)
- `--dry-run`                   Show actions without making any changes
- `--verbose`                   Enable verbose console output
- `--skip-tags`                 Skip ShipStation tag synchronization (tags-only sync should be run separately)

Concurrency:
The workflow uses a filesystem lock on `/tmp/y3dhub_workflow.lock` to ensure only one instance runs at a time.

Exit codes:
- `0` on success
- Non-zero if any step fails; the workflow aborts on the first error.

- **Monitor resource usage:**

  ```bash
  pm2 monit
  ```

- **Save the current process list (for startup on reboot):**
  ```bash
  pm2 save
  ```
  _(You might need to configure PM2 startup scripts for your OS for this to work automatically after reboot. See `pm2 startup` command)_.


<<< FILE: ./TODO_V3.md >>>



<<< FILE: ./docs/AMAZON-COLOR-PROCESSING.md >>>

# Amazon Order Color Processing

## Overview

This document outlines the process for handling Amazon orders with missing color information, including the scripts developed, workflow procedures, and recommendations for full end-to-end testing and diagnosing the workflow.

## Problem Statement

Some Amazon orders arrive with missing color information due to:
- CustomizedURL field missing in some orders
- Variations in JSON field naming in Amazon's customization data
- Inconsistent data extraction from Amazon's customization URLs
- Potential timing or timezone handling issues during sync/processing

This leads to incomplete orders in the print queue, tasks with missing colors in the DB, and potential fulfillment/shipping delays.

## End-to-End Testing & Diagnosis — Is the Full Workflow Working?

To fully check if the color and name customisations are propagating end-to-end (Amazon → DB → PrintTasks → ShipStation), and to diagnose potential issues (timezone, sync, ShipStation update delays):

### 1. **Check the Most Recent Data in the Database**

To check if the workflow is syncing recent orders (within the last 2 hours) and capturing personalization details, you can use the included diagnostic scripts:

#### a. **Check All Orders With Missing Colors**

Run:
```bash
npx tsx src/scripts/find-amazon-orders-with-missing-colors.ts
# Output: amazon-orders-missing-colors.json
```
This will list *all* Amazon orders/items/tasks still missing color1/color2 (and their taskIds, etc.). Check if orders within the last few hours are in this file; if so, they are either too new to be processed, or the workflow/data path is broken.

#### b. **Print Full DB Data for a Specific Amazon Order**

Use the diagnostic script:
```bash
npx tsx src/scripts/find-amazon-orders-with-missing-colors.ts
# Find your target orderId/orderNumber from output
# Then, check the DB Json with:
node check-database-order-customization.js  # or npx tsx src/scripts/check-database-order-customization.ts
```

#### c. **Directly Check a Single Order in Print Tasks Table**

Quickly check a single order's tasks:
- With `check-order.js`/`check-order.ts` (with your order number hardcoded)
- Or via Prisma Studio/DB tools
do:
```bash
node check-order.js # (edit it to match your order number)
```

This gives you a live snapshot of what your DB currently thinks the customizations for this order/item/task are.

### 2. **Test Amazon Customization Extraction (SP-API / URL)**

To check that Amazon Customization is being pulled (and if timezone handling affects whether "the latest" is fetched):

- Run `display-complete-amazon-order-data.js` (or `check-amazon-customization.js`)
- Review or save the API outputs (`amazon-order-complete-data.json`, etc.)
- Use `getOrderItems`/`getOrder` to ensure the Amazon SP-API returns the right set of order items and data.

If your test order/item data is present here *with* personalisation/color (or customizedURL pointing to a personalization zip), then the data *should* be possible to sync.

- To test Amazon Customization file extraction for a given item:
  - Use `fetchAndProcessAmazonCustomization(url)` in Node REPL / script, or re-run the batch color reprocessing script for just the target item

### 3. **Trigger a Full Manual Workflow for a Test Order**

**a. Force database and ShipStation update for a test order:**

```bash
npx tsx src/scripts/populate-print-queue.ts --order-id 026-5585200-4785105 -f --preserve-text
```
- This will force recreation of tasks, refetch Amazon URL if possible, and sync colors to ShipStation.
- `--preserve-text` helps retain the *name* if it was previously correct, guarding against AI overwrites.

**b. Manually Push DB Data into ShipStation Again:**
If some orders are not updating in ShipStation, but the DB is correct, you can trigger a direct sync:
```bash
npx tsx src/scripts/populate-print-queue.ts --order-id 026-5585200-4785105 --shipstation-sync-only
```
- This pushes what's currently in your DB to ShipStation item options.

### 4. **Check ShipStation UI (or Pull via API) For Updated Color/Names**

Go to the ShipStation web UI and check the order's item options:
- Are the colors and names present and correct?
- Is the timestamp of last modification recent? (If not, maybe the workflow isn't running as often as you think, or timezone is making you miss out-of-window orders)

**Note:** ShipStation can take a few minutes for updates to appear in the UI, and ignores updates for "shipped" orders.

### 5. **Check Your Cron/Automation for Timezone Issues**

- The crontab runs (in `crontab-config.txt`/`new_crontab.txt`) typically call `sync-orders.ts --hours=2`.
- This uses **UTC or server time**, but ShipStation API filters use Pacific Time for the `modifyDateStart`.
- Use recent local order timestamps to determine if your sync is pulling ALL the last 2 hours (cross-check the date/time math or add debug logs).
- If you notice orders from 2 hours ago are *not* updating, check (a) if the DB is missing the right orders (timezone mis-conversion), or (b) if print task creation is not catching them due to logic/skipped status.
  - Add debug logs to your worker scripts to print "processing order date xyz, comparing to last sync date abc"

## Color Reprocessing (Manual + URL)

To re-update ALL ShipStation items for orders with missing colors, the reprocess script is used:

```bash
npx tsx src/scripts/reprocess-amazon-colors.ts --dry-run
# To only update missing fields safely
npx tsx src/scripts/reprocess-amazon-colors.ts
# Use --generate-template and --use-manual-entries to fill in colors for stubborn/malformed orders
# See README.md for details
```

- **Safe:** Will only update print tasks where color_1 or color_2 is currently null, using AmazonURL or manual file.
- **ShipStation Sync included:** Script will push those changes to ShipStation at the item-level.

## Diagnosing Color/Name Not Updating in ShipStation

1. **If DB is updated, but ShipStation is NOT (and order is NOT shipped):**
   - Check print-queue script output/logs for API errors
   - Double-check `populate-print-queue.ts --order-id <order> --shipstation-sync-only`
   - Ensure print task holds correct data *and* that lineItemKey and orderId are correct
2. **If neither the DB nor ShipStation are updating:**
   - Check the `--hours=N` window logic in `sync-orders.ts` is pulling all expected orders from ShipStation (use verbose logging for debug)
   - Confirm the print task creation script *finds* the new/fresh order and doesn't skip it due to status/item filter logic
3. **If only the name is wrong after --force-recreate:**
   - Never use --force-recreate on live orders without --preserve-text, unless you want the AI to invent new names!
   - Always check AI output with --dry-run and --preserve-text before pushing live
4. **Timing:**
   - ShipStation API and database may be a few minutes behind each other. Give 5-10 minutes for update propagation.

## ShipStation "Already Shipped" Limitation

- **Once an order is shipped, ShipStation ignores subsequent updates to personalization fields!** Your script will notice, but the update will not propagate in the UI.

## Testing ShipStation Sync Before and After Shipping

- Always test your sync pipeline on a test order that is NOT shipped/fulfilled!
- For already shipped orders, you can still see updates in your local DB, but MUST mark new tasks/review externally.

## Full Debug Workflow

- Use all check scripts in `/home/jayson/y3dhubv3_copy/` (check-amazon-customization.js, check-database-order-customization.js, check-order.js)
- Use print-queue scripts in dry run, force-recreate, and preserve-text modes for diagnosis
- Always force a print/task/ShipStation refresh after confirming database data
- For naming issues: never update tasks with AI extraction unless you're certain the name field is needed to be replaced!

---

## Summary Table of All Scripts and Their Purpose

| Script/Utility                        | What It Does                                                               |
|---------------------------------------|----------------------------------------------------------------------------|
| find-amazon-orders-with-missing-colors.ts | List all Amazon orders/items with missing color info (Amazon → DB)         |
| reprocess-amazon-colors.ts            | Safe re-extraction of color info from Amazon URL or manual, updates DB+SS  |
| check-order.js / check-database-order-customization.js | Print all DB fields for a given order/item/task                   |
| populate-print-queue.ts --order-id ... [flags]| Force full refresh of print tasks for one order, updates DB + ShipStation |
| populate-print-queue.ts --shipstation-sync-only | Just send DB data to ShipStation (doesn't touch AI/URL/manual source)     |
| check-amazon-customization.js         | Show Amazon SP-API raw order/items data                                    |
| display-complete-amazon-order-data.js | Saves the full Amazon API order/items to file for review                   |
| check-order.js                        | Print DB task details for a specific order number                          |

## Best Practice: When Color Not Updating

- 1. Confirm order is still NOT shipped on ShipStation
- 2. Inspect DB via check-order.js (should show newest data)
- 3. If DB missing color → use reprocess-amazon-colors or full print-queue force-recreate
- 4. If DB has color but ShipStation doesn't: run populate-print-queue with --shipstation-sync-only
- 5. If AI is about to update name field, run with --preserve-text
- 6. If completely stuck: create an entry in manual-color-batch.json/template and re-run with --use-manual-entries

## Future Improvements

See main section in this file and also FUTURE_IMPROVEMENTS.md.

- Add logging of all inbound modification dates and sync times
- Add last-modified check to determine if timezone math is correct
- Consider forcing periodic full historical sync as backup
- Add dashboard or UI tools for checking/enforcing latest state
- Add warning if sync running out-of-window due to DST errors

---

If you follow this process you can fully trace every step:
- Amazon → item print_setting/CustomURL → parsed color/name
- → DB printTasks reflects correct colors/names
- → ShipStation item options get updated with the same
- → UI displays correct personalization to packing staff, customer, etc.

With the above scripted checks, you can isolate whether the problem is:
- ShipStation API window (timing/progress/modifyDateStart)
- Amazon data not available (URL is not present/JSON malformed)
- DB missing color due to script logic
- ShipStation not refreshing due to order being shipped
- AI/overwrite affecting the name field
- Or combination of the above.

If you need to test any step manually, all test/check scripts are already in your repo under /home/jayson/y3dhubv3_copy/.

<<< FILE: ./docs/API_REFERENCE.md >>>

# Y3DHub API Reference

This document provides a comprehensive reference for all API endpoints available in the Y3DHub system.## Base URLs- **Production:** `https://<your-y3dhub-instance>/api`- **Development:** `http://localhost:3000/api`## AuthenticationAll API requests require authentication using one of the following methods:- **Bearer Token:** Include an `Authorization` header with a Bearer token. `  Authorization: Bearer <API_KEY>  `- **API Key:** For specific endpoints (like sync operations), include an `X-Sync-API-Key` header. `  X-Sync-API-Key: <SYNC_API_KEY>  `## Error HandlingAPI errors are returned with appropriate HTTP status codes and JSON response bodies.Common error codes include:| Status Code | Error Code | Description || ----------- | ---------- | ----------- || 400 | `INVALID_REQUEST` | The request body or parameters are invalid || 401 | `AUTHENTICATION_FAILED` | Authentication failed || 403 | `PERMISSION_DENIED` | The authenticated user does not have permission || 404 | `RESOURCE_NOT_FOUND` | The requested resource does not exist || 429 | `RATE_LIMIT_EXCEEDED` | The rate limit has been exceeded || 500 | `INTERNAL_ERROR` | An internal server error occurred |Error response format:`json{  "error": {    "code": "ERROR_CODE",    "message": "Human-readable error message",    "details": {}  // Optional additional details  }}`## VersioningThe current API version is v1. The version is not currently included in the URL path but may be in future releases.## Endpoints### Orders#### Get OrdersFetches orders with pagination.`GET /api/orders`**Query Parameters:**| Parameter | Type | Description | Default || --------- | ---- | ----------- | ------- || `page` | integer | Page number | 1 || `limit` | integer | Items per page (max 100) | 20 |**Response:**`json{  "data": [    {      "id": 123,      "shipstation_order_id": "12345",      "order_number": "ABC-123",      "order_status": "awaiting_shipment",      "created_at": "2025-04-01T12:00:00Z",      "updated_at": "2025-04-01T12:00:00Z"      // Additional order fields...    }  ],  "pagination": {    "currentPage": 1,    "totalPages": 5,    "totalItems": 100,    "itemsPerPage": 20  }}`#### Get Order by IDFetches a specific order by ID.`GET /api/orders/:id`**Path Parameters:**| Parameter | Type | Description || --------- | ---- | ----------- || `id` | integer | Order ID |**Response:**`json{  "id": 123,  "shipstation_order_id": "12345",  "order_number": "ABC-123",  "order_status": "awaiting_shipment",  "created_at": "2025-04-01T12:00:00Z",  "updated_at": "2025-04-01T12:00:00Z",  "customer": {    "id": 456,    "name": "John Doe",    "email": "john.doe@example.com"    // Additional customer fields...  },  "items": [    {      "id": 789,      "sku": "ITEM-001",      "name": "Custom Keychain",      "quantity": 2,      "unit_price": 15.99      // Additional item fields...    }  ]  // Additional order fields...}`### Print Tasks#### Update Print TaskUpdates a specific print task.`PATCH /api/print-tasks/:taskId`**Path Parameters:**| Parameter | Type | Description || --------- | ---- | ----------- || `taskId` | integer | Print task ID |**Request Body:**`json{  "custom_text": "Updated text",  "color_1": "#FF0000",  "color_2": "#00FF00",  "notes": "Additional notes",  "needs_review": false  // Other updatable fields...}`**Response:**`json{  "id": 123,  "custom_text": "Updated text",  "color_1": "#FF0000",  "color_2": "#00FF00",  "notes": "Additional notes",  "needs_review": false,  "updated_at": "2025-04-01T12:00:00Z"  // Other task fields...}`#### Update Print Task StatusUpdates just the status of a print task.`PATCH /api/print-tasks/:taskId/status`**Path Parameters:**| Parameter | Type | Description || --------- | ---- | ----------- || `taskId` | integer | Print task ID |**Request Body:**`json{  "status": "completed"}`**Response:**`json{  "id": 123,  "status": "completed",  "updated_at": "2025-04-01T12:00:00Z"}`#### Bulk Update Print Task StatusUpdates the status of multiple print tasks at once.`PATCH /api/print-tasks/bulk-status`**Request Body:**`json{  "taskIds": [123, 456, 789],  "status": "in_progress"}`**Response:**`json{  "updated": 3,  "failed": 0,  "taskIds": [123, 456, 789]}`#### Bulk Update Print Task NamesUpdates the names of multiple print tasks at once.`PATCH /api/tasks/bulk-update-name`**Request Body:**`json{  "taskIds": [123, 456, 789],  "custom_text": "New standardized text"}`**Response:**`json{  "updated": 3,  "failed": 0,  "taskIds": [123, 456, 789]}`### Sync Operations#### Sync ShipStation OrdersTriggers a synchronization of orders from ShipStation.`POST /api/sync/shipstation`**Headers:**`X-Sync-API-Key: <SYNC_API_KEY>`**Request Body (Optional):**`json{  "mode": "recent",  // "all", "recent", "single"  "orderId": 12345,  // Required if mode is "single"  "daysBack": 7      // Optional, default is 7 for "recent" mode}`**Response:**`json{  "success": true,  "message": "ShipStation sync triggered successfully",  "details": {    "ordersProcessed": 25,    "ordersCreated": 5,    "ordersUpdated": 20,    "startTime": "2025-04-01T12:00:00Z",    "endTime": "2025-04-01T12:05:00Z",    "executionTimeMs": 300000  }}`## Rate LimitingAPI endpoints are rate-limited to protect the system from excessive usage. The current rate limits are:- **Standard Endpoints:** 60 requests per minute per API key- **Sync Operations:** 5 requests per minute per API keyWhen a rate limit is exceeded, the API will return a `429 Too Many Requests` status code.## Testing and DevelopmentFor local development, you can use tools like Postman or curl to interact with the API. Example curl command:`bashcurl -X GET "http://localhost:3000/api/orders?page=1&limit=20" \  -H "Authorization: Bearer your_api_key_here" \  -H "Content-Type: application/json"`## WebhooksY3DHub can also send webhook notifications for various events. These are configured in the admin settings.### Webhook Events| Event Type | Description || ---------- | ----------- || `order.created` | Triggered when a new order is created || `order.updated` | Triggered when an order is updated || `order.shipped` | Triggered when an order is marked as shipped || `print_task.created` | Triggered when a new print task is created || `print_task.updated` | Triggered when a print task is updated || `print_task.completed` | Triggered when a print task is completed |### Webhook Payload Format`json{  "event": "order.created",  "timestamp": "2025-04-01T12:00:00Z",  "data": {    // Event-specific data  }}`## Changelog### v1.0.0 (April 2025)- Initial release of the Y3DHub API


<<< FILE: ./docs/CODE_STRUCTURE.md >>>

# Code Structure

This document provides a detailed explanation of the Y3DHub codebase structure, focusing on the organization of modules, scripts, and their interactions.

## Directory Structure Overview

The codebase follows a clear directory structure that separates concerns and promotes maintainability:

```
src/
├── lib/               # Core library modules
│   ├── orders/        # Order-related functionality
│   │   ├── amazon/    # Amazon-specific order handling (customization fetching)
│   │   ├── sync.ts    # Order synchronization logic (fetching from ShipStation, upserting orders/items)
│   │   ├── mappers.ts # Data mapping functions (ShipStation -> Prisma)
│   │   ├── metrics.ts # Order-related metrics (Placeholder)
│   │   └── status.ts  # Order status reporting (Placeholder)
│   ├── print-tasks/   # Print task functionality
│   │   ├── creation.ts # Task creation logic (Moved from populate-print-queue.ts) - TODO: Create this file
│   │   ├── update.ts  # Task update logic (Placeholder)
│   │   ├── cleanup.ts # Task cleanup logic (Placeholder)
│   │   ├── metrics.ts # Task-related metrics (Placeholder)
│   │   └── status.ts  # Task status reporting (Placeholder)
│   ├── utils/         # Utility functions (Placeholder/TBD)
│   │   ├── check.ts   # System verification
│   │   ├── fix.ts     # Issue remediation
│   │   ├── backup.ts  # Backup functionality
│   │   └── stats.ts   # Statistics generation
│   ├── shared/        # Shared utilities
│   │   ├── shipstation.ts # ShipStation API client
│   │   ├── database.ts    # Database client wrapper (Prisma)
│   │   ├── logging.ts     # Logging utilities (Pino)
│   │   ├── metrics.ts     # Metrics collection
│   │   └── date-utils.ts  # Date handling utilities (date-fns, date-fns-tz)
│   └── prisma.ts      # Prisma client instance
├── scripts/           # Command-line scripts (Entry points)
│   ├── order-sync.ts  # Script for syncing orders from ShipStation
│   ├── populate-print-queue.ts # Script for populating print tasks (uses AI, Amazon URL)
│   ├── utils.ts       # Utility script (Placeholder/TBD)
│   └── ...            # Other scripts (e.g., user management)
├── app/               # Next.js application
│   ├── api/           # API routes
│   ├── orders/        # Order pages
│   ├── print-queue/   # Print queue pages
│   └── ...            # Other application pages
└── components/        # React components
    ├── ui/            # UI components (shadcn/ui)
    └── ...            # Other components
```

## Core Modules

### Orders Module (`lib/orders/`)

The orders module handles order synchronization with ShipStation and related data mapping.

#### Key Files:

- **`sync.ts`**: Core order synchronization logic.
  - `syncAllPaginatedOrders(options)`: Synchronizes all orders from ShipStation based on modification date, handling pagination and retries. Uses `upsertOrderWithItems`.
  - `syncRecentOrders(options)`: Synchronizes recent orders based on a time window (handles timezone conversion for ShipStation). Uses `syncAllPaginatedOrders`.
  - `syncSingleOrder(orderId, options)`: Synchronizes a specific order by ShipStation ID. Uses `upsertOrderWithItems`.
  - `syncShipStationTags(options)`: Synchronizes ShipStation tags.
  - `upsertOrderWithItems(orderData, progressId, options)`: Upserts a single order, its customer, products, and items into the database.
  - `upsertCustomerFromOrder(ssOrder, options)`: Upserts customer based on email.
  - `upsertProductFromItem(tx, ssItem, options)`: Upserts product based on SKU or ShipStation Product ID within a transaction.
- **`mappers.ts`**: Functions for mapping data between ShipStation API format and Prisma schema.
  - `mapAddressToCustomerFields(addr)`
  - `mapSsItemToProductData(ssItem)`
  - `mapSsItemToOrderItemData(ssItem, productId)`
  - `mapOrderToPrisma(ssOrder, dbCustomerId?)`
  - Includes timezone conversion for dates (`convertShipStationDateToUTC`).
- **`metrics.ts`**: (Placeholder) Intended for order metrics collection.
- **`status.ts`**: (Placeholder) Intended for order status reporting.

#### Amazon Submodule (`lib/orders/amazon/`)

Handles fetching and processing Amazon-specific customization data.

- **`customization.ts`**:
  - `fetchAndProcessAmazonCustomization(url)`: Fetches the zip file from the `CustomizedURL`, extracts the JSON, and parses it (parsing logic might need refinement based on actual JSON structure).
- **`sync.ts`**: Contains the library logic for finding Amazon orders needing customization sync and orchestrating the fetch/process/store flow (used by `populate-print-queue.ts` now, but intended for `order-sync.ts amazon sync` command).
  - `syncCustomizationFiles(options)`: Finds items with URLs and calls `processOrderItem`.
  - `findOrderItemsToProcess(options)`: Finds eligible Amazon order items.
  - `processOrderItem(item, options)`: Handles fetching/processing for a single item and updates `AmazonCustomizationFile` table.
- **`update.ts`**: (Placeholder) Intended for logic to update order items/tasks _after_ customization data is fetched.
- **`fix.ts`**: (Placeholder) Intended for fixing orders with missing personalization.
- **`workflow.ts`**: (Skeleton) Intended to orchestrate the full Amazon workflow (sync, update).

### Print Tasks Module (`lib/print-tasks/`)

Handles print task creation and potentially other task-related logic.

#### Key Files:

- **`creation.ts`**: (To be created) Will contain the core logic moved from `populate-print-queue.ts` for creating tasks, including AI extraction and database interaction.
  - `extractOrderPersonalization(...)`: (To be moved here) Handles AI call for personalization.
  - `createOrUpdateTasksInTransaction(...)`: (To be moved here) Handles DB upsert logic for tasks.
- **`update.ts`**: (Placeholder) Intended for task update logic.
- **`cleanup.ts`**: (Placeholder) Intended for task cleanup logic.
- **`metrics.ts`**: (Placeholder) Intended for task metrics.
- **`status.ts`**: (Placeholder) Intended for task status reporting.

### Utilities Module (`lib/utils/`)

(Placeholder/TBD) Intended for general utility functions for system maintenance and diagnostics.

#### Key Files (Examples):

- **`check.ts`**: System verification.
- **`fix.ts`**: Issue remediation.
- **`backup.ts`**: Backup functionality.
- **`stats.ts`**: Statistics generation.

### Shared Module (`lib/shared/`)

Provides utilities used across multiple modules.

#### Key Files:

- **`shipstation.ts`**: ShipStation API client (Axios instance, helper functions like `listTags`).
- **`database.ts`**: Prisma client wrapper/instance.
- **`logging.ts`**: Logging utilities (Pino setup).
- **`metrics.ts`**: Metrics collection helpers (`recordMetric`).
- **`date-utils.ts`**: Date handling utilities (using `date-fns` and `date-fns-tz`).

## Command-Line Scripts (`scripts/`)

Entry points for running backend processes.

### Order Sync Script (`scripts/order-sync.ts`)

Provides a command-line interface for triggering order synchronization from ShipStation. Uses functions from `lib/orders/sync.ts`. The `amazon` subcommands are currently placeholders and do not function.

### Populate Print Queue Script (`scripts/populate-print-queue.ts`)

Provides a command-line interface for generating print tasks.

- Fetches eligible orders using `lib/order-processing.ts`.
- Handles Amazon `CustomizedURL` fetching directly using `lib/orders/amazon/customization.ts`.
- Uses AI (via `extractOrderPersonalization`) as a fallback or for non-Amazon orders.
- Creates/updates tasks in the database using `createOrUpdateTasksInTransaction`.
- Includes options for targeting specific orders (`--order-id`), forcing recreation (`--force-recreate`), and clearing all tasks (`--clear-all`).

### Utilities Script (`scripts/utils.ts`)

(Placeholder/TBD) Intended as an entry point for various utility functions defined in `lib/utils/`.

## Module Interactions

The modules interact with each other in a structured manner:

1.  **Scripts** act as entry points, parse arguments, and call functions within **lib modules**.
2.  **`lib/orders/sync.ts`** interacts with **ShipStation API** (via `lib/shared/shipstation.ts`) and the **database** (via `lib/shared/database.ts` and mappers) to sync order data.
3.  **`scripts/populate-print-queue.ts`** uses **`lib/order-processing.ts`** to find orders, **`lib/orders/amazon/customization.ts`** to fetch Amazon data, its own internal AI logic (`extractOrderPersonalization`), and database logic (`createOrUpdateTasksInTransaction`) to manage print tasks.
4.  **All modules** utilize **shared utilities** (`lib/shared/`) for common operations like logging, metrics, and date handling.

```
[scripts/order-sync.ts] ---> [lib/orders/sync.ts] ---> [lib/shared/*] ---> [ShipStation API]
                                     |                     |
                                     v                     v
                                [Database (Order, Item, etc.)]

[scripts/populate-print-queue.ts] ---> [lib/order-processing.ts] ---> [Database]
              |                                  |
              |-----> [lib/orders/amazon/customization.ts] ---> [Amazon URL Fetch]
              |                                  |
              |-----> [AI Extraction (Internal)] ---------> [OpenAI API]
              |                                  |
              |-----> [Task Creation (Internal)] ---------> [Database (PrintTask)]
```

## Error Handling Strategy

The codebase implements a consistent error handling strategy:

1.  **Try-catch blocks** in key functions.
2.  **Retries** for transient errors in ShipStation API calls (`getShipstationOrders`).
3.  **Transaction rollbacks** for database operations using `prisma.$transaction`.
4.  **Detailed error logging** using Pino, including context.
5.  **Graceful degradation** (e.g., creating placeholder tasks on failure).

## Global Options

Most scripts and commands support common options like `--dry-run`, `--limit`, `--order-id`, and logging controls. Refer to `docs/COMMAND_REFERENCE.md` for specifics per script.

## Conclusion

This structure aims for separation of concerns, with library modules containing core reusable logic and scripts acting as entry points. The integration of Amazon URL fetching into `populate-print-queue.ts` deviates slightly from a pure modular approach but achieves the desired single-step task creation workflow.

For more details on specific aspects of the system, see:

- [COMMAND_REFERENCE.md](./COMMAND_REFERENCE.md) for a comprehensive list of commands and options
- [DATABASE.md](./DATABASE.md) for information on the database schema and field standards
- [API_REFERENCE.md](./API_REFERENCE.md) for documentation on API endpoints
- [TROUBLESHOOTING.md](./TROUBLESHOOTING.md) for help with common issues
- [TESTING.md](./TESTING.md) for information on testing strategies and test coverage


<<< FILE: ./docs/COMMAND_REFERENCE.md >>>

# Command Reference

This document provides a comprehensive reference for all commands available in the Y3DHub system scripts. It serves as a detailed guide for using the command-line interfaces.

## Overview

The Y3DHub system provides several main command-line scripts:

1.  `order-sync.ts` - Handles order synchronization from ShipStation.
2.  `populate-print-queue.ts` - Handles print task creation and management, including Amazon URL fetching and AI extraction.
3.  `utils.ts` - Provides utility functions for maintenance and diagnostics (Structure may vary).

## Global Options (Apply to most scripts, check specific script for exact support)

| Option                            | Description                                                                                                | Default          | Example                            |
| --------------------------------- | ---------------------------------------------------------------------------------------------------------- | ---------------- | ---------------------------------- |
| `--verbose` / `--log-level debug` | Show detailed debug output                                                                                 | `false` / `info` | `--verbose` or `--log-level debug` |
| `--dry-run`                       | Simulate operations without making changes                                                                 | `false`          | `--dry-run`                        |
| `--order-id=<id>`                 | Process a specific order by DB ID (for `populate-print-queue`) or ShipStation ID (for `order-sync single`) | -                | `--order-id=12345`                 |
| `--limit=<limit>`                 | Limit the number of items to process                                                                       | Varies           | `--limit=50`                       |
| `--help`                          | Show help information                                                                                      | -                | `--help`                           |

## Order Sync Script (`order-sync.ts`)

The Order Sync script handles order synchronization with ShipStation.

### Usage

```bash
npx tsx src/scripts/order-sync.ts <command> [options]
```

### Commands

#### `sync` - Synchronize orders from ShipStation

Fetches orders from ShipStation based on modification date and upserts them into the database. Correctly handles ShipStation's Pacific Time zone for date filters.

```bash
npx tsx src/scripts/order-sync.ts sync [options]
```

| Option                      | Description                                                                       | Default  | Example                                       |
| --------------------------- | --------------------------------------------------------------------------------- | -------- | --------------------------------------------- |
| `--mode=<mode>`             | Sync mode (`all`, `recent`, `single`)                                             | `recent` | `--mode=all`                                  |
| `--order-id=<ss_id>`        | ShipStation Order ID to sync (required for `single` mode)                         | -        | `--order-id=12345678`                         |
| `--days-back=<days>`        | Number of days to look back for modified orders (for `recent` mode)               | 2        | `--days-back 7`                               |
| `--hours=<hours>`           | Number of hours to look back (for `recent` mode, overrides `--days-back`)         | -        | `--hours 12`                                  |
| `--order-date-start=<date>` | Start date filter (YYYY-MM-DD HH:MM:SS format, assumes Pacific Time)              | -        | `--order-date-start="2024-01-01 00:00:00"`    |
| `--order-date-end=<date>`   | End date filter (YYYY-MM-DD HH:MM:SS format, assumes Pacific Time)                | -        | `--order-date-end="2024-01-31 23:59:59"`      |
| `--force-start-date=<date>` | Force sync to start from this ISO date (YYYY-MM-DDTHH:mm:ss.sssZ, for `all` mode) | -        | `--force-start-date=2023-01-01T00:00:00.000Z` |
| `--skip-tags`               | Skip syncing ShipStation tags                                                     | `false`  | `--skip-tags`                                 |
| `--verbose`                 | Show verbose output (Note: May not increase detail beyond Prisma logs)            | `false`  | `--verbose`                                   |
| `--dry-run`                 | Simulate operations without making changes                                        | `false`  | `--dry-run`                                   |

#### `amazon` - Process Amazon customization (Currently Not Implemented)

Handles Amazon customization processes. **Note:** These subcommands are currently placeholders and do not execute the intended logic. Amazon URL fetching is now integrated into `populate-print-queue.ts`.

```bash
npx tsx src/scripts/order-sync.ts amazon <subcommand> [options]
```

##### Subcommands (Placeholders)

###### `sync` - Download and process Amazon customization files (Not Implemented)

###### `update` - Update order items with personalization data (Not Implemented)

###### `fix` - Find and fix orders with missing personalization data (Not Implemented)

###### `workflow` - Run the entire Amazon customization workflow (Not Implemented)

#### `status` - Show sync status and statistics (May need update/verification)

Displays information about order synchronization status.

```bash
npx tsx src/scripts/order-sync.ts status [options]
```

| Option               | Description                                | Default | Example          |
| -------------------- | ------------------------------------------ | ------- | ---------------- |
| `--days-back=<days>` | Number of days to look back for statistics | 7       | `--days-back=14` |

#### `metrics` - Report on sync performance and issues (May need update/verification)

Generates metrics reports for order synchronization.

```bash
npx tsx src/scripts/order-sync.ts metrics [options]
```

| Option              | Description                      | Default | Example                 |
| ------------------- | -------------------------------- | ------- | ----------------------- |
| `--format=<format>` | Output format (json, table, csv) | `table` | `--format=json`         |
| `--output=<file>`   | Output file for metrics          | -       | `--output=metrics.json` |

## Populate Print Queue Script (`populate-print-queue.ts`)

Fetches eligible orders from the database, processes personalization (prioritizing Amazon URLs, then eBay notes, then AI), and creates/updates print tasks.

### Usage

```bash
npx tsx src/scripts/populate-print-queue.ts [options]
```

### Options

| Option                   | Alias | Description                                                                                               | Default       | Example                   |
| ------------------------ | ----- | --------------------------------------------------------------------------------------------------------- | ------------- | ------------------------- |
| `--order-id=<id>`        | `-o`  | Process specific order by **database ID**. Bypasses default filters.                                      | -             | `--order-id 450`          |
| `--limit=<number>`       | `-l`  | Limit the number of orders fetched when not using `--order-id`.                                           | 10            | `--limit 100`             |
| `--force-recreate`       | `-f`  | Delete existing tasks for fetched orders before creating new ones. Allows reprocessing orders with tasks. | `false`       | `--force-recreate`        |
| `--clear-all`            |       | Delete ALL print tasks from the database before processing. **Requires confirmation unless -y is used.**  | `false`       | `--clear-all`             |
| `--confirm`              | `-y`  | Skip confirmation prompts (e.g., for `--clear-all`).                                                      | `false`       | `-y`                      |
| `--create-placeholder`   |       | Create placeholder task if Amazon URL fetch fails and AI extraction also fails/is skipped.                | `true`        | `--no-create-placeholder` |
| `--openai-api-key=<key>` |       | OpenAI API Key (reads from `OPENAI_API_KEY` env var by default).                                          | `env`         | `--openai-api-key sk-...` |
| `--openai-model=<model>` |       | OpenAI model to use for extraction.                                                                       | `gpt-4o-mini` | `--openai-model gpt-4`    |
| `--log-level=<level>`    |       | Set log level (e.g., `debug`, `info`, `warn`, `error`).                                                   | `info`        | `--log-level debug`       |
| `--dry-run`              |       | Simulate operations without making database changes.                                                      | `false`       | `--dry-run`               |
| `--debug-file=<path>`    |       | Path for detailed debug log file (requires `--order-id`).                                                 | -             | `--debug-file debug.log`  |
| `--help`                 | `-h`  | Show help information.                                                                                    | -             | `--help`                  |

_(Note: The old `print-tasks.ts` script seems deprecated or refactored into `populate-print-queue.ts` based on recent changes. Commands like `update`, `cleanup`, `status`, `metrics` specific to print tasks might need separate scripts or integration into `utils.ts` if still required.)_

## Utilities Script (`utils.ts`)

The Utils script provides various utility functions for system maintenance and diagnostics. (Structure and commands may need verification based on current implementation).

### Usage

```bash
npx tsx src/scripts/utils.ts <command> [options]
```

### Commands (Example Structure - Verify Actual Implementation)

#### `check` - Check system status

##### Subcommands

###### `database` - Check database status and consistency

###### `order` - Check order details and status

#### `fix` - Fix common issues

##### Subcommands

###### `missing-data` - Find and fix missing data

###### `orphaned-tasks` - Find and fix orphaned tasks

#### `backup` - Backup database or files

##### Subcommands

###### `database` - Backup the database

###### `logs` - Backup log files

#### `stats` - Generate statistics and reports

##### Subcommands

###### `orders` - Generate order statistics

###### `ai-usage` - Generate AI usage statistics

## Examples

### Order Synchronization

```bash
# Sync recent orders from the last 12 hours
npx tsx src/scripts/order-sync.ts sync --mode=recent --hours 12

# Sync orders modified between two dates (Pacific Time assumed by ShipStation)
npx tsx src/scripts/order-sync.ts sync --order-date-start="2024-03-01 00:00:00" --order-date-end="2024-03-31 23:59:59"

# Sync a single specific order from ShipStation
npx tsx src/scripts/order-sync.ts sync --mode=single --order-id=<SHIPSTATION_ORDER_ID>
```

### Print Task Population

```bash
# Populate tasks for the 50 oldest eligible orders
npx tsx src/scripts/populate-print-queue.ts --limit 50

# Force re-population for the 20 oldest eligible orders, deleting old tasks first
npx tsx src/scripts/populate-print-queue.ts --limit 20 --force-recreate

# Force re-population for a specific order (DB ID 450)
npx tsx src/scripts/populate-print-queue.ts --order-id 450 --force-recreate

# Clear the entire print queue and repopulate up to 100 orders (no confirmation prompt)
npx tsx src/scripts/populate-print-queue.ts --clear-all -y --limit 100 --force-recreate
```

### Utilities (Verify actual commands)

```bash
# Check database status and consistency with verbose output
npx tsx src/scripts/utils.ts check database --verbose

# Backup the database to a specific directory
npx tsx src/scripts/utils.ts backup database --output=/mnt/backups
```


<<< FILE: ./docs/DATABASE.md >>>

# Database Schema and Standards

This document describes the Y3DHub database schema, conventions, and standards.

## Schema

- The database schema is defined in `prisma/schema.prisma`.
- Migrations are managed using Prisma Migrate.

## Key Models

- `Order`: Represents customer orders from various marketplaces.
- `OrderItem`: Represents individual items within an order.
- `AmazonCustomization`: Stores Amazon personalization data.
- `PrintTask`: Represents tasks for the printing process.
- `Product`: Stores product information.
- `ScriptRunLog`: Logs the execution of scripts.

[Add details about important relations and fields.]

## Naming Conventions

- Models: PascalCase (e.g., `OrderItem`)
- Fields: camelCase (e.g., `orderNumber`)
- Enums: PascalCase (e.g., `OrderStatus`)
- Relations: Use descriptive names (e.g., `orderItems` on `Order`)

## Timestamp Handling

- All timestamps are stored in UTC.
- See `docs/timezone-handling.md` for details.

## Data Integrity

- Use appropriate constraints (unique, foreign keys).
- Implement validation logic in the application layer.


<<< FILE: ./docs/DEVELOPMENT.md >>>

# Development Guide

This document provides guidelines and best practices for developing and maintaining the Y3DHub application.

## Code Organization

The application follows a standard Next.js App Router structure:

```
src/
├── app/                # Next.js App Router directory
│   ├── api/            # API Route Handlers
│   ├── orders/         # Orders pages
│   ├── print-queue/    # Print queue pages
│   └── ...
├── components/         # React components
│   ├── ui/             # UI components (shadcn/ui)
│   └── ...
├── lib/                # Core libraries and utilities
│   ├── actions/        # Server actions
│   ├── shipstation/    # ShipStation API integration
│   └── ...
└── scripts/           # Utility scripts
```

## Development Workflow

1. **Environment Setup**:

   - Copy `.env.example` to `.env` and fill in the required values
   - Run `npm install` to install dependencies
   - Run `npx prisma generate` to generate Prisma client

2. **Development Server**:

   - Run `npm run dev` to start the development server
   - Access the application at http://localhost:3000

3. **Building for Production**:
   - Run `npm run build` to build the application
   - Run `npm start` to start the production server

## Best Practices

### Database Access

- Use the singleton Prisma client from `src/lib/prisma.ts`
- Use transactions for operations that modify multiple records
- Set appropriate timeout values for long-running operations
- Always disconnect from the database in scripts using `finally` blocks

```typescript
try {
  // Database operations
} catch (error) {
  console.error("Error:", error);
} finally {
  await prisma.$disconnect();
}
```

### Error Handling

- Use the centralized error handling utilities in `src/lib/errors.ts`
- Always use `handleApiError` in API routes to ensure consistent error responses
- Log errors with appropriate context information

```typescript
try {
  // API logic
} catch (error) {
  console.error("Error context:", error);
  return handleApiError(error);
}
```

### Security

- Never hardcode credentials in the codebase
- Use environment variables for all sensitive information
- Validate user input using Zod schemas
- Implement proper authentication checks in API routes

### Performance

- Use pagination for large data sets
- Implement caching where appropriate
- Optimize database queries with proper indexes
- Use server components where possible to reduce client-side JavaScript

### Testing

- Write unit tests for critical functionality
- Test API endpoints with different input scenarios
- Verify error handling works as expected

## Common Tasks

### Adding a New API Endpoint

1. Create a new file in `src/app/api/` following the Next.js App Router conventions
2. Import the necessary dependencies
3. Implement the request handlers (GET, POST, etc.)
4. Use proper error handling with `handleApiError`
5. Document the endpoint with JSDoc comments

### Adding a New Component

1. Create a new file in `src/components/`
2. Use TypeScript interfaces for props
3. Follow the existing component patterns
4. Add appropriate comments for complex logic

### Working with the Database

1. Update the schema in `prisma/schema.prisma` if needed
2. Run `npx prisma migrate dev --name <migration_name>` to create a migration
3. Run `npx prisma generate` to update the Prisma client
4. Use the Prisma client from `src/lib/prisma.ts` in your code

### Adding a New Script

1. Create a new file in the appropriate subdirectory of `scripts/`
2. Add a header comment explaining the purpose and usage
3. Implement proper error handling and database disconnection
4. Update the `scripts/README.md` file if necessary

## ShipStation Integration Notes

### Updating Order Item Options

Updating specific details of an order item in ShipStation (e.g., adding personalization options extracted from Amazon) requires using the `/orders/createorder` endpoint. This endpoint handles both creating new orders and updating existing ones.

**Important:** Unlike some APIs where you send only the changed fields, ShipStation requires you to send back a payload that closely resembles the **entire order object** as you would fetch it from their API, with your modifications applied. Sending partial payloads or incorrect combinations of identifiers (`orderId`, `orderKey`) can lead to errors (like 500 "Import Key must be set" or 404 "Not Found") or silent failures (API returns 200 OK, but no changes are actually saved).

The correct process, implemented in `src/lib/shipstation/api.ts` (`updateOrderItemOptions` function) and used by scripts like `src/scripts/populate-print-queue.ts`, is as follows:

1.  **Fetch Full Order:** Before attempting an update, fetch the complete, current order details from ShipStation using the appropriate endpoint (e.g., `/orders/{shipstation_order_id}` or `/orders?orderNumber=...`). This provides the base object for the update.
2.  **Prepare Updated Item Options:** Construct the array of `options` you want to set for the specific item (e.g., `[{ name: "Personalization", value: "..." }, { name: "Color", value: "..." }]`).
3.  **Modify Items Array:** Create a _new_ array of order items based on the `items` array from the fetched order. Map through the original items:
    - If an item matches the `lineItemKey` you want to update, return a copy of that item (`...item`) but replace its `options` property with the new options array prepared in step 2.
    - If an item does not match, return it unchanged.
4.  **Construct Full Payload:** Create the payload object for the POST request:
    - Use the spread operator (`...`) on the **full fetched order object** obtained in step 1. This includes `orderId`, `orderKey`, addresses, status, dates, etc.
    - Override the `items` property in the spread object with the **modified items array** created in step 3.
5.  **Send Update Request:** Make a `POST` request to `/orders/createorder` with the fully constructed payload.

This ensures ShipStation receives all the necessary context from the original order while applying the specific item option changes.

## Timezone Handling (From docs/timezone-handling.md)

This section explains how timezones are handled in the Y3DHub application, particularly for ShipStation integration.

### Overview

- **ShipStation** operates in **Pacific Time** (America/Los_Angeles), which is UTC-8 during standard time and UTC-7 during daylight saving time.
- Our **database** stores all timestamps in **UTC**.
- Our **UI** displays timestamps in **UTC** with a timezone indicator.

### Implementation Details

#### 1. Storing ShipStation Timestamps

When we receive timestamps from ShipStation, we convert them from Pacific Time to UTC before storing them in the database using the `convertShipStationDateToUTC` function in `src/lib/orders/mappers.ts` (which utilizes `date-fns-tz`).

#### 2. Displaying Timestamps

When displaying timestamps in the UI, we use the utility functions from `src/lib/shared/date-utils.ts` (e.g., `formatDateWithTimezone`) to format them consistently in UTC with a timezone indicator.

#### 3. Relative Time Formatting

For relative time formatting (e.g., \"2 hours ago\"), we use the `formatRelativeTime` function from `src/lib/shared/date-utils.ts`, which also ensures UTC context.

### Libraries Used

- **date-fns**: For basic date formatting and calculations
- **date-fns-tz**: For timezone-aware date formatting and conversions

### Migration

A migration script (`scripts/migrate-timestamps.ts`) was previously used to update existing timestamps in the database from PST to UTC.

### Best Practices

1. **Always use the utility functions** from `src/lib/shared/date-utils.ts` for date formatting and display.
2. **Never manually manipulate dates** without considering timezone implications.
3. **Always include UTC timezone indicators** in the UI to avoid confusion.
4. **Document any timezone-specific logic** in comments.

### Common Issues

1. **Browser timezone differences**: The browser may display dates in the local timezone. Always use the utility functions to ensure consistent UTC display.
2. **Daylight saving time**: Pacific Time switches between PST and PDT. The `date-fns-tz` library handles this.
3. **Manual date manipulation**: Avoid manually adding/subtracting hours.

### Testing

When testing timezone-related functionality:

1. Test with dates during both standard time and daylight saving time.
2. Test with browsers set to different timezones.
3. Verify that dates are displayed consistently as UTC across the application.


<<< FILE: ./docs/EBAY.md >>>

wi_395107128418_8	663689296397	Brown
wi_395107128418_9	663689296404	Light Brown
wi_395107128418_11	663689296405	Cold White
wi_395107128418_24	663689296406	Bronze
wi_395107128418_16	663689296407	Matt Pink
wi_395107128418_7	663689296408	Dark Blue
wi_395107128418_22	663689296409	Gold
wi_395107128418_1	663689296410	White
wi_395107128418_19	663689296411	Fire Engine Red
wi_395107128418_21	663689296412	Yellow
wi_395107128418_14	663689296413	Silk Pink
wi_395107128418_15	663689296414	Rose Gold
wi_395107128418_10	663689296415	Pine Green
wi_395107128418_20	663689296416	Olive Green
wi_395107128418_0	663689296417	Black
wi_395107128418_17	663689296418	Magenta
wi_395107128418_5	663689296419	Peak Green
wi_395107128418_4	663689296420	Green
wi_395107128418_12	663689296421	Purple
wi_395107128418_18	663689296422	Orange
wi_395107128418_6	663689296423	Light Blue
wi_395107128418_13	663689296424	Pink
wi_395107128418_23	663689296425	Random Selection
wi_395107128418_2	663689296426	Blue
wi_395107128418_3	663689296427	Red


<<< FILE: ./docs/FUTURE_IMPROVEMENTS.md >>>

# Future Improvements for Y3DHub

This document outlines recommended future improvements for the Y3DHub system based on current observations and best practices.

## Order Synchronization

### API Rate Limiting and Backoff Strategy
- Implement exponential backoff for API failures
- Add rate limiting detection and handling for ShipStation API
- Create a queue system for retrying failed API calls
- Monitor API usage to stay within ShipStation limits

### Enhanced Error Recovery
- Implement transaction rollback for partial sync failures
- Add ability to resume sync from point of failure
- Create a dedicated error log for sync failures with actionable insights
- Implement automatic retry for specific error types

### Data Integrity
- Add checksums or version tracking for order data
- Implement conflict resolution for concurrent updates
- Add validation rules for incoming order data
- Create data repair tools for fixing inconsistencies

## Print Queue Management

### AI Personalization Extraction
- Fine-tune a custom model specifically for personalization extraction
- Implement a feedback loop where corrections improve future extractions
- Add support for image-based personalization instructions
- Create a gallery of example extractions for training purposes

### Performance Optimization
- Batch AI calls for multiple orders to reduce API overhead
- Implement caching for common personalization patterns
- Pre-process order data to simplify AI extraction
- Optimize database queries for large order volumes

### User Experience
- Add bulk editing capabilities for print tasks
- Implement drag-and-drop reordering of print queue
- Create customizable views based on user preferences
- Add print task templates for common personalization types

## Monitoring and Analytics

### Enhanced Metrics
- Track AI extraction accuracy over time
- Monitor order processing times across marketplaces
- Measure print task completion rates and bottlenecks
- Create dashboards for business KPIs

### Alerting System
- Set up alerts for abnormal sync patterns
- Create notifications for high-priority orders
- Implement warnings for potential AI extraction issues
- Add system health monitoring with proactive alerts

### Reporting
- Generate daily/weekly reports on order volume and processing
- Create analytics for marketplace performance comparison
- Track seasonal trends and prepare for high-volume periods
- Measure AI cost and performance metrics

## Infrastructure and Scalability

### Database Optimization
- Implement database partitioning for historical orders
- Add read replicas for reporting queries
- Optimize indexes for common query patterns
- Implement data archiving strategy for old orders

### Caching Strategy
- Add Redis caching for frequently accessed data
- Implement edge caching for static resources
- Create a tiered caching strategy based on data volatility
- Optimize cache invalidation to maintain data freshness

### Horizontal Scaling
- Refactor services for containerization
- Implement message queues for asynchronous processing
- Create microservices for independent scaling of components
- Design for multi-region deployment

## Security and Compliance

### Data Protection
- Implement field-level encryption for sensitive customer data
- Create data retention policies compliant with regulations
- Add audit logging for all data access and modifications
- Implement secure API key rotation

### Access Control
- Create role-based access control for different user types
- Implement principle of least privilege for all operations
- Add IP restrictions for administrative functions
- Create audit trails for security-relevant actions

### Compliance
- Ensure GDPR compliance for customer data handling
- Implement PCI DSS requirements for payment information
- Create data export tools for subject access requests
- Document compliance measures for each marketplace

## Integration and Extensibility

### Additional Marketplaces
- Add direct integration with Shopify API
- Implement WooCommerce connector for self-hosted stores
- Create a generic marketplace adapter for custom integrations
- Support for international marketplaces with localization

### Third-party Services
- Add integration with shipping providers for label printing
- Implement accounting software integration for financial tracking
- Create connections to CRM systems for customer management
- Support for inventory management systems

### API and Webhooks
- Create a comprehensive API for external access
- Implement webhooks for real-time event notifications
- Add OAuth support for secure third-party access
- Create developer documentation for API usage

## Implementation Priority

1. **High Priority (Next 1-3 Months)**
   - API rate limiting and backoff strategy
   - Enhanced error recovery for sync processes
   - Performance optimization for AI extraction
   - Basic monitoring and alerting

2. **Medium Priority (3-6 Months)**
   - Database optimization for growing data volume
   - Additional marketplace integrations
   - Enhanced user experience features
   - Security and compliance improvements

3. **Long-term (6+ Months)**
   - Advanced analytics and reporting
   - Horizontal scaling architecture
   - Comprehensive API and webhook system
   - AI model fine-tuning and optimization

## Conclusion

These recommendations provide a roadmap for evolving the Y3DHub system to handle increased scale, improve reliability, and enhance user experience. Prioritization should be based on business needs, user feedback, and available resources.

Regular review of this improvement plan is recommended as the system evolves and new requirements emerge.

\

---

## Print Queue Improvements (From NEWFEATURES.md)

### Overview
This document outlines the planned improvements to the print queue page to enhance usability, visibility, and efficiency.

### Changes to Implement

#### 1. Default Display Settings
- **Default to 250 tasks per page** (user can go up to 1000 per page)
- **Most recent tasks first** by default
- **Limit selector options**: 50, 100, 250, 500, 1000

#### 2. Column Reordering
Change layout from:
```
Status, Review, Order #, Shipping Method, Product SKU, Qty, Color 1, Color 2, Custom Text, Ship By
```

To:
```
Product SKU (truncated to 15 chars), Product Name (truncated to 15 chars), Qty, Color 1, Color 2, Custom Text, Status, Review?, Ship By, Order #, Shipping Method
```

#### 3. Sorting Functionality
- **Enable sorting by any column** (currently only ship by date)
- **Display relative dates** for Ship By dates (e.g., \"Tomorrow\" or \"Today\" instead of the date)
- **Allow advanced ordering by multiple columns** (e.g., by Color 1, Color 2, SKU)

#### 4. Task Totals Display
- **Show total number of pending tasks**
- **Show total number of completed tasks**
- **Display totals for the current page**

#### 5. Enhanced Filtering
- **Filter by Color 1**
- **Filter by Color 2**
- **Filter by both colors simultaneously**
- **Improved text search** across all relevant fields

#### 6. Color Display Improvements
- **Use rounded boxes with text inside** for better visibility
- **Ensure proper contrast** for all color names
- **Consistent styling** across the application
- **Special handling** for problematic colors like Light Blue, Magenta, and White

#### 7. UI/UX Enhancements
- **Responsive design** for all screen sizes
- **Improved loading states**
- **Better error handling**
- **Keyboard shortcuts** for common actions

### Implementation Approach
1. Update default limit in page.tsx
2. Create new column definitions with reordered columns
3. Implement relative date formatting for Ship By dates
4. Add task totals calculation and display
5. Enhance filtering capabilities
6. Ensure consistent color styling
7. Test thoroughly across different scenarios

### Benefits
- **Improved efficiency** for users managing print tasks
- **Better visibility** of important information
- **Enhanced filtering** to find specific tasks quickly
- **Consistent experience** across the application


<<< FILE: ./docs/IDE_GUIDELINES.md >>>

# Y3DHub IDE Guidelines for Refactoring Project

## Table of Contents

1. [Introduction](#introduction)
2. [Project Structure](#project-structure)
3. [Import Standards](#import-standards)
4. [TypeScript Guidelines](#typescript-guidelines)
5. [File Conventions](#file-conventions)
6. [Script Development](#script-development)
7. [Documentation Standards](#documentation-standards)
8. [Error Handling](#error-handling)
9. [Shared Module Usage](#shared-module-usage)
10. [Database Practices](#database-practices)
11. [VS Code Configuration](#vs-code-configuration)

## Introduction

This document provides specific guidelines for the Y3DHub refactoring project, focusing on the script consolidation and reorganization outlined in TODO_V3_UPDATED.md. Following these standards will ensure consistency across the codebase and simplify merging and reviewing changes.

## Project Structure

Maintain the following directory structure for the refactored code:

```
src/
├── lib/
│   ├── orders/
│   │   ├── amazon/
│   │   │   ├── customization.ts
│   │   │   ├── sync.ts
│   │   │   ├── update.ts
│   │   │   ├── fix.ts
│   │   │   ├── workflow.ts
│   │   │   └── metrics.ts
│   │   ├── sync.ts
│   │   ├── mappers.ts
│   │   ├── metrics.ts
│   │   └── status.ts
│   ├── print-tasks/
│   │   ├── create.ts
│   │   ├── update.ts
│   │   ├── cleanup.ts
│   │   ├── metrics.ts
│   │   └── status.ts
│   ├── utils/
│   │   ├── check.ts
│   │   ├── fix.ts
│   │   ├── backup.ts
│   │   └── stats.ts
│   ├── shared/
│   │   ├── shipstation.ts
│   │   ├── database.ts
│   │   ├── logging.ts
│   │   ├── metrics.ts
│   │   └── date-utils.ts
│   └── prisma.ts
└── scripts/
    ├── order-sync.ts
    ├── print-tasks.ts
    └── utils.ts
```

## Import Standards

1. **Absolute Imports**: Use the `@/` prefix for all internal imports:

```typescript
// Correct
import { prisma } from "@/lib/prisma";
import { logger } from "@/lib/shared/logging";

// Incorrect
import { prisma } from "../../lib/prisma";
import { logger } from "../shared/logging";
```

2. **Import Order**: Follow this order for imports:

```typescript
// 1. Node.js built-in modules
import fs from "fs";
import path from "path";

// 2. External libraries
import { Command } from "commander";
import { PrismaClient } from "@prisma/client";

// 3. Internal modules (using absolute paths)
import { logger } from "@/lib/shared/logging";
import { prisma } from "@/lib/prisma";
import { syncOrders } from "@/lib/orders/sync";

// 4. Type imports
import type { OrderSyncOptions } from "@/lib/orders/types";
```

3. **No Circular Dependencies**: Avoid circular dependencies between modules.

## TypeScript Guidelines

1. **Explicit Types**: Always provide explicit return types for functions, especially exported ones:

```typescript
// Correct
export async function syncOrders(
  options: OrderSyncOptions
): Promise<SyncResult> {
  // Implementation
}

// Incorrect
export async function syncOrders(options) {
  // Implementation
}
```

2. **Interface vs Type**: Use interfaces for objects that will be extended or implemented, and types for unions, intersections, or simple object shapes:

```typescript
// Interface for extendable objects
interface OrderSyncOptions {
  daysBack?: number;
  orderId?: number;
  dryRun?: boolean;
}

// Type for unions or simple shapes
type SyncMode = "all" | "recent" | "single";
```

3. **Snake Case for Database Fields**: Use snake_case for database field names to match the schema:

```typescript
const orderData = {
  shipstation_order_id: "12345",
  created_at: new Date(),
  customer_id: customerId,
};
```

4. **Use Proper Prisma Types**: Use the correct Prisma input types:

```typescript
import { Prisma } from "@prisma/client";

const orderData: Prisma.OrderCreateInput = {
  shipstation_order_id: "12345",
  created_at: new Date(),
  customer: { connect: { id: customerId } },
};
```

## File Conventions

1. **File Naming**: Use kebab-case for filenames:

```
order-sync.ts
print-tasks.ts
date-utils.ts
```

2. **Executable Scripts**: Add shebang and make executable:

```typescript
#!/usr/bin/env tsx
/**
 * Script: order-sync.ts
 * Description: Synchronizes orders from ShipStation
 */
```

3. **JSDoc Comments**: Add JSDoc comments for all exported functions, classes, and types:

```typescript
/**
 * Synchronizes orders from ShipStation to the local database
 *
 * @param options - Configuration options for the sync process
 * @returns A promise that resolves to the sync results
 */
export async function syncOrders(
  options: OrderSyncOptions
): Promise<SyncResult> {
  // Implementation
}
```

## Script Development

1. **Command Pattern**: Use the Commander.js library for CLI argument parsing:

```typescript
import { Command } from "commander";

const program = new Command();

program
  .name("order-sync")
  .description("Synchronize orders from ShipStation")
  .version("1.0.0");

program
  .command("all")
  .description("Sync all orders")
  .option("--days-back <days>", "Number of days to look back", "7")
  .action(async (options) => {
    // Command implementation
  });

program.parse(process.argv);
```

2. **Error Handling**: Implement proper error handling and database disconnection:

```typescript
try {
  // Script implementation
} catch (error) {
  logger.error("Error syncing orders:", { error });
  process.exit(1);
} finally {
  await prisma.$disconnect();
}
```

3. **Metrics Collection**: Include metrics collection in all scripts:

```typescript
const startTime = Date.now();
const metrics = createMetricsCollector();

// Script implementation

metrics.recordDuration(Date.now() - startTime);
await metrics.saveMetrics();
```

## Documentation Standards

1. **JSDoc Documentation**: Use JSDoc comments for all exported functions, classes, and types.

2. **Module Documentation**: Add a comment at the top of each file describing its purpose:

```typescript
/**
 * Shipstation API Integration
 *
 * This module provides functions for interacting with the ShipStation API,
 * including order retrieval, update, and status management.
 */
```

3. **Function Documentation**: Document function parameters, return values, and exceptions:

```typescript
/**
 * Retrieves orders from ShipStation API
 *
 * @param options - Options for retrieving orders
 * @param options.daysBack - Number of days to look back for orders
 * @param options.pageSize - Number of orders to retrieve per page
 * @returns A promise that resolves to an array of ShipStation orders
 * @throws {ApiError} If the API request fails
 */
```

## Error Handling

1. **Structured Error Handling**: Use try/catch blocks with appropriate error logging:

```typescript
try {
  await syncOrders(options);
} catch (error) {
  if (error instanceof ApiError) {
    logger.error("API Error:", {
      message: error.message,
      status: error.status,
      details: error.details,
    });
  } else {
    logger.error("Unexpected error:", { error });
  }
  throw error; // Rethrow for higher-level handling
}
```

2. **Custom Error Classes**: Define and use custom error classes for different error types:

```typescript
export class ApiError extends Error {
  constructor(
    message: string,
    public status: number,
    public details?: any
  ) {
    super(message);
    this.name = "ApiError";
  }
}
```

3. **Transaction Rollback**: Ensure proper transaction rollback in case of errors:

```typescript
await prisma.$transaction(async (tx) => {
  try {
    // Transaction operations
  } catch (error) {
    // Transaction will automatically roll back
    logger.error("Transaction error:", { error });
    throw error;
  }
});
```

## Shared Module Usage

1. **Database Module**: Use the shared database module for all database operations:

```typescript
import { withTransaction } from "@/lib/shared/database";

await withTransaction(async (tx) => {
  // Transaction operations using tx instead of prisma
});
```

2. **Logging Module**: Use the shared logging module for all logging:

```typescript
import { logger } from "@/lib/shared/logging";

logger.info("Starting order sync", { options });
logger.error("Error syncing orders", { error });
```

3. **Metrics Module**: Use the shared metrics module for all metrics collection:

```typescript
import { recordMetric } from "@/lib/shared/metrics";

await recordMetric("orders_synced", ordersProcessed);
```

## Database Practices

1. **Transactions**: Use transactions for operations that modify multiple records:

```typescript
await prisma.$transaction(async (tx) => {
  const order = await tx.order.create({ data: orderData });
  await tx.orderItem.createMany({
    data: items.map((item) => ({ ...item, orderId: order.id })),
  });
  return order;
});
```

2. **Batch Operations**: Use batch operations when possible:

```typescript
await prisma.orderItem.createMany({
  data: items.map((item) => ({ ...item, orderId: orderId })),
  skipDuplicates: true,
});
```

3. **Field Names**: Use the exact field names from the Prisma schema:

```typescript
// Correct
const order = await prisma.order.create({
  data: {
    shipstation_order_id: "12345",
    created_at: new Date(),
  },
});

// Incorrect
const order = await prisma.order.create({
  data: {
    shipstationOrderId: "12345", // Wrong: should be snake_case
    createdAt: new Date(), // Wrong: should be snake_case
  },
});
```

## VS Code Configuration

Configure VS Code to streamline development:

1. **Settings**: Create or update `.vscode/settings.json`:

```json
{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": "explicit"
  },
  "typescript.tsdk": "node_modules/typescript/lib",
  "eslint.validate": [
    "javascript",
    "javascriptreact",
    "typescript",
    "typescriptreact"
  ],
  "files.exclude": {
    "**/.git": true,
    "**/.DS_Store": true,
    "**/node_modules": true,
    "**/.next": true
  }
}
```

2. **Extensions**: Recommended VS Code extensions:

- ESLint
- Prettier
- Prisma
- TypeScript Import Sorter
- Error Lens
- GitLens
- Todo Tree

## Summary Checklist

When working on the refactoring project, check that your code:

- [ ] Follows the directory structure outlined in this document
- [ ] Uses absolute imports with the `@/` prefix
- [ ] Includes proper TypeScript types for all functions and variables
- [ ] Uses snake_case for database field names
- [ ] Follows file naming conventions
- [ ] Includes JSDoc comments for all exported functions
- [ ] Implements proper error handling
- [ ] Uses shared modules for database, logging, and metrics
- [ ] Uses transactions for operations that modify multiple records
- [ ] Is formatted according to the project's style guide


<<< FILE: ./docs/NEW_CODE_REVIEW.md >>>

Full code review focused on order‑sync, Amazon customisation, and print‑task logic under src/lib.
I group feedback by theme, then by file, and finish with concrete next‑steps.
────────────────────────────────────────
Cross‑cutting observations
────────────────────────────────────────
• File size / modularity
− orders/sync.ts (1 213 LOC) and shipstation/db-sync.ts (930 LOC) are far above the 300‑line guideline.
− They each mix API‑paging, progress tracking, domain mapping, DB upserts and metric logging.
→ Split into focused modules (e.g. customers/, products/, orders/, progress/, metrics/).
→ Keep “transactional” logic (one order + its items) in a separate pure function that is easy to unit‑test.
• Duplication
− upsertCustomerFromOrder, upsertProductFromItem, mapping helpers and date conversion are duplicated in orders/* and shipstation/*.
→ Move to lib/shared/{customers,products,mappers}.ts and re‑use.
• Type ownership
− ShipStation & Amazon types appear in multiple barrels. Expose them from one canonical lib/integrations/shipstation/types.ts and avoid type Foo = Prisma.Bar.
− Prefer interface over type for contracts you control (matches your custom instruction).
• Error handling
− Good use of structured logging, but failures that continue loops should escalate aggregated context to the caller.
− Consider a typed Result<T,E> utility to propagate errors without boolean flags.
• Concurrency / rate‑limits
− await is called inside for loops (serial). That’s safe for rate‑limits but slow when you are DB‑bound.
→ Adopt p‑map or a home‑grown semaphore to process items in parallel with e.g. concurrency = 5, still respecting ShipStation API delay.
• Testing
− No unit or integration tests found for these critical paths (except amazon/__tests__ folder but empty).
→ Add tests for:
1) mapping accuracy (mapSsItemToOrderItemData, date conversion)
2) idempotent upserts (unique constraints)
3) Amazon JSON extraction edge‑cases (colour tags, nested customisation).
• Logging
− Some string interpolation is expensive (template literals creating long messages) when log‑level is > info.
→ Guard heavy logs or use a logger that lazily evaluates.
• Environment / secrets
− API keys for ShipStation are not visible here—good—but make sure shipstationApi pulls from process.env and not userland import.
────────────────────────────────────────
File‑specific feedback
────────────────────────────────────────
A. orders/mappers.ts
✔ Clear pure functions, mostly side‑effect‑free.
✘ convertShipStationDateToUTC calls toDate inside a hot loop; cache SHIPSTATION_TIMEZONE parser or move conversion downstream only for persisted timestamps.
✘ consider returning undefined instead of null for absent optional fields to avoid Prisma JsonNull gymnastics and let .optional() schema handle defaults.
B. orders/sync.ts
• Large monolithic file; split per concern.
• upsertProductFromItem
− shipstation_product_id uniqueness conflict handled, but isNewProduct flag equals createdAt==updatedAt, which fails if DB triggers update timestamp. Better: check prisma.$transaction returns product.$transactionInfo?.wasCreated.
• Pagination loop
− while (page <= totalPages && success) is fine, but totalPages = Infinity until first page; if the first fetch errors out you waste a meaningless infinity loop guard.
• Metrics
− recordMetric is called only on success paths; wrap entire loop with try/finally to record global outcome.
• Dry‑run
− Good, but mocked objects have incomplete nullable fields some callers might later expect; consider a typed createMock<Customer>() helper.
C. orders/amazon/customization.ts
✔ Uses streaming unzip; good memory profile.
✔ Timeout via AbortController.
✘ isColourTag regex may mis‑detect “icoloration”; prepend \b(color|colour)\b.
✘ jsonFile[0]!.async (!) will throw if filtering returns empty; you already guard but do type‑narrow.
✘ allFields loops over top‑level keys only; nested structures are stringified as [object Object]. Consider flatMapKeys utility or persist JSON raw only.
✘ Not unit‑tested. Provide canned JSON fixtures.
D. orders/amazon/sync.ts
• Correctly supports targeted sync via orderId/itemId.
• findOrderItemsToProcess duplicates query logic across retries; extract.
• processOrderItem mixes IO (download), transform and DB; split into downloadFile, parseCustomization, persistResult.
• Missing concurrency control; simultaneous large downloads could thrash memory.
E. shipstation/db-sync.ts
• Very similar logic to orders/sync.ts; consolidate.
• generateSecureMockId presumably creates negative IDs for dry‑run; instead of fake IDs return null and adjust downstream code to handle optional customer.id.
• Uses relative imports like ../prisma that conflict with alias @/lib/... used elsewhere—standardise import strategy.
F. shipstation/index.ts
• Good barrel.
• Exposes both high‑level sync and low‑level clients; consider namespace separation to avoid accidental misuse.
────────────────────────────────────────
Suggested refactor plan
────────────────────────────────────────
Create new directories
src/lib/integrations/shipstation/{client,types,mappers.ts,upsert.ts}
src/lib/integrations/amazon/{customisation.ts,sync.ts}
src/lib/services/order-sync/{index.ts,progress.ts,metrics.ts}
Move duplicated upsert/mapping logic into shared pure modules; export small composable functions.
Replace giant sync.ts loops with orchestrators:
Apply to netlify.toml
Introduce p-limit (or own semaphore) for Amazon download & ShipStation item processing.
Add unit tests for pure helpers; stub Prisma with @prisma/client/runtime.
Adopt ESLint rule to prevent files > 300 LOC, deep nested try/catch, and duplicated code.
────────────────────────────────────────
Immediate quick‑wins
────────────────────────────────────────
• Extract duplicated upsertCustomerFromOrder into lib/shared/customers.ts.
• Replace Infinity placeholder with explicit let totalPages: number | null = null.
• Tighten isColourTag regex.
• Add npm run test amazon-custom with fixtures to guarantee parsing.
• Run ts-prune to drop unused exports (ShipStationTag etc.) and keep tree lean.
────────────────────────────────────────
Conclusion
────────────────────────────────────────
Overall the codebase shows thoughtful logging, dry‑run safeguards and clear domain mapping.
The primary areas to elevate it to production‑grade are (1) modularity, (2) eliminating duplication, (3) comprehensive tests, and (4) controlled parallelism for performance.
Applying the refactor plan in stages will improve maintainability, ease future features (e.g., other marketplaces), and align with your project’s clean‑code standards


<<< FILE: ./docs/README.md >>>

# Y3DHub Documentation

This directory contains documentation, reference materials, and resources for the Y3DHub 3D printing order management system.

## Directory Structure

- **configs/** - Configuration templates and examples
  - `crontab-config.txt` - Scheduled task configurations
  - `ecosystem.config.cjs` - PM2 process manager configuration
  - `netlify.toml` - Netlify deployment configuration
  - `windsurf_deployment.yaml` - Deployment configuration

- **json-samples/** - Example JSON data for testing and reference
  - Amazon order examples
  - Test fixtures
  - Manual color mapping examples

- **scripts/** - Reference scripts and utilities
  - Amazon API check scripts
  - Order processing utilities
  - Migration tools

## Key Documents

- [TODO.md](./TODO.md) - Current project roadmap and remaining tasks
- [recommendations.md](./recommendations.md) - Modernization and improvement recommendations

## Legacy Resources

This directory also contains some HTML samples and legacy response examples for reference purposes.

## How to Use This Documentation

Reference these files when:
1. Setting up new environments
2. Troubleshooting API integrations
3. Understanding data structures
4. Planning future development work

For active development, refer to the main README.md in the project root.


<<< FILE: ./docs/SHIPSTATION_SYNC.md >>>

# ShipStation Synchronization

This document outlines how the Print Queue system interacts with ShipStation for syncing order personalization details.

## Overview

The system can synchronize print task data (custom text and color information) from the database to ShipStation. This ensures that order details in ShipStation match what will be printed.

## Sync Functionality

The main sync function is provided through the `populate-print-queue.ts` script with the `--shipstation-sync-only` flag.

```bash
npx tsx src/scripts/populate-print-queue.ts --order-id <order-number> --shipstation-sync-only
```

This command will:

1. Find the order in the database
2. Fetch all print tasks associated with each order item
3. Update the ShipStation order with personalization options matching the database tasks
4. Report success or failure for each item

## Limitations

### Shipped Order Status

**Important:** ShipStation restricts modifications to orders that are already marked as "shipped" or "fulfilled".

When attempting to sync details for shipped orders:

- The API might return a successful response
- However, the changes may not be applied in the ShipStation system
- The script will warn you when attempting to update a shipped order
- You will be prompted to confirm whether to continue (unless using the `--confirm` flag)

### Other Limitations

- Only the first task for each order item is synced (most items only have one task)
- Items without ShipStation line item keys will be skipped
- Items without print tasks will be skipped
- Order status changes or other order-level updates are not handled by this sync

## Best Practices

1. **Process orders early**: Sync order details before they are marked as shipped in ShipStation
2. **Use dry run first**: Add the `--dry-run` flag to preview changes without applying them
3. **Monitor logs**: Check for warnings about shipped orders or other issues
4. **Verify updates**: Confirm changes are reflected in ShipStation's UI after sync
5. **For shipped orders**: Consider using ShipStation's UI directly to manually update details if needed

## Troubleshooting

If synchronization is not working as expected:

1. **Check order status**: Orders marked as "shipped" or "fulfilled" in ShipStation may ignore updates
2. **Verify database data**: Use `check-order.js` or Prisma Studio to confirm the database has the correct values
3. **API permissions**: Ensure the ShipStation API key has write access
4. **Rate limits**: ShipStation has API rate limits that may affect rapid updates
5. **Status Mismatch Script**: Use `src/scripts/fix-status-mismatch.ts` to check and correct discrepancies between ShipStation order status and the database status, including updating associated print tasks.

## Main Order & Tag Synchronization (`sync-orders.ts`)

The primary script for fetching order updates and tags from ShipStation and updating the local database is `src/scripts/sync-orders.ts`.

### Modes of Operation

- `--mode recent` (Default): Syncs orders modified within a recent timeframe (default 2 days, configurable with `--days-back` or `--hours`). Skips tag sync by default.
- `--mode all`: Syncs all orders since the last successful sync timestamp or a specified `--force-start-date`. Skips tag sync by default.
- `--mode single --order-id <ID>`: Syncs a single specific order. The `<ID>` can be the **Database ID**, **Marketplace Order Number**, or **ShipStation Order ID**. Skips tag sync.
- `--mode tags`: Syncs only the ShipStation tags and then exits.

### Options

- `--sync-tags`: **Enables** tag synchronization (skipped by default in `recent` and `all` modes).
- `--order-id <ID>`: Specifies the order identifier for `single` mode.
- `--days-back <N>` / `--hours <N>`: Sets the lookback period for `recent` mode.
- `--force-start-date <YYYY-MM-DD>`: Forces `all` mode to start from a specific date.
- `--dry-run`: Simulates the sync without making database changes. Useful for testing.
- `--verbose`: Enables more detailed logging output.

### Identifier Resolution (`--order-id`)

The `--order-id` flag for `single` mode is flexible:

1.  If the provided ID is purely numeric, the script first checks if it matches an `id` in the local `Order` table.
2.  If not found by DB ID, it checks if it matches a `shipstation_order_number`.
3.  If still not found, it assumes the numeric ID is the internal `shipstation_order_id`.
4.  If the provided ID is non-numeric, it assumes it's a `shipstation_order_number`.
5.  The script uses the resolved `shipstation_order_id` to query the ShipStation API.

## Full Workflow Script (`workflow.sh`)

The `scripts/workflow.sh` script orchestrates a common sequence of synchronization tasks:

1.  **Sync Orders:** Runs `src/scripts/sync-orders.ts` (passes through mode, ID, date range, dry-run, verbose, and tag sync options).
2.  **Populate Print Queue:** Runs `src/scripts/populate-print-queue.ts` to generate print tasks for newly synced or relevant orders.
3.  **Cleanup Shipped Tasks:** Runs the dedicated `src/scripts/cleanup-shipped-tasks.ts` script to mark tasks as completed for orders that are now shipped/cancelled in the database.

This workflow script provides a convenient way to run the standard sync process. It accepts the same flags as `sync-orders.ts` (e.g., `--mode`, `--order-id`, `--dry-run`, `--sync-tags`).

## Status Mismatch Correction (`fix-status-mismatch.ts`)

The `src/scripts/fix-status-mismatch.ts` script specifically addresses discrepancies between the order status in ShipStation and the local database.

- It fetches order status from both sources.
- If a mismatch is found (and `--fix` is used), it updates the database status.
- **Crucially**, it also checks if the order's final status is `shipped` or `cancelled`. If so (and `--fix` is used), it updates any associated `pending` or `in_progress` print tasks to `completed` or `cancelled`, respectively. This ensures task statuses align with the final order status, even if the order status itself didn't need correction during that specific run.
- Can be run for a specific `--order-id` (DB ID only) or for all orders.

## Command Examples

```bash
# Sync a specific order with confirmation prompts
npx tsx src/scripts/populate-print-queue.ts --order-id 202-7013581-4597156 --shipstation-sync-only

# Sync a specific order, bypassing confirmation prompts
npx tsx src/scripts/populate-print-queue.ts --order-id 202-7013581-4597156 --shipstation-sync-only --confirm

# Preview sync without making changes (dry run)
npx tsx src/scripts/populate-print-queue.ts --order-id 202-7013581-4597156 --shipstation-sync-only --dry-run

# Include debug logs
npx tsx src/scripts/populate-print-queue.ts --order-id 202-7013581-4597156 --shipstation-sync-only --log-level debug
```


<<< FILE: ./docs/TESTING.md >>>

# Testing Strategy

This document outlines the testing strategy for the Y3DHub project.

## Overview

We aim for a comprehensive testing approach covering different levels:

1.  **Unit Tests**: Test individual functions, modules, and components in isolation.
2.  **Integration Tests**: Test the interaction between different parts of the system (e.g., API endpoints and database).
3.  **End-to-End (E2E) Tests**: Test user flows through the application interface.
4.  **Script Tests**: Test the functionality of command-line scripts.

## Tools and Frameworks

- **Unit/Integration Tests**: [Jest, Vitest, etc.]
- **E2E Tests**: [Cypress, Playwright, etc.]
- **Assertion Library**: [Jest expect, Chai, etc.]
- **Mocking**: [Jest mocks, Sinon.JS, etc.]

## Test Coverage

- We aim for high test coverage, particularly for critical business logic (`src/lib`) and utility functions.
- Coverage reports will be generated regularly.

## Running Tests

- **All Tests**: `npm test` or `yarn test`
- **Unit Tests**: `npm run test:unit`
- **Integration Tests**: `npm run test:integration`
- **E2E Tests**: `npm run test:e2e`

[Update commands based on the chosen testing framework.]

## Writing Tests

- Follow standard testing practices (Arrange-Act-Assert).
- Write clear and descriptive test names.
- Keep tests independent and focused.
- Use mocking effectively to isolate units.

## Continuous Integration (CI)

- Tests will be run automatically in the CI pipeline on every push/pull request.
- Build failures will occur if tests fail.

[Describe the CI setup, e.g., GitHub Actions.]


<<< FILE: ./docs/TODO.md >>>

# Y3DHub Post-Refactoring TODO

This file tracks the remaining tasks after the major script consolidation and refactoring effort (completed ~April 2025).

## Remaining Tasks

### Phase 9: Documentation and Finalization (Day 9)

- [ ] Update all script documentation with JSDoc comments
- [ ] Create detailed README for each module
- [ ] Update crontab configuration (crontab-config.txt)
- [ ] Fix any remaining ESLint warnings
- [ ] Remove deprecated scripts
- [ ] Final verification of all functionality

### Phase 10: Deployment (Day 10)

- [x] Test in staging environment
- [ ] Update production documentation
- [ ] Deploy to production
- [ ] Monitor initial execution
- [ ] Handle any post-deployment issues 


<<< FILE: ./docs/TROUBLESHOOTING.md >>>

# Troubleshooting Guide

This document provides guidance for diagnosing and fixing common issues in Y3DHub.

## Common Issues

### Script Failures

- **Symptom**: A script (e.g., `amazon-customization.ts`) fails to run or exits with an error.
- **Diagnosis**:
  - Check the script logs (e.g., `$LOG_DIR/cron_amazon_workflow_*.log`).
  - Run the script manually with `--verbose` for more details.
  - Check database connectivity.
  - Verify environment variables (`$Y3D_DIR`, `$LOG_DIR`).
- **Fixes**:
  - Correct any configuration errors.
  - Address database issues.
  - Consult specific script documentation (e.g., `docs/Amazon/AMAZON_CUSTOMIZATION_UNIFIED_SCRIPT.md`).

### Data Discrepancies

- **Symptom**: Data in the UI or database doesn't match the source (e.g., ShipStation, Amazon).
- **Diagnosis**:
  - Check script logs for sync errors.
  - Manually compare data between systems.
  - Investigate timestamp conversion issues (see `docs/timezone-handling.md`).
  - **Print Tasks Pending for Shipped Orders**: If print tasks remain `pending` or `in_progress` even after the corresponding order is marked `shipped` in the database, this might have been due to an older version of the `fix-status-mismatch.ts` script.
- **Fixes**:
  - Ensure you are using the latest version of `fix-status-mismatch.ts` (updated April 17, 2025 or later).
  - Run the dedicated cleanup script: `npx tsx src/scripts/cleanup-shipped-tasks.ts` (use `--dry-run` first).
  - Alternatively, run the full workflow: `./scripts/workflow.sh` (use `--dry-run` first).
  - Rerun relevant sync scripts (`sync-orders.ts`).
  - Use fix commands if available (e.g., `amazon-customization.ts fix`).
  - Manually correct data if necessary.

### UI Errors

- **Symptom**: Errors or unexpected behavior in the web interface.
- **Diagnosis**:
  - Check the browser's developer console for errors.
  - Check the Next.js server logs.
  - Verify API endpoint responses.
- **Fixes**:
  - Clear browser cache.
  - Restart the Next.js server.
  - Debug frontend code.

[Add more common issues and troubleshooting steps.]

## Debugging Tools

- Verbose logging (`--verbose` flag in scripts)
- Dry runs (`--dry-run` flag in scripts)
- Browser developer tools
- Database query logs
- Specific order processing (`--order-id` flag)

## Deploying to Netlify via CLI

1. Install the Netlify CLI if you haven't already:

   ```bash
   npm install -g netlify-cli
   ```

2. Login to Netlify:

   ```bash
   netlify login
   ```

3. **Build your site (if required):**

   - For most frameworks (like Next.js, React, etc.), run:
     ```bash
     npm run build
     ```
   - Make sure the output directory matches your Netlify settings (e.g., `out`, `build`, or `.next`).

4. Deploy your site (from your project root):

   ```bash
   netlify deploy
   ```

   - For production:
     ```bash
     netlify deploy --prod
     ```

5. Follow the prompts to select your site or create a new one.


<<< FILE: ./docs/linting-guide.md >>>

# Y3DHub Linting Guide

This guide outlines our approach to code quality for the Y3DHub project.

## Current Approach

We've implemented a balanced approach to linting that allows builds to succeed while maintaining code quality standards:

1. **Build without linting**: Our main build process skips linting to ensure successful deployments
   ```json
   "build": "NEXT_TELEMETRY_DISABLED=1 next build --no-lint"
   ```

2. **Tiered linting rules**:
   - Core application code has stricter linting
   - Script files have relaxed rules (no return type requirements)

3. **Available lint commands**:
   - `npm run lint` - Basic linting
   - `npm run lint:full` - Full linting across all source code
   - `npm run lint:fix` - Attempt to automatically fix issues

## Recommended Workflow

1. **Before committing code**:
   - Run `npm run lint` to catch major issues
   - Address any errors (red) immediately
   - Consider fixing warnings (yellow) when time permits

2. **Fixing common issues**:

   a) **Missing return types** (in application code):
   ```typescript
   // Before
   export async function getData() {
     // ...
   }

   // After
   export async function getData(): Promise<SomeType> {
     // ...
   }
   ```

   b) **Named imports from packages with default exports**:
   ```typescript
   // Before
   import pino from 'pino';
   const logger = pino();
   const streams = pino.multistream([...]);

   // After
   import pino, { multistream } from 'pino';
   const logger = pino();
   const streams = multistream([...]);
   ```

   c) **Line-specific disabling** (when necessary):
   ```typescript
   // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
   export async function complexFunction() {
     // Complex function where return type is difficult to express
   }
   ```

## Future Improvements

As the codebase matures, consider:

1. Re-enabling linting in the build process
2. Adding pre-commit hooks with husky for lint checks
3. Gradually upgrading warnings to errors for critical code quality issues

## Path Aliases

Remember that our codebase supports two formats of path aliases:
- `@components/...` - Standard format
- `@/components/...` - Alternative format (both work)

## Custom Dictionary

We maintain a custom dictionary in `.vscode/settings.json` for technical terms like "shipstation" and "shadcn". Add new terms there if you're getting spell-check warnings.


<<< FILE: ./docs/recommendations.md >>>

(Repo snapshot analysed: 2025‑04‑17)

    --------------------------------------------------------------------------------------------------------
    ---

    ## 1. 🚩 Critical Errors & Build Failures

    • src/scripts/populate-print-queue.ts : 1271 • TS2741 “Property ‘verbose’ is missing…”

        - const transactionOptions: ProcessingOptions = {
        -   dryRun: cmdOptions.dryRun,
        + const transactionOptions: ProcessingOptions = {
        +   dryRun: cmdOptions.dryRun,
        +   verbose: cmdOptions.debug,            // <-- add required field
            …

    • ESLint (blocking npm run lint) – 2 × any in customization.test.ts lines 42 & 63 → add explicit type.
    • Jest test file src/tests/print-tasks/update.test.ts is empty → Jest exits with failure flag on some CI
     set‑ups.
    • Prisma generate not run in CI; postinstall hook missing in Dockerfile → build fails in container
    images.
    • Netlify build: SESSION_PASSWORD length check logs error but still exits 0 → deployment continues in
    insecure mode (see §2).
    • Next.js warns about missing src/app/favicon.ico sizes; blocks production build with --strict flag.
    • TypeScript noImplicitReturns violated in 6 scripts (e.g. src/scripts/reprocess‑amazon‑colors.ts)
    causing tsc --strict failure.
    • ts-node/tsx invoked with absolute path /usr/bin/npx in server action; breaks Windows builds.
    • Tailwind v4 peer‑dependency conflict with PostCSS 8.4.39 raises “Unsupported engine” in fresh
    installs.
    • Jest config points to __mocks__/fileMock.js that does not exist – tests crash when components import
    images.

    --------------------------------------------------------------------------------------------------------
    ---

    ## 2. 🔒 Security Vulnerabilities

        1. HIGH • CWE‑306 (Unauthenticated Endpoint) – `GET /api/orders` has no auth or tenant filter → any
    internet user can enumerate full order history.
           Mitigation: wrap `getCurrentUser()` check + market/user scoped `where` clause.
        2. HIGH • CWE‑862 (Missing AuthZ) – `PATCH /api/print‑tasks/[taskId]` verifies session but not task
    ownership → horizontal privilege escalation.
           Patch: join through user->orders to ensure requester owns the task.
        3. HIGH • CWE‑77 (Command Injection) – `runPopulateQueueForOrder()` builds a shell string with
    user‑controlled `orderIdOrNumber`. Although numeric/regex‑checked, an attacker can pass “123;rm -rf /”
    via crafted marketplace pattern. Use `spawnFile` with arg array or `execFile`.
        4. MED • CWE‑798 (Weak Secret) – `SESSION_PASSWORD` warning only logs; server still boots with
    <32‑char key enabling cookie tampering. Fail hard if invalid.
        5. MED • CWE‑307 (Brute‑Force) – Login route lacks rate‑limiting / account lockout. Add Redis‑backed
     limiter or `@fastify/rate‑limit`.
        6. MED • CWE‑311 (Transport Encryption) – ShipStation & Amazon clients default to HTTPS but do not
    set `strictSSL`; rejectUnauthorized=false could sneak in via axios default override. Explicitly set
    `httpsAgent`.
        7. LOW • CWE‑352 (CSRF) – API routes rely solely on same‑origin cookies; no CSRF token on
    state‑changing POST/PATCH routes.
        8. LOW • CWE‑209 (Information Exposure) – Detailed stack traces logged to `console.error` and
    returned in 500 JSON in `/lib/errors.ts`. Strip before response.
        9. LOW • CWE‑565 (Hard‑coded Credentials) – Example docs contain live `sk‑…` placeholders; scrub
    before public push.
        10. LOW • CWE‑330 (Insufficient Randomness) – `resetPasswordToken` helper (src/lib/utils.ts) uses
    `Math.random()` instead of crypto.

    --------------------------------------------------------------------------------------------------------
    ---

    ## 3. 🐢 Performance Bottlenecks

    • populate-print-queue.ts (~1 600 LOC) loads all pending orders then processes sequentially – can take
    minutes. Suggest batching with Promise.allSettled (max concurrency = 5).
    • GET /api/orders does two separate queries for list & count; use Prisma $transaction([{…}, {…}])
    already – but still reads full count each call; cache count or use select count(*) OVER() if DB
    supports.
    • Amazon customization sync downloads ZIPs one‑by‑one; parallelize with p-limit.
    • React table re‑renders full list on every keystroke (debounce at 0 ms). Raise to 250 ms and memoize
    rows.
    • Large JSON logs written with fs.appendFile per loop → high I/O. Buffer per N records.
    • Missing DB index on print_order_task.status used in dashboards; add composite (status, updated_at).
    • Build time‑outs on Netlify due to Tailwind JIT scanning node_modules; add content exclude.
    • shipstationApi axios instance not re‑used across lambda invocations (cold‑start penalty). Move to
    top‑level module.
    • Unthrottled OpenAI calls risk rate‑limit errors; apply exponential backoff with openai-ratelimiter.
    • React embla-carousel not SSR‑friendly; lazy‑load on client only to shave 100 KB JS.

    --------------------------------------------------------------------------------------------------------
    ---

    ## 4. 🗜️ Code‑Size & Duplication

    • 3 × similar Amazon color‑reprocess scripts – merge into single scripts/amazon/colors.ts with
    sub‑commands.
    • populate-print-queue.ts combines CLI parsing, AI prompt creation, DB writes; split into: parser,
    AI‑adapter, task‑service.
    • Repeated if (!user) return 401 blocks in API routes – introduce withAuth(handler) middleware.
    • Multiple inline regexes for marketplace order numbers; already extracted to order-utils.ts but older
    copies remain – delete dupes.
    • Dead file src/tests/print-tasks/update.test.ts.
    • Legacy duplicates of check-order.js vs check_order.js (underscore vs camel).
    • Style helpers (clsx, cva) scattered; centralise into ui/ util.
    • Numerous JSON fixtures in repo root; move to tests/fixtures/ or delete if unused.
    • 400‑line React components (print‑queue table) violate max‑length; refactor into sub‑components.
    • Several bash helpers (fix-imports.sh, update-headers.sh) can be replaced with eslint‑fix
    & lint-staged.

    --------------------------------------------------------------------------------------------------------
    ---

    ## 5. 🎨 Style & Maintainability

    • Mixed import styles (absolute “@/…”, relative “../../”) within same folder – configure
    eslint-plugin-import/order.
    • 37 files with >120‑char lines; wrap for readability.
    • Inconsistent async error handling – some catch(console.error) without structured logger.
    • Unused vars flagged by TS 5’s exactOptionalPropertyTypes; enable noUnusedLocals.
    • Missing return‑type annotations in server actions (any).
    • CamelCase vs snake_case DB fields cause mapping confusion (shipstation_order_id). Add Prisma
    @@map/@map.
    • Components placed under app/ and components/; follow Next.js convention of colocated component
    folders.
    • props drilling in Print‑Queue pages; introduce context or TanStack query.
    • 20 % of CSS still in legacy .css instead of tailwind classes.
    • Docstrings absent on public util functions; adopt TSDoc.

    --------------------------------------------------------------------------------------------------------
    ---

    ## 6. 🧩 Architectural Observations

    Textual diagram

        ┌ app (Next.js routes & pages)
        │   └─ api/ (REST endpoints) ──┐
        │                              │
        ├ components/ (UI)             │
        ├ lib/                         │
        │   ├─ auth (iron‑session)     │
        │   ├─ orders/                 │
        │   ├─ shipstation/            │
        │   └─ actions/ (server)       │
        ├ scripts/ (one‑off CLIs)      │
        └ prisma/ (ORM layer) ─────────┘

    Hotspots: populate-print-queue.ts (God‑object), API layer tightly coupled to Prisma models, duplicate
    marketplace logic.
    Suggested redesign:
    • Introduce domain‑layer services (OrderService, TaskService) to isolate DB.
    • Use command‑bus pattern for background jobs (BullMQ).
    • Swap bespoke shell scripts for dedicated worker queue.
    • Adopt feature‑based folder structure to improve cohesion.

    --------------------------------------------------------------------------------------------------------
    ---

    ## 7. 🧪 Test‑Coverage Gaps

        1. No tests for `runPopulateQueueForOrder` happy‑path/command‑injection.
        2. Missing auth & authz tests (login, unauthorized access).
        3. No integration test for order → task creation flow (Amazon JSON → DB rows).
        4. ShipStation sync lacks contract test with mocked API.
        5. Critical AI prompt parsing not fuzz‑tested (edge JSON/HTML).
        6. No regression test for duplicate task creation on re‑run.
        7. Lacking db‑transaction rollback test on OpenAI failure.
        8. GET /api/orders pagination off‑by‑one case.
        9. React Print‑Queue renders not snapshot‑tested.
        10. Rate‑limit / brute force scenarios untested.

    --------------------------------------------------------------------------------------------------------
    ---

    ## 8. 🚀 Modernisation Opportunities

    • Replace raw child_process.exec with Node 20 child_process.execFile & promises.spawn.
    • Migrate Prisma to serverless driver (Data Proxy) for better cold‑start.
    • Use zod inference to auto‑generate TypeScript types for API schemas.
    • Adopt @nextui-org/theme + CSS variables, drop legacy CSS.
    • Enable Next.js App‑Router & React Server Components for heavy dashboard pages.
    • Swap custom logger for pino + transport to CloudWatch.
    • Integrate sentry for error capture, remove homemade handler.
    • CI: add GitHub Dependabot & npm audit --production.
    • Apply eslint --fix via lint-staged; enforce Prettier 3.
    • Use vitest instead of Jest for faster HMR & TS‑first testing.

    --------------------------------------------------------------------------------------------------------
    ---

    ## Executive Summary

    The codebase functions, but one TypeScript error and several ESLint violations currently block clean
    builds. More importantly, two unauthenticated/authorised API endpoints expose the entire order and task
    datasets, and a server‑side action builds shell commands from user input, making remote command
    execution feasible. Session security can also be bypassed if an operator forgets to set a strong secret.
     On the performance side, order‑processing scripts and dashboards run sequentially and synchronously,
    causing sluggish builds and page loads. The project would benefit from modularising a handful of
    1 000‑line files, consolidating duplicate scripts, and introducing unit/integration tests around
    authentication and order‑to‑task creation logic. Addressing the highlighted top issues will close
    critical security holes, cut build times, and pave the way for safer future feature work.


<<< FILE: ./docs/reference/local_llm_prompting.md >>>

Below are **two** commonly recommended open or permissively-licensed models in the **7B–14B** range, plus a **short prompt template** example you might use with them. I’ve also included some general tips for working with local language models in that parameter range.

---

## Recommended Models in the Up-to-14B Range

1. **Llama 2 13B**

   - Meta’s second-generation LLaMA model, with a 13B parameter variant.
   - Generally stronger than the original LLaMA1 or many 7B variants, especially at reasoning tasks.
   - Available under a custom licence that permits commercial use with some restrictions.
   - Typically uses around 20–24 GB VRAM in 16-bit mode, or less if you quantise (e.g., 8-bit, 4-bit).

2. **MPT-7B/13B (MosaicML)**
   - MosaicML Pretrained Transformer with versions up to 13B.
   - The 13B variant is new and can be used under certain licences depending on which finetune you pick (MPT-13B-Chat, for instance).
   - Good at following instructions if you pick a “chat” or “instruct” finetune.
   - Smaller VRAM footprint for 7B, but 13B obviously has bigger memory needs.

_(**Honourable Mentions**: Falcon 7B/13B, WizardLM 13B, or Guanaco 13B can also be decent, depending on your hardware and the style of instruction fine-tuning you prefer.)_

---

## Prompt Template Example

Below is a **highly condensed** prompt style for your “multi-personalisation eBay notes” scenario. Instead of repeating an entire multi-page set of rules, you can store them in a short “system prompt” or just keep them in one place. Then for each item, you append a short user prompt with the relevant data.

### System Prompt (Stable Instructions)

This can be loaded first, ensuring the model always follows these instructions:

```
System Prompt (Unchanging):
You are an AI assistant extracting personalisation details for 3D printing from a single e-commerce item. Return ONLY valid JSON with the key "personalizations".

Rules:
1) If 'customerNotes' has lines like "Item ID: ... Variation: Color=... Text: ...", each line = 1 object with "customText", "color1", "quantity=1", etc.
2) If only one personalisation or none, just return 1 object with the item’s "quantityOrdered".
3) Format "customText" in Title Case except for 2+ letter acronyms. If note says "(keep caps)", do exactly that.
4) If color is "Navy Blue", map to "Dark Blue" and add "annotation".
5) If something is missing or unknown color, set "needsReview": true.
6) The sum of all "quantity" must match "quantityOrdered", or set "needsReview": true.
7) The final JSON structure:
{
  "personalizations": [
    {
      "customText": "...",
      "color1": "...",
      "color2": "...",
      "quantity": 1,
      "needsReview": false,
      "reviewReason": null,
      "annotation": null
    }
  ]
}
No extra text or disclaimers.
```

### User Prompt (Per Item)

Then for each item you want to process, you feed something like:

```
User Prompt:
## Item Data
{
  "itemId": 1652,
  "quantityOrdered": 6,
  "printSettings": [ ... ],
  "orderContext": {
    "customerNotes": "Personalisation:\nItem ID: 123 Variation: Color=Red\nText: ACCC\nItem ID: 123 Variation: Color=Blue\nText: Buddy"
  }
}

Produce only the JSON as per the system rules.
```

**That’s it.** The system prompt is loaded first (the stable instructions). You append the user prompt with the actual data. The model should then output something like:

```json
{
  "personalizations": [
    {
      "customText": "ACCC",
      "color1": "Red",
      "color2": null,
      "quantity": 1,
      "needsReview": false,
      "reviewReason": null,
      "annotation": null
    },
    {
      "customText": "Buddy",
      "color1": "Blue",
      "color2": null,
      "quantity": 1,
      "needsReview": false,
      "reviewReason": null,
      "annotation": null
    },
    {
      "customText": null,
      "color1": null,
      "color2": null,
      "quantity": 4,
      "needsReview": true,
      "reviewReason": "Quantity mismatch (2 extracted vs. 6 ordered).",
      "annotation": null
    }
  ]
}
```

_(In this example, the final object lumps the “remaining 4” items as “unclear” or “missing instructions,” so it set `needsReview: true`. Exactly how you handle that is up to your logic.)_

---

## Additional Recommendations

1. **Quantisation**: For 13B models, you might run out of VRAM if you only have a 16 GB GPU. Many people quantise to 4-bit (Q4) or 8-bit to fit. Performance can still be good, but test carefully for any accuracy drop.

2. **Temperature, Top-p, Repetition Penalty**: Tweaking generation settings can help your local model stay on track. Typically:

   - Temperature ~ `0.2`–`0.5` for more deterministic compliance.
   - Repetition penalty ~ `1.1`–`1.2` to avoid loops.

3. **Token Limits**: A 13B model typically handles ~2K–4K tokens context window (depending on the model variant). If your data is large, keep your prompt short or break items into multiple calls.

4. **Chain-of-Thought**: Some models may attempt to produce “thinking” steps. To avoid that in the final output, keep emphasising “Return JSON only. No extra text.”

5. **Compare** 7B vs 13B: If your hardware or speed constraints are strong, a well-tuned 7B can be enough for simpler extraction tasks. But 13B is usually more reliable in consistent formatting and following instructions.

---

### TL;DR

- **Llama 2 13B** and **MPT-13B** are good under ~14B.
- Keep instructions short and load them once (system prompt).
- Provide minimal but clear user data.
- Force “Return JSON only.”
- Test your generation settings to ensure stable results.

That’s the recommended approach for your scenario!


<<< FILE: ./docs/scripts/cleanup.md >>>

# Cleanup Utilities

The project provides a unified cleanup utility to manage temporary files, build artifacts, and other cleanup tasks.

## clean.ts

Located at `src/scripts/clean.ts`, this script handles all cleanup operations:

```bash
# Basic cleanup
npx tsx src/scripts/clean.ts

# Dry run (shows what would be removed without actually removing)
npx tsx src/scripts/clean.ts --dry-run

# Verbose output
npx tsx src/scripts/clean.ts --verbose

# Include browser caches
npx tsx src/scripts/clean.ts --browser-caches

# Include node_modules
npx tsx src/scripts/clean.ts --node-modules

# Include example files
npx tsx src/scripts/clean.ts --example-files

# Skip log files
npx tsx src/scripts/clean.ts --no-logs

# Specify a different directory
npx tsx src/scripts/clean.ts --dir /path/to/directory
```

## NPM Scripts

The following npm scripts are available for cleanup:

```bash
# Basic cleanup
npm run clean

# Full cleanup (includes browser caches and node_modules)
npm run clean:all

# Dry run with verbose output
npm run clean:dry
```

## What Gets Cleaned

The cleanup utility removes the following by default:

- Temporary files (`*.tmp`, `*.temp`, `*.bak`, `*.old`)
- Cache directories (`.turbo`, `.swc`, `.ruff_cache`, etc.)
- Build artifacts (`.next`, `build`, etc.)
- Log files (`*.log`, `logs/` directory)
- IDE files (except `.vscode`)

With additional options, it can also clean:

- Browser caches (Playwright, Puppeteer)
- Node modules (`node_modules/` directory)
- Example files (`example*.jpg`, `example*.png`, `example*.json`)

## Cron Job

A daily cleanup is scheduled in the crontab configuration:

```
# Run daily cleanup at 2 AM
0 2 * * * cd $Y3D_DIR && /usr/bin/npx tsx src/scripts/clean.ts >> $LOG_DIR/cleanup_`date +\%Y\%m\%d`.log 2>&1
```

## Implementation Details

The cleanup functionality is implemented in `src/lib/utils/cleanup.ts`, which provides a modular and extensible approach to cleaning different types of files and directories.

The implementation uses:
- `globby` for pattern matching
- `fs/promises` for file operations
- Proper error handling and reporting
- Dry run capability for safe testing
- Verbose logging for detailed output


<<< FILE: ./docs/scripts/crontab.md >>>

# Cron Job Configuration

This document provides the recommended cron job configuration for the Y3DHub system. These cron jobs ensure that the database is kept up-to-date with the latest orders and that print tasks are generated and cleaned up as needed.

## Key Points & FAQ (Why npm run full-workflow runs >1 hour? Timezone issues?)

**Q: Why does `npm run full-workflow -- --mode recent --hours 1 --skip-tags` appear to pull much more than 1 hour's worth of data?**

### A: Timezone Mismatch (ShipStation uses Pacific Time, You specify UTC/Local)

- **Root Cause:**
  - ShipStation API expects `modifyDateStart` in Pacific Time (`America/Los_Angeles`), while the workflow (`sync-orders` and background scripts) often interpret or calculate `--hours 1` as local server time (likely UTC in your environment).
  - **This results in the system fetching a wider time range**: for example, 1 hour back _in UTC_ actually covers up to 8 extra hours (or 7 during daylight savings) because Pacific Time is behind UTC.

**_Example_**:
  - If it is 10:00 UTC (server time) and you specify `--hours 1` (i.e. 09:00 UTC), the API request for ShipStation becomes `modifyDateStart=09:00 UTC`, but **ShipStation interprets this as 09:00 Pacific!**
  - ShipStation thinks you want all orders _since 09:00 Pacific Time_, so it returns far more data (08:00 or 07:00 hours difference).

**_Consequences_**:
  - Your script then pulls up to 8 hours of orders instead of 1 hour.
  - If run in a loop or successive cron, it overlaps or duplicates work, and appears to take much longer, especially when using small ranges (1 hour).

**Q: Is it a bug in the script?**
- **Not a fundamental bug, but a timezone awareness pitfall.** The code base tries to handle timezones carefully (see `docs/timezone-handling.md`), but if you specify UTC times, ShipStation expects Pacific Time for `.modifyDateStart` and interprets all date params as such.

## How to Fix or Mitigate

**1. Always consider timezones when supplying --hours/--days-back or modifyDateStart!**
  - When you pass `--hours N` to the workflow, double-check how your script computes the actual filter time sent to ShipStation.
  - Consider adjusting the code to convert UTC/local time → Pacific Time before setting `modifyDateStart`, or explicitly use a wider window (e.g., with a buffer).

**2. What does the workflow do?**  (Relates to resource/time usage)
The `npm run full-workflow` command, by default, performs these steps:
  1. Syncs orders from ShipStation (using `src/scripts/sync-orders.ts`). If you specify `--hours 1`, see above for possible over-pulling.
  2. Populates the print queue (AI & Amazon customization extraction).
  3. (Optionally) Cleans up print tasks.

**3. Adjust for ShipStation's Pacific Time**
  - If editing code or manually syncing, use a time window in Pacific (e.g., `date -d '1 hour ago PDT' +%Y-%m-%dT%H:%M:%SZ`).
  - **Or**, use a slightly larger window for reliability and filter duplicate orders _after_ fetching, but be aware you may process more than the expected number of orders.
  - For guaranteed incremental sync: always store the last ShipStation order’s `.modifyDate` (in UTC) after each run, and use it as the next `.modifyDateStart` but **convert to Pacific Time** before querying.

## Reference Snippet from the sync script
You’ll see logic similar to:
```js
const SHIPSTATION_TIMEZONE = "America/Los_Angeles";
modifyDateStart = format(tz(sub(new Date(), { hours: N }), SHIPSTATION_TIMEZONE), "yyyy-MM-dd'T'HH:mm:ss")
```
But if your code only does UTC math, it will pull an unexpectedly large window.

## Quick TL;DR (for production operations)
- If you specify `--hours 1` (with UTC), ShipStation gives all orders since "that Pacific hour" (which is currently 7 or 8 hours behind UTC), resulting in over-pulling orders.
- **Convert your intended window to Pacific before running when using manual or one-off runs.**
- The best practice is always store and use the last processed ShipStation `.modifyDate` from the API, and use that (in Pacific) as your next filter.

## Example Config Correction (in crontab/new_crontab.txt):
```
# Sync recent orders every 10 minutes (looking back 2 hours)
*/10 * * * * cd $Y3D_DIR && /usr/bin/npx tsx src/scripts/sync-orders.ts --hours=2 >> $LOG_DIR/cron_sync_orders_recent_`date +\%Y\%m\%d`.log 2>&1
```
**This approach uses a _wider window (2 hours)_ per 10-minute interval, which covers timezone mismatches, API delays, and ShipStation idiosyncrasies.**
Any duplicated orders are de-duplicated by upsert logic in the sync script.

**Avoid running with strictly small `--hours N` values (e.g., 1) unless you are certain your server and ShipStation operate in the same timezone.**

## See Also
- [docs/timezone-handling.md] -- Full explanation of date handling in Y3DHub
- [docs/COMMAND_REFERENCE.md] -- Details of all flags and sync script
- [src/scripts/sync-orders.ts] -- Source code for main sync script

---

# Original Sample Crontab Block (for reference)

```
# Sync recent orders every 10 minutes (looking back 2 hours)
*/10 * * * * cd $Y3D_DIR && /usr/bin/npx tsx src/scripts/sync-orders.ts --hours=2 >> $LOG_DIR/cron_sync_orders_recent_`date +\%Y\%m\%d`.log 2>&1

# Sync orders from the past day, three times daily (6am, 2pm, 10pm)
0 6,14,22 * * * cd $Y3D_DIR && /usr/bin/npx tsx src/scripts/sync-orders.ts --days=1 >> $LOG_DIR/cron_sync_orders_daily_`date +\%Y\%m\%d`.log 2>&1
```

This configuration deliberately uses a larger window (`--hours=2` or `--days=1`) than your cron interval, to ensure any drift or overlap is covered.

---

# See also
- [docs/timezone-handling.md] for full details on ShipStation/UTC/Pacific Time logic
- [docs/COMMAND_REFERENCE.md] for flags explanation
- [src/scripts/sync-orders.ts] for sync logic
- [src/lib/orders/sync.ts] for time window calculation logic

---

# Summary Table

| Option/Flag         | Meaning in Y3DHub Script                               | Effect re: ShipStation     |
|---------------------|--------------------------------------------------------|----------------------------|
| `--hours N`         | Fetch orders back to N hours in your system time/UTC   | ShipStation interprets it as Pacific, so actual window is wider |
| `--days-back N`     | Fetch back N days in system time                       | Same as above, but with days |
| `--force-start-date`| Force fetch from a specific date/time                  | Should use Pacific timezone |
| *Recommended*       | Use a buffer (fetch a wider window than your cron period), and always upsert/deduplicate in your sync step |



<<< FILE: ./scripts/README.md >>>

# Scripts Directory

This directory contains various utility scripts for the Y3DHub application, primarily located within the `utils/` subdirectory.

## Utility Scripts (`./utils/`)

General utility scripts:
- `backup-print-tasks.ts` - Creates backups of print tasks
- `check-ai-logs.ts` - Checks AI call logs
- `check-logging.ts` - Verifies logging functionality
- `ai-usage-stats.ts` - Generates statistics on AI usage (Used by cron)
- `run-with-env.sh` - Shell script for running commands with environment variables
- `reprocess-all-orders.ts` - Reprocesses all orders

## Running Scripts

Most scripts can be run using:

```bash
npx tsx scripts/utils/script-name.ts [arguments]
```

For shell scripts:

```bash
bash scripts/utils/script-name.sh [arguments]
```

## Note on New Scripts

For new core application scripts (e.g., those run by cron or essential for core processes), consider placing them in the `src/scripts/` directory alongside other primary application code. This directory (`scripts/`) is primarily intended for manual utilities, one-off tasks, or auxiliary scripts.

## Full Workflow (`npm run full-workflow`)

The `full-workflow` script (`npm run full-workflow`) runs the complete end-to-end Y3DHub process:
1. Sync orders from ShipStation
2. Populate the print queue
3. Cleanup completed print tasks

Usage:
```bash
npm run full-workflow -- [options]
```

Options:
- `--mode <all|recent|single>`  Which orders to sync (default: recent)
- `--order-id <ID>`             Only sync a single order (requires `--mode single`)
- `--days-back <N>`             Days to look back when mode is `recent` (default: 2)
- `--hours <N>`                 Hours to look back when mode is `recent` (overrides `--days-back`)
- `--dry-run`                   Show actions without making changes
- `--verbose`                   Enable verbose console output
- `--skip-tags`                 Skip ShipStation tag synchronization (handled by separate daily job)

Concurrency:
The script uses a filesystem lock at `/tmp/y3dhub_workflow.lock` to prevent concurrent executions.


<<< FILE: ./src/scripts/README.md >>>

# Background Processing Scripts

This directory contains scripts responsible for background data synchronization and processing tasks essential for the application's workflow.

## Table of Contents

- [Order Synchronization (`sync-orders.ts`)](#order-synchronization-sync-ordersts)
  - [Purpose](#purpose)
  - [Process Flow](#process-flow)
  - [Key Logic Points](#key-logic-points)
  - [Usage](#usage)
  - [Configuration](#configuration)
- [Print Task Population (`populate-print-queue.ts`)](#print-task-population-populate-print-queuets)
  - [Purpose](#purpose-1)
  - [Process Flow](#process-flow-1)
  - [Key Logic Points](#key-logic-points-1)
  - [Usage & Flags](#usage--flags)
  - [Configuration](#configuration-1)
- [Database Logging (`ScriptRunLog`)](#database-logging-scriptrunlog)
- [Running Scripts (Cron/Scheduled Tasks)](#running-scripts-cronscheduled-tasks)

---

## Order Synchronization (`sync-orders.ts`)

### Purpose

Fetches recent order data from the ShipStation API and synchronizes it with the local application database (`Customer`, `Product`, `Order`, `OrderItem` tables).

### Process Flow

1.  **Authentication:** Connects to ShipStation using API Key/Secret.
2.  **Fetch Data:** Retrieves orders modified since a specific start date (logic might need refinement for continuous syncing).
3.  **Iterate Orders:** Processes each fetched ShipStation order individually.
4.  **Upsert Customer:** Creates a new `Customer` record or updates an existing one based on `shipstation_customer_id` or email/name, using the shipping address details.
5.  **Transaction Per Order:** Starts a Prisma transaction (`prisma.$transaction`) to ensure atomicity for all changes related to a single order.
6.  **Process Items (within Transaction):** For each `item` in the ShipStation order:
    - **Upsert Product:** Creates/updates a `Product`. It first tries to match using `shipstation_product_id` (if provided), falling back to `sku` (trimmed of whitespace). If the name is missing from ShipStation, it uses the placeholder `"Product Needs Name"`. Handles potential unique constraint errors on upsert by attempting a lookup.
    - **Upsert OrderItem:** Creates/updates an `OrderItem`, linking it via `productId` to the corresponding `Product` record and via `orderId` to the parent `Order`. Uses `shipstationLineItemKey` as the primary key for upserting.
7.  **Upsert Order:** Creates/updates the main `Order` record (using `shipstation_order_id` for upserting), linking it to the upserted `Customer`. Maps standard and custom/optional fields.
8.  **Commit/Rollback:** The transaction commits if all upserts within it succeed. If any database error occurs, the entire transaction for that order is rolled back.

### Key Logic Points

- **Upsert Strategy:** Heavily relies on `prisma.*.upsert` with unique fields (`shipstation_order_id`, `shipstation_customer_id`, `sku`, `shipstation_product_id`, `shipstationLineItemKey`) to ensure data consistency and avoid duplicates.
- **Product Linking:** Critical step to link `OrderItems` to canonical `Product` records based on SKU or ShipStation ID.
- **Data Integrity:** Transactions prevent partially synchronized orders. Fallback names and SKU trimming help handle inconsistent source data.
- **Error Handling:** Logs errors during customer/product/order upserts but typically continues processing other orders. Transaction failures are logged.

### Usage

```bash
# Ensure environment variables are set in .env
npm run sync-orders
# or directly
tsx src/scripts/sync-orders.ts
```

_(Note: Lacks command-line flags for date ranges or specific order sync. Environment variables control API keys.)_

### Configuration

Requires environment variables (in `.env`):

- `DATABASE_URL`: Database connection string.
- `SHIPSTATION_API_KEY`: ShipStation API Key.
- `SHIPSTATION_API_SECRET`: ShipStation API Secret.

---

## Print Task Population (`populate-print-queue.ts`)

### Purpose

Identifies orders requiring personalized print tasks, uses OpenAI to interpret personalization details from `OrderItem.print_settings`, and creates `PrintOrderTask` records for the print queue UI. Designed for frequent execution (e.g., cron).

### Process Flow

1.  **Log Script Start:** Creates an initial entry in `ScriptRunLog` with `status: 'running'`.
2.  **Find Eligible Orders:** Queries the database (`findOrdersForProcessing`) for orders meeting criteria:
    - `order_status` is `awaiting_shipment` or `on_hold`.
    - Contains at least one `OrderItem` where `print_settings` is not null AND `productId` is greater than 0.
    - **Crucially (for efficiency):** Excludes orders where _any_ item already has _any_ associated `PrintOrderTask`. (`NOT: { items: { some: { printTasks: ... } } }`). This prevents reprocessing completed/partially completed orders in normal runs.
    - Respects the `ORDER_PROCESSING_LIMIT` (default 10).
    - Logs initial candidates and final selected orders (after filtering out those with existing tasks).
3.  **Iterate Through Orders:** Loops through the fetched orders (up to the limit). If 0 orders selected, finishes early.
4.  **Transaction Per Order:** Starts a database transaction (`prisma.$transaction`) for each selected order.
5.  **Filter Processable Items:** Within the transaction, filters the order's items again to ensure `print_settings`, `productId`, and `product` data are present.
6.  **Iterate Through Items:** Loops through the processable items within the current order.
7.  **Check Existing Item Tasks:** Queries `tx.printOrderTask.findFirst` for the current `orderItemId`.
    - If tasks exist AND the `--force-recreate` flag was **NOT** used, logs `Skipping Item X: Print task(s) already exist...` and `continue`s to the next item.
    - If tasks exist AND `--force-recreate` **WAS** used, logs deletion, runs `tx.printOrderTask.deleteMany`, then proceeds.
8.  **AI Call:** If tasks don't exist (or were just deleted by `--force-recreate`), waits `AI_CALL_DELAY_MS`, then calls `extractOrderPersonalization` with item details and order context.
9.  **Validate AI Response:**
    - Checks for API errors, JSON parsing errors, missing `tasks` array.
    - Validates structure of each task in the `tasks` array.
    - Calculates `totalQuantity` from valid AI tasks.
    - **Quantity Check:** If `totalQuantity !== originalItem.quantity`, considers it an AI error, returns an error state (`{tasks: [], error: 'Quantity mismatch...', ...}`).
    - If valid, returns the validated tasks and review status.
10. **Handle AI Result:**
    - If `extractOrderPersonalization` returned an error state (API error, parse error, quantity mismatch, etc.) OR empty tasks:
      - Logs the specific reason for skipping task creation.
      - If `CREATE_PLACEHOLDER_ON_AI_ERROR` is true AND there was an error (not just 0 tasks returned), attempts to create a single placeholder task marked for review. Logs success/failure of placeholder creation.
      - `continue`s to the next item.
11. **Create Tasks:** If the AI result was valid:
    - Loops through `taskDetail` in `aiResult.tasks`.
    - Prepares `taskData` object, connecting `Order`, `OrderItem`, and `Product`.
    - Logs the `taskData` being attempted (if not dry run).
    - Calls `tx.printOrderTask.create({ data: taskData })`.
    - Logs success or handles errors:
      - `P2002` (Unique Constraint): Logs a warning (`Skipping Task X: Unique constraint violation...`) and continues.
      - Other Errors: Logs the full error and **re-throws it** to ensure the **entire order transaction is rolled back**.
12. **Commit/Rollback:** The transaction attempts to `COMMIT` after all items in an order are processed. If any error was thrown during item processing (step 11), the transaction automatically `ROLLBACK`.
13. **Log Order Failure:** If the transaction for an order fails (catches error in `main`), logs a specific `ScriptRunLog` entry with `status: 'order_failure'`, order ID, and error details.
14. **Update Final Script Log:** In the `finally` block:
    - Determines overall status (`success`, `partial_success`, `success_no_orders`, or `failed` if caught by main try/catch).
    - Updates the initial `ScriptRunLog` entry with the end time, final status, and summary details (counts, failed IDs).

### Key Logic Points

- **Batching & Filtering:** Processes orders in limited batches (`ORDER_PROCESSING_LIMIT`), efficiently filtering out already processed orders in normal runs.
- **Item Skipping:** Avoids redundant AI calls for items already processed within a potentially partially processed order (unless forced).
- **Targeted Re-creation:** `--force-recreate` flag allows deleting and regenerating tasks for specific items/orders without clearing everything.
- **Robust AI Validation:** Checks structure, types, and critically, the total quantity returned by the AI against the order item.
- **Transactional Integrity:** Ensures all tasks for an order are created together or none are (rollback on error).
- **Comprehensive Logging:** Logs script start/end, order processing status, item skipping reasons, AI errors, task creation attempts/data/outcomes, and transaction failures to both console and the `ScriptRunLog` database table.

### Usage & Flags

```bash
# Normal run (processes next batch of unprocessed orders)
npm run populate-queue

# Force recreate tasks for a specific order
npm run populate-queue -- --order-id 123 --force-recreate

# Force recreate tasks for the next batch of orders
npm run populate-queue -- --force-recreate

# See other flags (--days-back, --dry-run, --clear-all, --prune-shipped)
npm run populate-queue -- --help
```

### Configuration

Requires environment variables (in `.env`):

- `DATABASE_URL`
- `OPENAI_API_KEY`
- `AI_CALL_DELAY_MS` (Default: `100`)
- `CREATE_PLACEHOLDER_ON_AI_ERROR` (Default: `false`)
- `ORDER_PROCESSING_LIMIT` (Default: `10`)

---

## Database Logging (`ScriptRunLog`)

Tracks script executions:

- **Initial Entry:** Created at start (`status: 'running'`).
- **Order Failure Entry:** Created _if_ an order's transaction fails (`status: 'order_failure'`). Contains specific order ID and error.
- **Final Update:** Initial entry updated at end with `runEndedAt`, final `status` (`success`, `partial_success`, `success_no_orders`, `failed`), and JSON `details` (counts, failed IDs).

Monitor this table for script health and potential alerting on `'failed'` or `'order_failure'` statuses.

---

## Running Scripts (Cron/Scheduled Tasks)

Schedule these scripts using cron (Linux/macOS) or Task Scheduler (Windows).

- `sync-orders.ts`: Schedule less frequently (e.g., every 15-60 minutes) as needed for data freshness.
- `populate-print-queue.ts`: Schedule
